<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.101" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Identifier" content="urn:ietf:rfc:68" />
<meta name="DC.Creator" content="M. Elie" />
<meta name="DC.Date.Issued" content="August, 1970" />
<meta name="DC.Title" content="Comments on Memory Allocation Control Commands: CEASE, ALL, GVB, RET, and RFNM" />

    <link rel="icon" href="/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="/images/rfc.png" type="image/png" />
    <title>RFC 68 - Comments on Memory Allocation Control Commands: CEASE, ALL, GVB, RET, and RFNM</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>          <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>            <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>    <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>     <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td><td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td><td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard:</td>   <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>         <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>         <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgwhite"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc68.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc68" title="PDF version of this document">pdf</a>]                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                           M. Elie
Request for Comments #68                                        31 August 70
                                                                UCLA

             Comments on memory allocation control commands
                     CEASE, ALL, GVB, RET) and RFNM

The protocol provides a scheme for buffer allocation.  This scheme is
rather complicated because it necessitates two parallel mechanisms.
It is not obvious that both are necessary.  In fact it is suggested
that this scheme could be probably replaced by a slightly different
conception of the Request for Next Message (RFNM).  Now the RFNM is
sent back from the receiving imp after the message has been
reconstituted and the first packet transmitted to the host.  Nothing
insures that the whole message has been accepted and correctly
received by the host; also the design of the host imp interface
permits the host to stop accepting data from the imp during any length
of time; as the link has been already unblocked by sending back the
RFNM another message may be transmitted by the sending foreign host
which will congest the imp's memory.  On the other hand it is prob-
able that usually the host is able to accept data from the imp at a
higher rate than it is transmitted on the network, e.g. 200k bits/sec;
thus the time to transmit a full message from the imp to the host
would be approximately 1/20th of a second which is 10 times less than
the average delay of transmission of a message over the network.  This
indicates that to send a RFNM after the reception of a full message by
the host would not increase significantly the response time on the
network.

In this case there is no reason why the RFNM could not be initiated by
the receiving host as an acknowledgment of the correct reception of
the message (ACK), and take the form of either a host imp or a control
command message.  This RFNM could have the two forms

         ACK  (CONTINUE)
or       ACK  (CEASE)

This would permit to add to the message some error detection
redundancy, such as check sum bits as proposed in [DELO 69].  In the
present design nothing insures that one or several bits of the text
has not been altered, e.g., by an interference or a deficiency of one
of the host imp interfaces.  This could have important consequences,
e.g. if the text is used to update a centralized data base.  Also, if
the user has a way of detecting the error, but none of correcting it,
it has no way of asking for the retransmission of the message, which
has probably been discarded at the sending end upon reception of the
RFNM.  In fact it seems not up to the user to have to detect errors in




<span class="grey">                                                                [Page 1]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey">Network Working Group                                           M. Elie</span>
Request for Comments #68                                        31 August 70
                                                                UCLA

its text but rather up to the NCP: the user process must as much as
possible act as if it was talking to some other local process.  So a
third kind of RFNM sent by the NCP could be:

            NAK(REPEAT)

Repetition would also be initiated in case of no reply.

Thus we see that it seems worthwhile to make these slight
modifications which would permit to use between the sending host and
the receiving host a very simple point-to-point transmission procedure
which would insure control of the data transmitted from end-to-end.

It could also replace the memory allocation mechanism: ACK (CONTINUE)
would only be sent if space was available for a new message on this
connection and/or ACK (CEASE) would be sent if no more space was
available; it corresponds to the WABT of classic transmission
procedures [USAS69]; transmission could be resumed by an ACK
(CONTINUE) or a RESUME from the receiving end.  The user process is
not mixed at all with this memory allocation which is a function of
the system (or NCP): it only sees a varying global transmission speed
of its data on a connection.  The imp programs take care of the
routing of the data according to the distributed nature of the
network, and neither the user nor the system (or NCP) is concerned
with it.  Other improvements to the protocol may be found after
experiencing it.

Finally note that this solution does not immobilize the imp memory any
longer than the actual solution, because it is not the imp which has
to repeat a message, but the sending host.


______________________________________________

DELO 69 DELOCHE G.  Implementation of the Host-Host Software
        Procedures in GORDO Network Working Group RFC #11 Aug 1969

USAS 69 Proposed USA standard data communication control procedures
        for USASCII CACM Vol. 12 NB 3 March 1969 PB 166-178


       [ This RFC was put into machine readable form for entry ]
        [ into the online RFC archives by Kai Henningsen 6/97 ]




                                                                [Page 2]

</pre><br />
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.101, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>
</body></html>
