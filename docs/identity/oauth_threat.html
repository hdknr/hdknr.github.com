

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Auth 2.0 Threat Model and Security Considerations &mdash; identity 1.0 documentation</title>
    
    <link rel="stylesheet" href="static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    <link rel="stylesheet" href="static/openid.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="identity 1.0 documentation" href="index.html" />
    <link rel="next" title="The OAuth 2.0 Protocol: Bearer Tokens" href="bearer.html" />
    <link rel="prev" title="OAuth 2.0 Multiple Response Type Encoding Practices" href="oauth_responses.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>identity 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Auth 2.0 Threat Model and Security Considerations</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="oauth_responses.html">OAuth 2.0 Multiple Response Type Encoding Practices</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="bearer.html">The OAuth 2.0 Protocol: Bearer Tokens</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="auth-2-0-threat-model-and-security-considerations">
<h1><a class="toc-backref" href="#id34">Auth 2.0 Threat Model and Security Considerations</a><a class="headerlink" href="#auth-2-0-threat-model-and-security-considerations" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://tools.ietf.org/html/draft-ietf-oauth-v2-threatmodel-0">draft-ietf-oauth-v2-threatmodel-01</a></p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#auth-2-0-threat-model-and-security-considerations" id="id34">Auth 2.0 Threat Model and Security Considerations</a><ul>
<li><a class="reference internal" href="#abstract" id="id35">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id36">1.  Introduction</a></li>
<li><a class="reference internal" href="#overview" id="id37">2.  Overview</a><ul>
<li><a class="reference internal" href="#scope" id="id38">2.1.  Scope</a></li>
<li><a class="reference internal" href="#attack-assumptions" id="id39">2.2.  Attack Assumptions</a></li>
<li><a class="reference internal" href="#architectural-assumptions" id="id40">2.3.  Architectural assumptions</a><ul>
<li><a class="reference internal" href="#authorization-servers" id="id41">2.3.1.  Authorization Servers</a></li>
<li><a class="reference internal" href="#resource-server" id="id42">2.3.2.  Resource Server</a></li>
<li><a class="reference internal" href="#client" id="id43">2.3.3.  Client</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-features" id="id44">3.  Security Features</a><ul>
<li><a class="reference internal" href="#tokens" id="id45">3.1.  Tokens</a><ul>
<li><a class="reference internal" href="#oauth-threat-3-1-1" id="id46">3.1.1. Scope</a></li>
<li><a class="reference internal" href="#expires-in" id="id47">3.1.2. Expires_In</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-token" id="id48">3.2. Access Token</a></li>
<li><a class="reference internal" href="#refresh-token" id="id49">3.3. Refresh Token</a></li>
<li><a class="reference internal" href="#authorization-code" id="id50">3.4. Authorization Code</a></li>
<li><a class="reference internal" href="#redirection-uri" id="id51">3.5. Redirection URI</a></li>
<li><a class="reference internal" href="#state-parameter" id="id52">3.6. State parameter</a></li>
<li><a class="reference internal" href="#client-identity" id="id53">3.7. Client Identity</a><ul>
<li><a class="reference internal" href="#deployment-independent-client-id-with-pre-registered-redirect-uri-and-without-client-secret" id="id54">Deployment-independent <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> with pre-registered <a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a> and without <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">client_secret</em></a></a></li>
<li><a class="reference internal" href="#deployment-specific-client-id-with-pre-registered-redirect-uri-and-with-client-secret" id="id55">Deployment-specific client_id with pre-registered redirect_uri and with client_secret</a></li>
<li><a class="reference internal" href="#deployment-specific-client-id-with-client-secret-without-validated-properties" id="id56">Deployment-specific client_id with client_secret without validated properties</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-threat-model" id="id57">4.  Security Threat Model</a><ul>
<li><a class="reference internal" href="#clients" id="id58">4.1.  Clients</a><ul>
<li><a class="reference internal" href="#threat-obtain-client-secrets" id="id59">4.1.1.  Threat: Obtain Client Secrets</a><ul>
<li><a class="reference internal" href="#attack-obtain-secret-from-source-code-or-binary" id="id60"><em>Attack: Obtain Secret From Source Code or Binary.</em></a></li>
<li><a class="reference internal" href="#attack-obtain-a-deployment-specific-secret" id="id61"><em>Attack: Obtain a Deployment-Specific Secret.</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#threat-obtain-refresh-tokens" id="id62">4.1.2. Threat: Obtain Refresh Tokens</a><ul>
<li><a class="reference internal" href="#attack-obtain-refresh-token-from-web-application" id="id63"><em>Attack: Obtain Refresh Token from Web application.</em></a></li>
<li><a class="reference internal" href="#attack-obtain-refresh-token-from-native-clients" id="id64"><em>Attack: Obtain Refresh Token from Native clients.</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#threat-obtain-access-tokens" id="id65">4.1.3. Threat: Obtain Access Tokens</a></li>
<li><a class="reference internal" href="#threat-end-user-credentials-phished-using-compromised-or-embedded-browser" id="id66">4.1.4.  Threat: End-user credentials phished using compromised or embedded browser</a></li>
<li><a class="reference internal" href="#threat-open-redirectors-on-client" id="id67">4.1.5.  Threat: Open Redirectors on client</a></li>
</ul>
</li>
<li><a class="reference internal" href="#authorization-endpoint" id="id68">4.2.  Authorization Endpoint</a><ul>
<li><a class="reference internal" href="#threat-password-phishing-by-counterfeit-authorization-server" id="id69">4.2.1.  Threat: Password phishing by counterfeit authorization server</a></li>
<li><a class="reference internal" href="#threat-user-unintentionally-grants-too-much-access-scope" id="id70">4.2.2.  Threat: User unintentionally grants too much access scope</a></li>
<li><a class="reference internal" href="#threat-malicious-client-obtains-existing-authorization-by-fraud" id="id71">4.2.3.  Threat: Malicious client obtains existing authorization by fraud</a></li>
<li><a class="reference internal" href="#threat-open-redirector" id="id72">4.2.4.  Threat: Open redirector</a></li>
</ul>
</li>
<li><a class="reference internal" href="#token-endpoint" id="id73">4.3.  Token endpoint</a><ul>
<li><a class="reference internal" href="#threat-eavesdropping-access-tokens" id="id74">4.3.1.  Threat: Eavesdropping access tokens</a></li>
<li><a class="reference internal" href="#threat-obtain-access-tokens-from-authorization-server-database" id="id75">4.3.2.  Threat: Obtain access tokens from authorization server database</a></li>
<li><a class="reference internal" href="#threat-obtain-client-credentials-over-non-secure-transport" id="id76">4.3.3.  Threat: Obtain client credentials over non secure transport</a></li>
<li><a class="reference internal" href="#threat-obtain-client-secret-from-authorization-server-database" id="id77">4.3.4.  Threat: Obtain client secret from authorization server database</a></li>
<li><a class="reference internal" href="#threat-obtain-client-secret-by-online-guessing" id="id78">4.3.5.  Threat: Obtain client secret by online guessing</a></li>
<li><a class="reference internal" href="#threat-dos-on-dynamic-client-secret-creation" id="id79">4.3.6.  Threat: DoS on dynamic client secret creation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#obtaining-authorization" id="id80">4.4.  Obtaining Authorization</a><ul>
<li><a class="reference internal" href="#oauth-threat-4-4-1" id="id81">4.4.1.  Authorization Code</a><ul>
<li><a class="reference internal" href="#threat-eavesdropping-or-leaking-authorization-codes" id="id82">4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</a></li>
<li><a class="reference internal" href="#threat-obtain-authorization-codes-from-authorization-server-database" id="id83">4.4.1.2.  Threat: Obtain authorization codes from authorization server database</a></li>
<li><a class="reference internal" href="#threat-online-guessing-of-authorization-codes" id="id84">4.4.1.3.  Threat: Online guessing of authorization codes</a></li>
<li><a class="reference internal" href="#threat-malicious-client-obtains-authorization" id="id85">4.4.1.4.  Threat: Malicious client obtains authorization</a></li>
<li><a class="reference internal" href="#threat-authorization-code-phishing" id="id86">4.4.1.5.  Threat: Authorization code phishing</a></li>
<li><a class="reference internal" href="#threat-user-session-impersonation" id="id87">4.4.1.6.  Threat: User session impersonation</a></li>
<li><a class="reference internal" href="#threat-authorization-code-leakage-through-counterfeit-client" id="id88">4.4.1.7.  Threat: Authorization code leakage through counterfeit client</a></li>
<li><a class="reference internal" href="#threat-csrf-attack-against-redirect-uri" id="id89">4.4.1.8.  Threat: CSRF attack against redirect-uri</a></li>
<li><a class="reference internal" href="#threat-clickjacking-attack-against-authorization" id="id90">4.4.1.9.  Threat: Clickjacking attack against authorization</a></li>
<li><a class="reference internal" href="#threat-resource-owner-impersonation" id="id91">4.4.1.10.  Threat: Resource Owner Impersonation</a></li>
<li><a class="reference internal" href="#threat-dos-exhaustion-of-resources-attacks" id="id92">4.4.1.11.  Threat: DoS, Exhaustion of resources attacks</a></li>
<li><a class="reference internal" href="#threat-dos-using-manufactured-authorization-codes" id="id93">4.4.1.12.  Threat: DoS using manufactured authorization codes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implicit-grant" id="id94">4.4.2.  Implicit Grant</a><ul>
<li><a class="reference internal" href="#threat-access-token-leak-in-transport-end-points" id="id95">4.4.2.1.  Threat: Access token leak in transport/end-points</a></li>
<li><a class="reference internal" href="#threat-access-token-leak-in-browser-history" id="id96">4.4.2.2.  Threat: Access token leak in browser history</a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-3" id="id97">4.4.2.3.  Threat: Malicious client obtains authorization</a></li>
<li><a class="reference internal" href="#threat-manipulation-of-scripts" id="id98">4.4.2.4.  Threat: Manipulation of scripts</a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-5" id="id99">4.4.2.5.  Threat: CSRF attack against redirect-uri</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resource-owner-password-credentials" id="id100">4.4.3.  Resource Owner Password Credentials</a><ul>
<li><a class="reference internal" href="#threat-accidental-exposure-of-passwords-at-client-site" id="id101">4.4.3.1.  Threat: Accidental exposure of passwords at client site</a></li>
<li><a class="reference internal" href="#threat-client-obtains-scopes-without-end-user-authorization" id="id102">4.4.3.2.  Threat: Client obtains scopes without end-user authorization</a></li>
<li><a class="reference internal" href="#threat-client-obtains-refresh-token-through-automatic-authorization" id="id103">4.4.3.3.  Threat: Client obtains refresh token through automatic authorization</a></li>
<li><a class="reference internal" href="#threat-obtain-user-passwords-on-transport" id="id104">4.4.3.4.  Threat: Obtain user passwords on transport</a></li>
<li><a class="reference internal" href="#threat-obtain-user-passwords-from-authorization-server-database" id="id105">4.4.3.5.  Threat: Obtain user passwords from authorization server database</a></li>
<li><a class="reference internal" href="#threat-online-guessing" id="id106">4.4.3.6.  Threat: Online guessing</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#refreshing-an-access-token" id="id107">4.5.  Refreshing an Access Token</a><ul>
<li><a class="reference internal" href="#threat-eavesdropping-refresh-tokens-from-authorization-server" id="id108">4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</a></li>
<li><a class="reference internal" href="#threat-obtaining-refresh-token-from-authorization-server-database" id="id109">4.5.2.  Threat: Obtaining refresh token from authorization server database</a></li>
<li><a class="reference internal" href="#threat-obtain-refresh-token-by-online-guessing" id="id110">4.5.3.  Threat: Obtain refresh token by online guessing</a></li>
<li><a class="reference internal" href="#threat-obtain-refresh-token-phishing-by-counterfeit-authorization-server" id="id111">4.5.4.  Threat: Obtain refresh token phishing by counterfeit authorization server</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accessing-protected-resources" id="id112">4.6.  Accessing Protected Resources</a><ul>
<li><a class="reference internal" href="#threat-eavesdropping-access-tokens-on-transport" id="id113">4.6.1.  Threat: Eavesdropping access tokens on transport</a></li>
<li><a class="reference internal" href="#threat-replay-authorized-resource-server-requests" id="id114">4.6.2.  Threat: Replay authorized resource server requests</a></li>
<li><a class="reference internal" href="#threat-guessing-access-tokens" id="id115">4.6.3.  Threat: Guessing access tokens</a></li>
<li><a class="reference internal" href="#threat-access-token-phishing-by-counterfeit-resource-server" id="id116">4.6.4. Threat: Access token phishing by counterfeit resource server</a></li>
<li><a class="reference internal" href="#threat-abuse-of-token-by-legitimate-resource-server-or-client" id="id117">4.6.5.  Threat: Abuse of token by legitimate resource server or client</a></li>
<li><a class="reference internal" href="#threat-leak-of-confidential-data-in-http-proxies" id="id118">4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</a></li>
<li><a class="reference internal" href="#threat-token-leakage-via-logfiles-and-http-referrers" id="id119">4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#security-considerations" id="id120">5.  Security Considerations</a><ul>
<li><a class="reference internal" href="#general" id="id121">5.1.  General</a><ul>
<li><a class="reference internal" href="#confidentiality-of-requests" id="id122">5.1.1.  Confidentiality of Requests</a></li>
<li><a class="reference internal" href="#server-authentication" id="id123">5.1.2.  Server authentication</a></li>
<li><a class="reference internal" href="#always-keep-the-resource-owner-informed" id="id124">5.1.3.  Always keep the resource owner informed</a></li>
<li><a class="reference internal" href="#credentials" id="id125">5.1.4.  Credentials</a><ul>
<li><a class="reference internal" href="#credential-storage-protection" id="id126">5.1.4.1.  Credential Storage Protection</a><ul>
<li><a class="reference internal" href="#standard-system-security-means" id="id127">5.1.4.1.1.  Standard System Security Means</a></li>
<li><a class="reference internal" href="#standard-sql-injection-countermeasures" id="id128">5.1.4.1.2.  Standard <em class="xref std std-term">SQL Injection</em> Countermeasures</a></li>
<li><a class="reference internal" href="#no-cleartext-storage-of-credentials" id="id129">5.1.4.1.3.  No cleartext storage of credentials</a></li>
<li><a class="reference internal" href="#encryption-of-credentials" id="id130">5.1.4.1.4.  Encryption of credentials</a></li>
<li><a class="reference internal" href="#use-of-asymmetric-cryptography" id="id131">5.1.4.1.5.  Use of asymmetric cryptography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#online-attacks-on-secrets" id="id132">5.1.4.2.  Online attacks on secrets</a><ul>
<li><a class="reference internal" href="#password-policy" id="id133">5.1.4.2.1.  Password policy</a></li>
<li><a class="reference internal" href="#high-entropy-of-secrets" id="id134">5.1.4.2.2.  High entropy of secrets</a></li>
<li><a class="reference internal" href="#lock-accounts" id="id135">5.1.4.2.3.  Lock accounts</a></li>
<li><a class="reference internal" href="#tar-pit" id="id136">5.1.4.2.4.  Tar pit</a></li>
<li><a class="reference internal" href="#usage-of-captchas" id="id137">5.1.4.2.5.  Usage of CAPTCHAs</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tokens-access-refresh-code" id="id138">5.1.5.  Tokens (access, refresh, code)</a><ul>
<li><a class="reference internal" href="#limit-token-scope" id="id139">5.1.5.1.  Limit token scope</a></li>
<li><a class="reference internal" href="#expiration-time" id="id140">5.1.5.2.  Expiration time</a></li>
<li><a class="reference internal" href="#short-expiration-time" id="id141">5.1.5.3.  Short expiration time</a></li>
<li><a class="reference internal" href="#limit-number-of-usages-one-time-usage" id="id142">5.1.5.4.  Limit number of usages/ One time usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bind-tokens-to-a-particular-resource-server-audience" id="id143">5.1.5.5.  Bind tokens to a particular resource server (Audience)</a><ul>
<li><a class="reference internal" href="#use-endpoint-address-as-token-audience" id="id144">5.1.5.6.  Use endpoint address as token audience</a></li>
<li><a class="reference internal" href="#audience-and-token-scopes" id="id145">5.1.5.7.  Audience and Token scopes</a></li>
<li><a class="reference internal" href="#bind-token-to-client-id" id="id146">5.1.5.8.  Bind token to client id</a></li>
<li><a class="reference internal" href="#signed-tokens" id="id147">5.1.5.9.  Signed tokens</a></li>
<li><a class="reference internal" href="#encryption-of-token-content" id="id148">5.1.5.10.  Encryption of token content</a></li>
<li><a class="reference internal" href="#random-token-value-with-high-entropy" id="id149">5.1.5.11.  Random token value with high entropy</a></li>
<li><a class="reference internal" href="#assertion-formats" id="id150">5.1.5.12.  Assertion formats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-tokens" id="id151">5.1.6.  Access tokens</a></li>
</ul>
</li>
<li><a class="reference internal" href="#authorization-server" id="id152">5.2.  Authorization Server</a><ul>
<li><a class="reference internal" href="#authorization-codes" id="id153">5.2.1.  Authorization Codes</a><ul>
<li><a class="reference internal" href="#automatic-revocation-of-derived-tokens-if-abuse-is-detected" id="id154">5.2.1.1.  Automatic revocation of derived tokens if abuse is detected</a></li>
</ul>
</li>
<li><a class="reference internal" href="#refresh-tokens" id="id155">5.2.2.  Refresh tokens</a><ul>
<li><a class="reference internal" href="#restricted-issuance-of-refresh-tokens" id="id156">5.2.2.1.  Restricted issuance of refresh tokens</a></li>
<li><a class="reference internal" href="#binding-of-refresh-token-to-client-id" id="id157">5.2.2.2.  Binding of refresh token to client_id</a></li>
<li><a class="reference internal" href="#refresh-token-rotation" id="id158">5.2.2.3. Refresh Token Rotation</a></li>
<li><a class="reference internal" href="#refresh-token-revocation" id="id159">5.2.2.4.  Refresh Token Revocation</a></li>
<li><a class="reference internal" href="#device-identification" id="id160">5.2.2.5.  Device identification</a></li>
<li><a class="reference internal" href="#x-frame-option-header" id="id161">5.2.2.6.  X-FRAME-OPTION header</a></li>
</ul>
</li>
<li><a class="reference internal" href="#public-client-authentication-and-authorization" id="id162">5.2.3.  Public client authentication and authorization</a><ul>
<li><a class="reference internal" href="#don-t-issue-secrets-to-public-clients-or-clients-with-inappropriate-security-policy" id="id163">5.2.3.1.  Don&#8217;t issue secrets to public clients or clients with inappropriate security policy</a></li>
<li><a class="reference internal" href="#public-clients-without-secret-require-user-consent" id="id164">5.2.3.2.  Public clients without secret require user consent</a></li>
<li><a class="reference internal" href="#client-id-only-in-combination-with-redirect-uri" id="id165">5.2.3.3.  Client_id only in combination with redirect_uri</a></li>
<li><a class="reference internal" href="#deployment-specific-client-secrets" id="id166">5.2.3.4.  Deployment-specific client secrets</a></li>
<li><a class="reference internal" href="#validation-of-pre-registered-redirect-uri" id="id167">5.2.3.5.  Validation of pre-registered redirect_uri</a></li>
<li><a class="reference internal" href="#client-secret-revocation" id="id168">5.2.3.6.  Client secret revocation</a></li>
<li><a class="reference internal" href="#use-strong-client-authentication-e-g-client-assertion-client-token" id="id169">5.2.3.7.  Use strong client authentication (e.g. client_assertion / client_token)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#end-user-authorization" id="id170">5.2.4.  End-user authorization</a><ul>
<li><a class="reference internal" href="#automatic-processing-of-repeated-authorizations-requires-client-validation" id="id171">5.2.4.1.  Automatic processing of repeated authorizations requires client validation</a></li>
<li><a class="reference internal" href="#informed-decisions-based-on-transparency" id="id172">5.2.4.2.  Informed decisions based on transparency</a></li>
<li><a class="reference internal" href="#validation-of-client-properties-by-end-user" id="id173">5.2.4.3.  Validation of client properties by end-user</a></li>
<li><a class="reference internal" href="#binding-of-authorization-code-to-client-id" id="id174">5.2.4.4.  Binding of authorization code to client_id</a></li>
<li><a class="reference internal" href="#binding-of-authorization-code-to-redirect-uri" id="id175">5.2.4.5.  Binding of authorization code to redirect_uri</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#client-app-security" id="id176">5.3.  Client App Security</a><ul>
<li><a class="reference internal" href="#don-t-store-credentials-in-code-or-resources-bundled-with-software-packages" id="id177">5.3.1.  Don&#8217;t store credentials in code or resources bundled with software packages</a></li>
<li><a class="reference internal" href="#standard-web-server-protection-measures-for-config-files-and-databases" id="id178">5.3.2.  Standard web server protection measures (for config files and databases)</a></li>
<li><a class="reference internal" href="#store-secrets-in-a-secure-storage" id="id179">5.3.3.  Store secrets in a secure storage</a></li>
<li><a class="reference internal" href="#utilize-device-lock-to-prevent-unauthorized-device-access" id="id180">5.3.4.  Utilize device lock to prevent unauthorized device access</a></li>
<li><a class="reference internal" href="#platform-security-measures" id="id181">5.3.5.  Platform security measures</a></li>
<li><a class="reference internal" href="#link-state-parameter-to-user-agent-session" id="id182">5.3.6.  Link <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter to user agent session</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resource-servers" id="id183">5.4.  Resource Servers</a><ul>
<li><a class="reference internal" href="#authorization-headers" id="id184">5.4.1.  Authorization headers</a></li>
<li><a class="reference internal" href="#authenticated-requests" id="id185">5.4.2.  Authenticated requests</a></li>
<li><a class="reference internal" href="#signed-requests" id="id186">5.4.3.  Signed requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#iana-considerations" id="id187">6.  IANA Considerations</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id188">7.  Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id189">8.  References</a><ul>
<li><a class="reference internal" href="#normative-references" id="id190">8.1.  Normative References</a></li>
<li><a class="reference internal" href="#informative-references" id="id191">8.2.  Informative References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<span id="ouath-threat-abstract"></span><h2><a class="toc-backref" href="#id35">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This document gives <em class="xref std std-ref">security considerations</em>
based on a comprehensive threat model for the <a class="reference internal" href="oauth.html"><em>OAuth 2.0 Protocol</em></a>.</p>
</div>
<div class="section" id="introduction">
<span id="oauth-threat-1"></span><h2><a class="toc-backref" href="#id36">1.  Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document gives <a class="reference internal" href="#oauth-threat-5"><em>security considerations</em></a>
based on a comprehensive threat model for the <a class="reference internal" href="oauth.html"><em>OAuth 2.0 Protocol [I-D.ietf-oauth-v2]</em></a>.
It contains the following content:</p>
<blockquote>
<div><ul class="simple">
<li>Documents any <strong>assumptions</strong> and <strong>scope</strong> considered when creating the threat model.</li>
<li>Describes the <strong>security features</strong> in-built into the <a class="reference internal" href="oauth.html"><em>OAuth protocol</em></a>
and how they are intended to thwart <a class="footnote-reference" href="#id2" id="id1">[1]</a>  attacks.</li>
<li>Gives a comprehensive <a class="reference internal" href="#oauth-threat-4"><em>threat model</em></a> for OAuth
and describes the respective <strong>counter measures</strong> to thwart those threats.</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>To prevent the occurrence, realization, or attainment of: They thwarted her plans.</td></tr>
</tbody>
</table>
<p>Threats include any intentional attacks on <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">OAuth tokens</em></a> and
<a class="reference internal" href="uma_core.html#term-protected-resource"><em class="xref std std-term">resources</em></a> protected by OAuth tokens
as well as security risks introduced
if the proper security measures are not put in place.</p>
<p>Threats are structured along the lines of the protocol structure
to aid development teams implement each part of the protocol securely.
For example all threats for <strong>granting access</strong> or all threats for a particular <strong>client profile</strong>
or all threats for <strong>protecting the resource server</strong>.</p>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id37">2.  Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scope">
<span id="oauth-threat-2-1"></span><h3><a class="toc-backref" href="#id38">2.1.  Scope</a><a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h3>
<p>The security considerations document only considers <a class="reference internal" href="glossary.html#term-clients"><em class="xref std std-term">clients</em></a>
bound to a particular deployment as supported by <a class="reference internal" href="oauth.html"><em>[I-D.ietf-oauth-v2]</em></a>.
Such deployments have the following characteristics:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">Resource server</em></a> URLs are static and well-known at development time,
<a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> URLs can be static or discovered.</li>
<li><a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">Token</em></a> <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> values
(e.g. applicable URLs and methods) are well-known at development time.</li>
<li>Client registration:
Since registration of clients is out of scope of the current core spec,
this document assumes a broad variety of options
from <a class="reference internal" href="glossary.html#term-static-registration"><em class="xref std std-term">static registration</em></a>
during development time to <a class="reference internal" href="glossary.html#term-dynamic-registration"><em class="xref std std-term">dynamic registration</em></a> at runtime.</li>
</ul>
</div></blockquote>
<p>The following are considered out of scope :</p>
<blockquote>
<div><ul class="simple">
<li>Communication between <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> and <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a></li>
<li>Token formats</li>
<li>Except for &#8220;Resource Owner Password Credentials&#8221;
(see <a class="reference internal" href="oauth.html#oauth-4-3"><em>[I-D.ietf-oauth-v2], section 4.3</em></a>),
the mechanism used by <a class="reference internal" href="glossary.html#term-authorization-servers"><em class="xref std std-term">authorization servers</em></a> to authenticate the user</li>
<li>Mechanism by which a user obtained an <a class="reference internal" href="oauth_assertion.html#term-assertion"><em class="xref std std-term">assertion</em></a> and
any resulting attacks mounted as a result of the assertion being false.</li>
<li>Clients are not bound to a specific deployment:
An example could by a mail client with support for contact list access
via the portable contacts API (see <a class="reference internal" href="poco.html"><em>[portable-contacts]</em></a>).
Such clients cannot be registered upfront with a particular deployment and
must dynamically discover the URLs relevant for the OAuth protocol.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="attack-assumptions">
<span id="oauth-threat-2-2"></span><h3><a class="toc-backref" href="#id39">2.2.  Attack Assumptions</a><a class="headerlink" href="#attack-assumptions" title="Permalink to this headline">¶</a></h3>
<p>The following assumptions relate to an attacker and resources available to an attacker:</p>
<blockquote>
<div><ul class="simple">
<li>It is assumed the attacker has full access to the network
between the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and <a class="reference internal" href="glossary.html#term-authorization-servers"><em class="xref std std-term">authorization servers</em></a>
and the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and the <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>, respectively.
The attacker may eaves drop on any communications between those parties.
He is not assumed to have access to communication
between authorization and resource server.</li>
<li>It is assumed an attacker has unlimited resources to mount an attack.</li>
<li>It is assumed that
2 of the 3 parties involved in the OAuth protocol
may collude <a class="footnote-reference" href="#id4" id="id3">[2]</a>  to mount an attack against the 3rd party.
For example, the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may be
under control of an attacker
and collude to trick a user to gain access to resources.</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>To act together secretly to achieve a fraudulent, illegal, or deceitful purpose; conspire.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="architectural-assumptions">
<span id="oauth-threat-2-3"></span><h3><a class="toc-backref" href="#id40">2.3.  Architectural assumptions</a><a class="headerlink" href="#architectural-assumptions" title="Permalink to this headline">¶</a></h3>
<p>This section documents the assumptions about the features,
limitations and design options of the different entities of
a OAuth deployment along with the security-sensitive data-elements
managed by those entity.</p>
<p>These assumptions are the foundation of the treat analysis.</p>
<p>The OAuth protocol leaves deployments with a certain degree of freedom
how to implement and apply the standard.
The core specification defines the core concepts of an <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
and a <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>.</p>
<p>Both servers can be implemented in the same server entity,
or they may also be different entities.
The later is typically the case for multi-service providers
with a single authentication and authorization system,
and are more typical in middleware architectures.</p>
<p>Compoents:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-2-3-1"><em>2.3.1.  Authorization Servers</em></a></li>
<li><a class="reference internal" href="#oauth-threat-2-3-2"><em>2.3.2.  Resource Server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-2-3-3"><em>2.3.3.  Client</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="authorization-servers">
<span id="oauth-threat-2-3-1"></span><h4><a class="toc-backref" href="#id41">2.3.1.  Authorization Servers</a><a class="headerlink" href="#authorization-servers" title="Permalink to this headline">¶</a></h4>
<p>The following data elements MAY be stored or accessible
on the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>:</p>
<blockquote>
<div><ul class="simple">
<li>user names and passwords</li>
<li><a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client ids</em></a> and <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">secrets</em></a></li>
<li>client-specific <a class="reference internal" href="glossary.html#term-refresh-tokens"><em class="xref std std-term">refresh tokens</em></a></li>
<li>client-specific <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> (in case of handle-based design)</li>
<li>HTTPS certificate/key</li>
<li>per authorization process (in case of handle-based design):
<a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a>, <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a>, <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="resource-server">
<span id="oauth-threat-2-3-2"></span><h4><a class="toc-backref" href="#id42">2.3.2.  Resource Server</a><a class="headerlink" href="#resource-server" title="Permalink to this headline">¶</a></h4>
<p>The following data elements MAY be stored or accessible on the <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>:</p>
<blockquote>
<div><ul class="simple">
<li>user data (out of scope)</li>
<li>HTTPS certificate/key</li>
<li>authz server credentials (handle-based design), or</li>
<li>authz server shared secret/public key (assertion-based design)</li>
<li><a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> (per request)</li>
</ul>
</div></blockquote>
<p>It is assumed that a <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> has no knowledge of <a class="reference internal" href="glossary.html#term-refresh-tokens"><em class="xref std std-term">refresh tokens</em></a>,
user passwords, or <a class="reference internal" href="glossary.html#term-client-secrets"><em class="xref std std-term">client secrets</em></a>.</p>
</div>
<div class="section" id="client">
<span id="oauth-threat-2-3-3"></span><h4><a class="toc-backref" href="#id43">2.3.3.  Client</a><a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h4>
<p>A full definition of different client types and profiles is given in
[I-D.ietf-oauth-v2], <a class="reference internal" href="oauth.html#oauth-2-1"><em>Section 2.1</em></a>.</p>
<p>The following data elements are stored or accessible on the client:</p>
<blockquote>
<div><p>o  client id (and client secret or corresponding client credential)</p>
<dl class="docutils">
<dt>o  one or more refresh tokens (persistent) and access tokens</dt>
<dd>(transient) per end-user or other security-context or delegation
context</dd>
</dl>
<p>o  trusted CA certificates (HTTPS)</p>
<p>o  per authorization process: redirect_uri, authorization code</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="security-features">
<span id="oauth-threat-3"></span><h2><a class="toc-backref" href="#id44">3.  Security Features</a><a class="headerlink" href="#security-features" title="Permalink to this headline">¶</a></h2>
<p>These are some of the security features which have been built into
the OAuth 2.0 protocol to mitigate attacks and security issues.</p>
<p>Features:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-3-1"><em>3.1.  Tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-2"><em>3.2. Access Token</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-3"><em>3.3. Refresh Token</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-4"><em>3.4. Authorization Code</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-5"><em>3.5. Redirection URI</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-6"><em>3.6. State parameter</em></a></li>
<li><a class="reference internal" href="#oauth-threat-3-7"><em>3.7. Client Identity</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="tokens">
<span id="oauth-threat-3-1"></span><h3><a class="toc-backref" href="#id45">3.1.  Tokens</a><a class="headerlink" href="#tokens" title="Permalink to this headline">¶</a></h3>
<p>OAuth makes extensive use of all kinds of tokens
(<a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a>, <a class="reference internal" href="glossary.html#term-refresh-tokens"><em class="xref std std-term">refresh tokens</em></a>, <em class="xref std std-term">authorization codes</em>).
The information content of a token can be represented in two ways as follows:</p>
<dl class="glossary docutils">
<dt id="term-handle">Handle</dt>
<dd>(or <a class="reference internal" href="glossary.html#term-artifact"><em class="xref std std-term">artifact</em></a>)
a reference to some internal data structure within the authorization server,
the internal data structure contains the attributes of the token,
such as user id, scope, etc.
Handles enable simple revocation and do not require cryptographic
mechanisms to protected token content from being modified.
On the other hand, handles require communication between issuing and
consuming entity (e.g. authorization and resource server) in order
to validate the token and obtain token-bound data.
This communication might have an negative impact on performance and
scalability if both entities reside on different system.
Handles are therefore typically used if the issuing and consuming entity
are the same.
A &#8216;handle&#8217; token is often referred to as an &#8216;opaque&#8217; token
because the resource server does not need to be able to interpret
the token directly, it simply uses the token.</dd>
<dt id="term-assertions">Assertions</dt>
<dd>(aka self-contained token)
a parseable <a class="footnote-reference" href="#id6" id="id5">[3]</a> token.
An assertion typically has a <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a>, an <a class="reference internal" href="oauth_assertion.html#term-audience"><em class="xref std std-term">audience</em></a>,
and is digitally signed containing information about the user and the client.
Examples of assertion formats are SAML assertions and Kerberos tickets.
Assertions can typically directly be validated and used
by a resource server without interactions with the authorization server.
This results in better performance and scalability in deployment
where issuing and consuming entity reside on different systems.
Implementing token revocation is more difficult with assertions than with handles.</dd>
</dl>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>To break (a sentence) down into its component parts of speech with an explanation of the form, function, and syntactical relationship of each part.</td></tr>
</tbody>
</table>
<p>Tokens can be used in two ways to invoke requests on resource servers as follows:</p>
<dl class="glossary docutils">
<dt id="term-bearer-token">bearer token</dt>
<dd>A &#8216;bearer token&#8217; is a token that can be used by any client who has received the token
(e.g.  [I-D.ietf-oauth-v2-bearer]).
Because mere possession is enough to use the token it is important
that communication between endpoints be secured to ensure
that only authorized end-points may capture the token.
The bearer token is convenient to client applications
as it does not require them to do anything to use them (such as a proof of identity).
Bearer tokens have similar characteristics to web single-sign-on (SSO) cookies used in browsers.</dd>
<dt id="term-proof-token">proof token</dt>
<dd>A &#8216;proof token&#8217; is a token that can only be used by a specific client.
Each use of the token, requires the client to perform some action that proves
that it is the authorized user of the token.
Examples of this are MAC tokens,
which require the client to digitally sign the resource request with a secret
corresponding to the particular token send with the request
(e.g.[I-D.ietf-oauth-v2-http-mac]).</dd>
</dl>
<div class="section" id="oauth-threat-3-1-1">
<span id="id7"></span><h4><a class="toc-backref" href="#id46">3.1.1. Scope</a><a class="headerlink" href="#oauth-threat-3-1-1" title="Permalink to this headline">¶</a></h4>
<p>A <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">Scope</em></a> represents the access authorization associated with a particular token
with respect to resource servers, resources and methods on those resources.
Scopes are the OAuth way to explicitly manage the power associated with an access token.
A scope can be controlled by the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> and/or the <a class="reference internal" href="messages.html#term-end-user"><em class="xref std std-term">end-user</em></a>
in order to limit access to resources for OAuth clients these parties deem <a class="footnote-reference" href="#id9" id="id8">[4]</a> less secure or trustworthy.</p>
<p>Optionally,
the client can request the scope to apply to the token
but only for lesser scope than would otherwise be granted,
e.g. to reduce the potential impact if this token is sent over non secure channels.
A scope is typically complemented by a restriction on a token&#8217;s lifetime.</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td>To regard as; consider:</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="oauth.html#oauth-3-3"><em>3.3. Access Token Scope</em></a></p>
</div>
</div>
<div class="section" id="expires-in">
<span id="oauth-threat-3-1-2"></span><h4><a class="toc-backref" href="#id47">3.1.2. Expires_In</a><a class="headerlink" href="#expires-in" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="standard.html#term-expires-in"><em class="xref std std-term">Expires_In</em></a> allows an <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
(based on its policies or on behalf of the end-user)
to limit the <strong>lifetime</strong> of the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.</p>
<p>This mechanisms can be used to issue <strong>short-living</strong> tokens to
OAuth clients the authorization server
deems less secure or where sending tokens over non secure channels.</p>
</div>
</div>
<div class="section" id="access-token">
<span id="oauth-threat-3-2"></span><h3><a class="toc-backref" href="#id48">3.2. Access Token</a><a class="headerlink" href="#access-token" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> is used by a client to access a resource.
Access tokens typically have short life-spans (minutes or hours)
that cover typical session lifetimes.</p>
<p>An access token may be refreshed through the use of a <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a>.
The short lifespan of an access token in combination with the usage of refresh tokens
enables the possibility of <strong>passive revocation</strong> of access authorization
on the expiry of the current access token.</p>
</div>
<div class="section" id="refresh-token">
<span id="oauth-threat-3-3"></span><h3><a class="toc-backref" href="#id49">3.3. Refresh Token</a><a class="headerlink" href="#refresh-token" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> represents a long-lasting authorization
of a certain client to access resources on behalf of a <a class="reference internal" href="oauth.html#term-resource-owner"><em class="xref std std-term">resource owner</em></a>.
Such tokens are exchanged between <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>, only.
Clients use this kind of token to obtain (&#8220;refresh&#8221;) new <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a>
used for <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> invocations.</p>
<p>A refresh token, coupled with a short access token lifetime,
can be used to grant longer access to resources without involving end user authorization.
This offers an advantage where resource servers and
authorization servers are not the same entity,
e.g. in a distributed environment,
as the refresh token must always be exchanged at the authorization server.
The authorization server can revoke the refresh token at any time
causing the granted access to be revoked once the current access token expires.
Because of this, a short access token lifetime is important
if timely revocation is a high priority.</p>
<p>The refresh token is also a secret bound to the client identifier and _instance_
which originally requested the authorization and representing the original resource owner grant.
This is ensured by the authorization process as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The resource owner and user-agent safely deliver the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
to the client instance in first place.</li>
<li>The client uses it immediately in secure transport-level communications
to the authorization server and then securely stores the long-lived refresh token.</li>
<li>The client always uses the refresh token in secure transport-level communications
to the authorization server to get an access token (and optionally rollover the refresh token).</li>
</ol>
</div></blockquote>
<p>So as long as the confidentiality of the particular token can be ensured by the client,
a refresh tokens can also be used as an alternative mean to authenticate the client instance itself.</p>
</div>
<div class="section" id="authorization-code">
<span id="oauth-threat-3-4"></span><h3><a class="toc-backref" href="#id50">3.4. Authorization Code</a><a class="headerlink" href="#authorization-code" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">Authorization Code</em></a> represents
the intermediary result of a successful <a class="reference internal" href="messages.html#term-end-user"><em class="xref std std-term">end-user</em></a> authorization process
and is used by the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> to obtain access and refresh token.
Authorization codes are sent to the client&#8217;s redirection URI instead of tokens for two purposes.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Instead of (longer-lasting) tokens,
the short-living authorization code is exposed to potential attackers
via URI query parameters (HTTP referrer), browser cacher or log file entries.</li>
<li>It is much simpler to authenticate clients during the direct request
between client and <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
than in the context of the indirect authorization request.
The later would require digital signatures.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="redirection-uri">
<span id="oauth-threat-3-5"></span><h3><a class="toc-backref" href="#id51">3.5. Redirection URI</a><a class="headerlink" href="#redirection-uri" title="Permalink to this headline">¶</a></h3>
<p>A redirection URI helps to detect malicious client
and prevents phishing attacks from clients attempting
to trick the user into believing the phisher is the client.</p>
<p>The value of the actual redirection URI used in the authorization request
has to be presented and is verified when an authorization code is exchanged for tokens.
This helps to prevent attacks, where the authorization code is revealed
through redirectors and counterfeit web application clients.</p>
<p>The authorization server requires public clients and confidential clients
using implicit grant type to pre-register their redirect URIs and
validate agains the registered redirection URI in the authorization request.</p>
</div>
<div class="section" id="state-parameter">
<span id="oauth-threat-3-6"></span><h3><a class="toc-backref" href="#id52">3.6. State parameter</a><a class="headerlink" href="#state-parameter" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter is used to link requests and callbacks to prevent <a class="reference internal" href="glossary.html#term-csrf"><em class="xref std std-term">CSRF</em></a> attacks
where an attacker authorizes access to his own resources
and then tricks a users into following a redirect with the attacker&#8217;s token.
It should bind to the authenticated state in a user agent and
the user agent must be capable of keeping it in a location accessible
only by the client and user agent, i.e. protected by same-origin policy</p>
</div>
<div class="section" id="client-identity">
<span id="oauth-threat-3-7"></span><h3><a class="toc-backref" href="#id53">3.7. Client Identity</a><a class="headerlink" href="#client-identity" title="Permalink to this headline">¶</a></h3>
<p>Authentication protocols have typically not taken into account
the identity of the software component
acting on behalf of the end-user.</p>
<p>OAuth does this in order to increase the security level
in delegated authorization scenarios and
because the client will be able to act without the user being present.</p>
<p>OAuth uses the <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">_client_id_</em></a> (client identity)
to collate associated request to the same originator, such as</p>
<blockquote>
<div><ul class="simple">
<li>particular end-user authorization process and the corresponding request
on the tokens endpoint to exchange the authorization code for tokens or</li>
<li>the initial authorization and issuance of a tokens by an end-user to a particular client
and sub-sequent requests by this client to obtain tokens w/o user consent
(automatic processing of repeated authorization)</li>
</ul>
</div></blockquote>
<p>The client identity may also be used by the authorization server
to display relevant registration information to a user
when requesting consent for scope requested by a particular client.
The client identity may be used to limit the number of request for a particular client
or to charge the client per request.
Client Identity may furthermore be useful to differentiate access by different clients,
e.g. in server log files.</p>
<p>OAuth defines two client types, <strong>confidential</strong> and <strong>public</strong>,
based on their ability to authenticate securely with the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
(i.e. ability to maintain the confidentiality of their client credentials).
Confidential clients are capable of maintaining the confidentiality of client credentials
(i.e. a client secret associated with the client identifier)
or capable of secure client authentication using other means,
such as a client assertion (e.g.  SAML) or key cryptography.
The latter is considered more secure.</p>
<p>The authorization server should determine
whether the client is capable of keeping its secret confidential
or using secure authentication.
Alternatively, the <a class="reference internal" href="messages.html#term-end-user"><em class="xref std std-term">end-user</em></a> can verify the identity of the client,
e.g. by only installing trusted applications.
The <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> can be used to prevent delivering credentials
to a counterfeit client after obtaining end-user authorization,
but can&#8217;t be used to verify the client identity.</p>
<p>Clients can be categorized as follows based on the client type, profile
(e.g. native vs web application) and deployment model:</p>
<div class="section" id="deployment-independent-client-id-with-pre-registered-redirect-uri-and-without-client-secret">
<h4><a class="toc-backref" href="#id54">Deployment-independent <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> with pre-registered <a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a> and without <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">client_secret</em></a></a><a class="headerlink" href="#deployment-independent-client-id-with-pre-registered-redirect-uri-and-without-client-secret" title="Permalink to this headline">¶</a></h4>
<p>Such an identity is used by multiple installations of the same software package.
The identity of such a client can only be validated with the help of the end-user.
This is a viable option for native applications in order to identify the client
for the purpose of displaying meta information
about the client to the user and to differentiate clients in log files.
Revocation of such an identity will affect ALL deployments
Deployment-independent client_id with pre-registered redirect_uri and with client_secret
This is an option for native applications only,
since web application would require different redirect URIs.
This category is not advisable
because the client secret cannot be protected appropriately (see <a class="reference internal" href="#oauth-threat-4-1-1"><em>Section 4.1.1</em></a>).
Due to its security weaknesses,
such client identities have the same trust level as deployment-independent clients without secret.
Revocation will affect ALL deployments.</p>
</div>
<div class="section" id="deployment-specific-client-id-with-pre-registered-redirect-uri-and-with-client-secret">
<h4><a class="toc-backref" href="#id55">Deployment-specific client_id with pre-registered redirect_uri and with client_secret</a><a class="headerlink" href="#deployment-specific-client-id-with-pre-registered-redirect-uri-and-with-client-secret" title="Permalink to this headline">¶</a></h4>
<p>The client registration process insures the validation of the client&#8217;s properties,
such as redirection URI, website address, web site name, contacts.
Such a client identity can be utilized for all relevant use cases cited above.
This level can be achieved for web applications in combination with a manual or user-bound registration process.
Achieving this level for native applications is much more difficult.
Either the installation of the application is conducted by an administrator,
who validates the clients authenticity,
or the process from validating the application to the installation of the application
on the device and the creation of the client credentials is controlled end-to-end by a single entity
(e.g. application market provider).
Revocation will affect a single deployment only.</p>
</div>
<div class="section" id="deployment-specific-client-id-with-client-secret-without-validated-properties">
<h4><a class="toc-backref" href="#id56">Deployment-specific client_id with client_secret without validated properties</a><a class="headerlink" href="#deployment-specific-client-id-with-client-secret-without-validated-properties" title="Permalink to this headline">¶</a></h4>
<p>Such a client can be recognized by the authorization server in transactions with subsequent requests
(e.g.  authorization and token issuance, refresh token issuance and access token refreshment).
The authorization server cannot assure any property of the client to end-users.
Automatic processing of re-authorizations could be allowed as well.
Such client credentials can be generated automatically without any validation of client properties,
which makes it another option especially for native applications.
Revocation will affect a single deployment only.</p>
</div>
</div>
</div>
<div class="section" id="security-threat-model">
<span id="oauth-threat-4"></span><h2><a class="toc-backref" href="#id57">4.  Security Threat Model</a><a class="headerlink" href="#security-threat-model" title="Permalink to this headline">¶</a></h2>
<p>This sections gives a comprehensive threat model of <a class="reference internal" href="oauth.html"><em>OAuth 2.0</em></a>.</p>
<p>Threats are grouped first by attacks directed against an OAuth component,
which are <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>, <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>, and <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>.</p>
<p>Subsequently, they are grouped by flow, e.g. obtain token or access protected resources.
Every countermeasure description refers to a detailed description in <a class="reference internal" href="#oauth-threat-5"><em>Section 5</em></a>.</p>
<img alt="images/4.png" src="images/4.png" style="width: 600px;" />
<div class="section" id="clients">
<span id="oauth-threat-4-1"></span><h3><a class="toc-backref" href="#id58">4.1.  Clients</a><a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h3>
<p>This section describes possible threats directed to <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">OAuth clients</em></a>.</p>
<img alt="images/4.1.png" src="images/4.1.png" style="width: 600px;" />
<p>Threats:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-1-1"><em>4.1.1.  Threat: Obtain Client Secrets</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-1-2"><em>4.1.2. Threat: Obtain Refresh Tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-1-3"><em>4.1.3. Threat: Obtain Access Tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-1-4"><em>4.1.4.  Threat: End-user credentials phished using compromised or embedded browser</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-1-5"><em>4.1.5.  Threat: Open Redirectors on client</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-obtain-client-secrets">
<span id="oauth-threat-4-1-1"></span><h4><a class="toc-backref" href="#id59">4.1.1.  Threat: Obtain Client Secrets</a><a class="headerlink" href="#threat-obtain-client-secrets" title="Permalink to this headline">¶</a></h4>
<p>The attacker could try to get access to the secret of a particular <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> in order to:</p>
<blockquote>
<div><ul class="simple">
<li>replay its <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh tokens</em></a>  and <em class="xref std std-term">authorization codes</em>, or</li>
<li>obtain tokens on behalf of the attacked client with the privileges of that client.</li>
</ul>
</div></blockquote>
<p>The resulting impact would be:</p>
<blockquote>
<div><ul class="simple">
<li>Client authentication of access to <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> can be bypassed</li>
<li>Stolen refresh tokens or authorization codes can be replayed</li>
</ul>
</div></blockquote>
<p>Depending on the client category,
the following attacks could be utilized to obtain the client secret.</p>
<div class="section" id="attack-obtain-secret-from-source-code-or-binary">
<h5><a class="toc-backref" href="#id60"><em>Attack: Obtain Secret From Source Code or Binary.</em></a><a class="headerlink" href="#attack-obtain-secret-from-source-code-or-binary" title="Permalink to this headline">¶</a></h5>
<p>This applies for all client profiles.
For open source projects, secrets can be extracted directly from source code in their public repositories.
Secrets can be extracted from application binaries just as easily when published source is not available to the attacker.
Even if an application takes significant measures to obfuscate secrets in their application distribution one should consider
that the secret can still be reverse-engineered by anyone with access to a complete functioning application bundle or binary.</p>
<p>_Countermeasures:_</p>
<blockquote>
<div><ul class="simple">
<li>Don&#8217;t issue secrets to public clients or clients with inappropriate security policy - <a class="reference internal" href="#oauth-threat-5-2-3-1"><em>Section 5.2.3.1</em></a></li>
<li>Public clients require user consent - <a class="reference internal" href="#oauth-threat-5-2-3-2"><em>Section 5.2.3.2</em></a></li>
<li>Use deployment-specific client secrets - <a class="reference internal" href="#oauth-threat-5-2-3-4"><em>Section 5.2.3.4</em></a></li>
<li>Client secret revocation - <a class="reference internal" href="#oauth-threat-5-2-3-6"><em>Section 5.2.3.6</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="attack-obtain-a-deployment-specific-secret">
<h5><a class="toc-backref" href="#id61"><em>Attack: Obtain a Deployment-Specific Secret.</em></a><a class="headerlink" href="#attack-obtain-a-deployment-specific-secret" title="Permalink to this headline">¶</a></h5>
<p>An attacker may try to obtain the secret from a client installation,
either from a web site (web server) or a particular devices (native application).</p>
<p>_Countermeasures:_</p>
<blockquote>
<div><ul class="simple">
<li>Web server: apply standard web server protection measures
(for config files and databases) - <a class="reference internal" href="#oauth-threat-5-3-2"><em>Section 5.3.2</em></a></li>
<li>Native applications: Store secrets in a secure local storage - <a class="reference internal" href="#oauth-threat-5-3-3"><em>Section 5.3.3</em></a></li>
<li>Client secret revocation - <a class="reference internal" href="#oauth-threat-5-2-3-6"><em>Section 5.2.3.6</em></a></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="threat-obtain-refresh-tokens">
<span id="oauth-threat-4-1-2"></span><h4><a class="toc-backref" href="#id62">4.1.2. Threat: Obtain Refresh Tokens</a><a class="headerlink" href="#threat-obtain-refresh-tokens" title="Permalink to this headline">¶</a></h4>
<p>Depending on the <em class="xref std std-term">client type</em>,
there are different ways <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh tokens</em></a> may be revealed to an attacker.
The following sub-sections give a more detailed description of the different attacks
with respect to different client types and further specialized countermeasures.
Some generally applicable countermeasure to mitigate such attacks shall be given in advance:</p>
<blockquote>
<div><ul>
<li><p class="first">The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> must validate the <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client id</em></a>
associated with the particular refresh token with every refresh request
- <a class="reference internal" href="#oauth-threat-5-2-2-2"><em>Section 5.2.2.2</em></a></p>
</li>
<li><p class="first">Limited <em class="xref std std-ref">scope</em> tokens - <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a></p>
<p>Refresh token revocation - <a class="reference internal" href="#oauth-threat-5-2-2-4"><em>Section 5.2.2.4</em></a></p>
</li>
<li><p class="first">Client secret revocation - <a class="reference internal" href="#oauth-threat-5-2-3-6"><em>Section 5.2.3.6</em></a></p>
</li>
<li><p class="first">Refresh tokens can automatically be replaced in order to detect
unauthorized token usage by another party (Refresh Token Rotation)
- <a class="reference internal" href="#oauth-threat-5-2-2-3"><em>Section 5.2.2.3</em></a></p>
</li>
</ul>
</div></blockquote>
<div class="section" id="attack-obtain-refresh-token-from-web-application">
<h5><a class="toc-backref" href="#id63"><em>Attack: Obtain Refresh Token from Web application.</em></a><a class="headerlink" href="#attack-obtain-refresh-token-from-web-application" title="Permalink to this headline">¶</a></h5>
<p>An attack may obtain the refresh tokens issued to a web server client.
Impact: Exposure of all refresh tokens on that side.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Standard web server protection measures - <a class="reference internal" href="#oauth-threat-5-3-2"><em>Section 5.3.2</em></a></li>
<li>Use strong client authentication
(e.g. client_assertion / client_token),
so the attacker cannot obtain the client secret
required to exchange the tokens - <a class="reference internal" href="#oauth-threat-5-2-3-7"><em>Section 5.2.3.7</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="attack-obtain-refresh-token-from-native-clients">
<h5><a class="toc-backref" href="#id64"><em>Attack: Obtain Refresh Token from Native clients.</em></a><a class="headerlink" href="#attack-obtain-refresh-token-from-native-clients" title="Permalink to this headline">¶</a></h5>
<p>On native clients, leakage of a refresh token typically affects a single user, only.</p>
<p>Read from local filesystem:</p>
<blockquote>
<div>The attacker could try get file system access on the device and read the refresh tokens.
The attacker could utilize a malicious application for that purpose.</div></blockquote>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Store secrets in a secure storage - <a class="reference internal" href="#oauth-threat-5-3-3"><em>Section 5.3.3</em></a></li>
<li>Utilize device lock to prevent unauthorized device access - <a class="reference internal" href="#oauth-threat-5-3-4"><em>Section 5.3.4</em></a></li>
</ul>
</div></blockquote>
<p>Steal device:</p>
<blockquote>
<div>The host device (e.g. mobile phone) may be stolen.
In that case,
the attacker gets access to all applications under the identity of the legitimate user.</div></blockquote>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Utilize device lock to prevent unauthorized device access - <a class="reference internal" href="#oauth-threat-5-3-4"><em>Section 5.3.4</em></a></li>
<li>Where a user knows the device has been stolen,
they can revoke the affected tokens - <a class="reference internal" href="#oauth-threat-5-2-2-4"><em>Section 5.2.2.4</em></a></li>
</ul>
</div></blockquote>
<p>Clone device:</p>
<blockquote>
<div>All device data and applications are copied to another device.
Applications are used as-is on the target device.</div></blockquote>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Combine refresh token request with device identification - <a class="reference internal" href="#oauth-threat-5-2-2-5"><em>Section 5.2.2.5</em></a></li>
<li>Refresh Token Rotation - <a class="reference internal" href="#oauth-threat-5-2-2-3"><em>Section 5.2.2.3</em></a></li>
<li>Where a user knows the device has been cloned,
they can use this countermeasure - Refresh Token Revocation - <a class="reference internal" href="#oauth-threat-5-2-2-3"><em>Section 5.2.2.4</em></a></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="threat-obtain-access-tokens">
<span id="oauth-threat-4-1-3"></span><h4><a class="toc-backref" href="#id65">4.1.3. Threat: Obtain Access Tokens</a><a class="headerlink" href="#threat-obtain-access-tokens" title="Permalink to this headline">¶</a></h4>
<p>Depending on the client type,
there are different ways <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> may be revealed to an attacker.
Access tokens could be stolen from the device if the application stores them in a storage,
which is accessible to other applications.</p>
<p>Impact:
Where the token is a <a class="reference internal" href="#term-bearer-token"><em class="xref std std-term">bearer token</em></a> and no additional mechanism is used to identify the client,
the attacker can access all resources associated with the token and its scope.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Keep access tokens in transient memory and limit grants: <a class="reference internal" href="#oauth-threat-5-1-6"><em>Section 5.1.6</em></a></li>
<li>Limited scope tokens - <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a></li>
<li>Keep access tokens in private memory or apply same protection means as for refresh tokens - <a class="reference internal" href="#oauth-threat-5-2-2"><em>Section 5.2.2</em></a></li>
<li>Keep access token lifetime short - <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-end-user-credentials-phished-using-compromised-or-embedded-browser">
<span id="oauth-threat-4-1-4"></span><h4><a class="toc-backref" href="#id66">4.1.4.  Threat: End-user credentials phished using compromised or embedded browser</a><a class="headerlink" href="#threat-end-user-credentials-phished-using-compromised-or-embedded-browser" title="Permalink to this headline">¶</a></h4>
<p>A malicious application could attempt to phish end-user passwords
by misusing an embedded browser in the end-user authorization process,
or by presenting its own user-interface instead of allowing trusted system browser
to render the authorization user interface.</p>
<p>By doing so, the usual visual trust mechanisms may be bypassed
(e.g.  TLS confirmation, web site mechanisms).
By using an embedded or internal client application user interface,
the client application has access to additional information it should not have access to
(e.g. uid/ password).</p>
<p>Impact:
If the client application or the communication is compromised,
the user would not be aware and all information in the authorization exchange could be captured
such as username and password.</p>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o    Client developers and end-user can be educated</dt>
<dd>to trust an external System-Browser only.</dd>
<dt>o    Client applications could be validated prior publication</dt>
<dd>in a application market.</dd>
<dt>o    Client developers should not collect authentication information directly</dt>
<dd>from users and should instead use redirects to and back from a trusted external system-browser.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-open-redirectors-on-client">
<span id="oauth-threat-4-1-5"></span><h4><a class="toc-backref" href="#id67">4.1.5.  Threat: Open Redirectors on client</a><a class="headerlink" href="#threat-open-redirectors-on-client" title="Permalink to this headline">¶</a></h4>
<p>An open redirector is an endpoint
using a parameter to automatically redirect a user-agent
to the location specified by the parameter value without any validation.</p>
<p>If the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> allows the client
to register only part of the redirection URI,
an attacker can use an open redirector operated by
the client to construct a redirection URI that will pass the authorization server validation
but will send the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
or <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> to an endpoint under the control of the attacker.</p>
<p>Impact: An attacker could gain access to authorization codes or access tokens</p>
<p>Countermeasure</p>
<blockquote>
<div>o  require clients to register full redirection URI <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a></div></blockquote>
</div>
</div>
<div class="section" id="authorization-endpoint">
<span id="oauth-threat-4-2"></span><h3><a class="toc-backref" href="#id68">4.2.  Authorization Endpoint</a><a class="headerlink" href="#authorization-endpoint" title="Permalink to this headline">¶</a></h3>
<img alt="images/4.2.png" src="images/4.2.png" style="width: 600px;" />
<p>Threats:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-2-1"><em>4.2.1.  Threat: Password phishing by counterfeit authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-2-2"><em>4.2.2.  Threat: User unintentionally grants too much access scope</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-2-3"><em>4.2.3.  Threat: Malicious client obtains existing authorization by fraud</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-2-4"><em>4.2.4.  Threat: Open redirector</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-password-phishing-by-counterfeit-authorization-server">
<span id="oauth-threat-4-2-1"></span><h4><a class="toc-backref" href="#id69">4.2.1.  Threat: Password phishing by counterfeit authorization server</a><a class="headerlink" href="#threat-password-phishing-by-counterfeit-authorization-server" title="Permalink to this headline">¶</a></h4>
<p>OAuth makes no attempt to verify the authenticity of the Authorization Server.
A hostile party could take advantage of this
by intercepting the Client&#8217;s requests and returning misleading or otherwise incorrect responses.
This could be achieved using DNS or ARP spoofing.
Wide deployment of OAuth and similar protocols may cause Users
to become inured <a class="footnote-reference" href="#id11" id="id10">[5]</a> to the practice of being redirected to websites
where they are asked to enter their passwords.</p>
<p>If Users are not careful to verify the authenticity of these websites
before entering their credentials,
it will be possible for attackers to exploit this practice to steal Users&#8217; passwords.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[5]</a></td><td>To habituate to something undesirable, especially by prolonged subjection; accustom: &#8220;Though the food became no more palatable, he soon became sufficiently inured to it&#8221; (John Barth).</td></tr>
</tbody>
</table>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o  Authorization servers should consider such attacks</dt>
<dd>when developing services based on OAuth,
and should require <a class="reference internal" href="glossary.html#term-tls"><em class="xref std std-term">transport-layer security</em></a> for any requests
where the authenticity of the authorization server or of request responses is an issue
(see <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a> ).</dd>
<dt>o  Authorization servers should attempt to educate Users</dt>
<dd>about the risks phishing attacks pose,
and should provide mechanisms that make it easy for users
to confirm the authenticity of their sites.</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">UX ?</p>
</div>
</div>
<div class="section" id="threat-user-unintentionally-grants-too-much-access-scope">
<span id="oauth-threat-4-2-2"></span><h4><a class="toc-backref" href="#id70">4.2.2.  Threat: User unintentionally grants too much access scope</a><a class="headerlink" href="#threat-user-unintentionally-grants-too-much-access-scope" title="Permalink to this headline">¶</a></h4>
<p>When obtaining end user authorization,
the <a class="reference internal" href="messages.html#term-end-user"><em class="xref std std-term">end-user</em></a> may not understand the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of the access being granted
and to whom or they may end up providing a <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> with access to resources
which should not be permitted.</p>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o  Explain the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> (resources and the permissions) the user is about to grant</dt>
<dd>in a understandable way - <a class="reference internal" href="#oauth-threat-5-2-4-2"><em>Section 5.2.4.2</em></a></dd>
<dt>o  Narrow <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> based on <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> -</dt>
<dd>When obtaining end user authorization and
where the client requests scope,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may want to consider
whether to honour that scope based on who the client is.
That decision is between the client and authorization server
and is outside the scope of this spec.
The authorization server may also want to consider
what scope to grant based on the <em class="xref std std-term">client type</em>,
e.g. providing lower scope to public clients. - <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-malicious-client-obtains-existing-authorization-by-fraud">
<span id="oauth-threat-4-2-3"></span><h4><a class="toc-backref" href="#id71">4.2.3.  Threat: Malicious client obtains existing authorization by fraud</a><a class="headerlink" href="#threat-malicious-client-obtains-existing-authorization-by-fraud" title="Permalink to this headline">¶</a></h4>
<p>Authorization servers may wish to automatically process authorization requests
from clients which have been previously authorized by the user.
When the user is redirected
to the authorization server&#8217;s end-user <a class="reference internal" href="oauth_responses.html#term-authorization-endpoint"><em class="xref std std-term">authorization endpoint</em></a> to grant access,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> detects that the user has already granted access to that particular client.
Instead of prompting the user for approval,
the authorization server automatically redirects the user back to the client.</p>
<p>A malicious client may exploit that feature and
try to obtain such an <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> instead of the legitimate client.</p>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o  Authorization servers should not automatically process repeat authorizations</dt>
<dd>to public clients or
unless the client is validated using a pre-registered redirect URI (<a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a> )</dd>
<dt>o  Authorization servers can mitigate the risks associated with automatic processing</dt>
<dd>by limiting the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of Access Tokens
obtained through automated approvals - <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-open-redirector">
<span id="oauth-threat-4-2-4"></span><h4><a class="toc-backref" href="#id72">4.2.4.  Threat: Open redirector</a><a class="headerlink" href="#threat-open-redirector" title="Permalink to this headline">¶</a></h4>
<p>An attacker could use the <a class="reference internal" href="glossary.html#term-end-user-authorization-endpoint"><em class="xref std std-term">end-user authorization endpoint</em></a> and
the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> parameter to abuse the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
as an <em class="xref std std-term">open redirector</em>.</p>
<p>An open redirector is an endpoint using a parameter to automatically redirect a user-agent
to the location specified by the parameter value without any validation.</p>
<p>Impact:
An attacker could utilize a user&#8217;s trust in your authorization server to launch a <em class="xref std std-term">phishing attack</em>.</p>
<p>Countermeasure</p>
<blockquote>
<div><p>o  require clients to register full redirection URI <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a></p>
<dl class="docutils">
<dt>o  don&#8217;t redirect to redirection URI,</dt>
<dd>if client identity or redirection URI could not be verified <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a></dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="token-endpoint">
<span id="oauth-threat-4-3"></span><h3><a class="toc-backref" href="#id73">4.3.  Token endpoint</a><a class="headerlink" href="#token-endpoint" title="Permalink to this headline">¶</a></h3>
<img alt="images/4.3.png" src="images/4.3.png" style="width: 600px;" />
<p>Threats:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-3-1"><em>4.3.1.  Threat: Eavesdropping access tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-2"><em>4.3.2.  Threat: Obtain access tokens from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-3"><em>4.3.3.  Threat: Obtain client credentials over non secure transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-4"><em>4.3.4.  Threat: Obtain client secret from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-5"><em>4.3.5.  Threat: Obtain client secret by online guessing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-6"><em>4.3.6.  Threat: DoS on dynamic client secret creation</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-eavesdropping-access-tokens">
<span id="oauth-threat-4-3-1"></span><h4><a class="toc-backref" href="#id74">4.3.1.  Threat: Eavesdropping access tokens</a><a class="headerlink" href="#threat-eavesdropping-access-tokens" title="Permalink to this headline">¶</a></h4>
<p>Attackers may attempts to eavesdrop <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>
on transit from the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> to the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>.</p>
<p>Impact:
The attacker is able to access all resources with the permissions
covered by the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of the particular access token.</p>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o  Authorization servers MUST ensure that these transmissions are protected</dt>
<dd>using transport-layer mechanisms such as <a class="reference internal" href="glossary.html#term-tls"><em class="xref std std-term">TLS</em></a> or <a class="reference internal" href="glossary.html#term-ssl"><em class="xref std std-term">SSL</em></a> (see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</dd>
<dt>o  If end-to-end confidentiality cannot be guaranteed,</dt>
<dd>reducing <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a>
(see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>)
and expiry time (<a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>)
for access tokens can be used to reduce the damage in case of leaks.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-access-tokens-from-authorization-server-database">
<span id="oauth-threat-4-3-2"></span><h4><a class="toc-backref" href="#id75">4.3.2.  Threat: Obtain access tokens from authorization server database</a><a class="headerlink" href="#threat-obtain-access-tokens-from-authorization-server-database" title="Permalink to this headline">¶</a></h4>
<p>This threat is applicable
if the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> stores access tokens as handles in a database.
An attacker may obtain access tokens from the authorization server&#8217;s database
by gaining access to the database or launching a SQL injection attack.</p>
<p>Impact: disclosure of all access tokens</p>
<p>Countermeasures:</p>
<blockquote>
<div><p>o  System security measures - <a class="reference internal" href="#oauth-threat-5-1-4-1-1"><em>Section 5.1.4.1.1</em></a></p>
<p>o  Store access token hashes only - <a class="reference internal" href="#oauth-threat-5-1-4-1-3"><em>Section 5.1.4.1.3</em></a></p>
<p>o  Standard SQL injection Countermeasures - <a class="reference internal" href="#oauth-threat-5-1-4-1-2"><em>Section 5.1.4.1.2</em></a></p>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-client-credentials-over-non-secure-transport">
<span id="oauth-threat-4-3-3"></span><h4><a class="toc-backref" href="#id76">4.3.3.  Threat: Obtain client credentials over non secure transport</a><a class="headerlink" href="#threat-obtain-client-credentials-over-non-secure-transport" title="Permalink to this headline">¶</a></h4>
<p>An attacker could attempt to eavesdrop the transmission of <a class="reference internal" href="glossary.html#term-client-credentials"><em class="xref std std-term">client credentials</em></a>
between <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and <a class="reference internal" href="glossary.html#term-server"><em class="xref std std-term">server</em></a> during the client authentication process
or during <em class="xref std std-term">OAuth token requests</em>.</p>
<p>Impact:</p>
<p>Revelation of a client credential enabling the possibility for
<a class="reference internal" href="glossary.html#term-phishing"><em class="xref std std-term">phishing</em></a> or imitation of a client service.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Implement transport security through Confidentiality of Requests</li>
<li>Alternative authentication means,
which do not require to send
plaintext credentials over the wire
(Examples: <em class="xref std std-term">Digest authentication</em>)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-client-secret-from-authorization-server-database">
<span id="oauth-threat-4-3-4"></span><h4><a class="toc-backref" href="#id77">4.3.4.  Threat: Obtain client secret from authorization server database</a><a class="headerlink" href="#threat-obtain-client-secret-from-authorization-server-database" title="Permalink to this headline">¶</a></h4>
<p>An attacker may obtain valid <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a>/secret combinations
from the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>&#8216;s database
by gaining access to the database or launching a <em class="xref std std-term">SQL injection attack</em>.</p>
<p>Impact:
disclosure of all client_id/secret combinations.
This allows the attacker to act on behalf of legitimate clients.</p>
<p>Countermeasures:</p>
<blockquote>
<div>o  Ensure proper handling of credentials as per <a class="reference internal" href="#oauth-threat-5-1-4-1"><em>Credential Storage Protection</em></a>.</div></blockquote>
</div>
<div class="section" id="threat-obtain-client-secret-by-online-guessing">
<span id="oauth-threat-4-3-5"></span><h4><a class="toc-backref" href="#id78">4.3.5.  Threat: Obtain client secret by online guessing</a><a class="headerlink" href="#threat-obtain-client-secret-by-online-guessing" title="Permalink to this headline">¶</a></h4>
<p>An attacker may try to guess valid <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a>/secret pairs.</p>
<p>Impact: disclosure of single client_id/secret pair.</p>
<p>Countermeasures:</p>
<blockquote>
<div><p>o  High entropy of secrets - <a class="reference internal" href="#oauth-threat-5-1-4-2-2"><em>Section 5.1.4.2.2</em></a></p>
<p>o  Lock accounts - <a class="reference internal" href="#oauth-threat-5-1-4-2-2"><em>Section 5.1.4.2.3</em></a></p>
<p>o  Use Strong Client Authentication - <a class="reference internal" href="#oauth-threat-5-2-3-7"><em>Section 5.2.3.7</em></a></p>
</div></blockquote>
</div>
<div class="section" id="threat-dos-on-dynamic-client-secret-creation">
<span id="oauth-threat-4-3-6"></span><h4><a class="toc-backref" href="#id79">4.3.6.  Threat: DoS on dynamic client secret creation</a><a class="headerlink" href="#threat-dos-on-dynamic-client-secret-creation" title="Permalink to this headline">¶</a></h4>
<p>If an authorization servers includes a nontrivial amount of entropy
in client secrets and
if the authorization server automatically grants them,
an attacker could exhaust the pool by repeatedly applying for them.</p>
<p>Countermeasures:</p>
<blockquote>
<div><dl class="docutils">
<dt>o  The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> should consider some <strong>verification step</strong> for new clients.</dt>
<dd>The authorization server should include a
nontrivial amount of <strong>entropy</strong> in client secrets.</dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="obtaining-authorization">
<span id="oauth-threat-4-4"></span><h3><a class="toc-backref" href="#id80">4.4.  Obtaining Authorization</a><a class="headerlink" href="#obtaining-authorization" title="Permalink to this headline">¶</a></h3>
<p>This section covers threats which are specific to certain flows
utilized to obtain <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access tokens</em></a>.</p>
<p>Each flow is characterized by
<a class="reference internal" href="oauth_responses.html#term-response-type"><em class="xref std std-term">response types</em></a> and/or <a class="reference internal" href="glossary.html#term-grant-type"><em class="xref std std-term">grant types</em></a>
on the end-user <a class="reference internal" href="oauth_responses.html#term-authorization-endpoint"><em class="xref std std-term">authorization</em></a> and <a class="reference internal" href="oauth.html#term-token-endpoint"><em class="xref std std-term">tokens endpoint</em></a>, respectively.</p>
<img alt="images/4.4.png" src="images/4.4.png" style="width: 600px;" />
<p>Flows:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1"><em>4.4.1.  Authorization Code</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2"><em>4.4.2.  Implicit Grant</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3"><em>4.4.3.  Resource Owner Password Credentials</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="oauth-threat-4-4-1">
<span id="id12"></span><h4><a class="toc-backref" href="#id81">4.4.1.  Authorization Code</a><a class="headerlink" href="#oauth-threat-4-4-1" title="Permalink to this headline">¶</a></h4>
<p>Threat list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-2"><em>4.4.1.2.  Threat: Obtain authorization codes from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-3"><em>4.4.1.3.  Threat: Online guessing of authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-5"><em>4.4.1.5.  Threat: Authorization code phishing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-6"><em>4.4.1.6.  Threat: User session impersonation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-8"><em>4.4.1.8.  Threat: CSRF attack against redirect-uri</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-9"><em>4.4.1.9.  Threat: Clickjacking attack against authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-10"><em>4.4.1.10.  Threat: Resource Owner Impersonation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-11"><em>4.4.1.11.  Threat: DoS, Exhaustion of resources attacks</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-12"><em>4.4.1.12.  Threat: DoS using manufactured authorization codes</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-eavesdropping-or-leaking-authorization-codes">
<span id="oauth-threat-4-4-1-1"></span><h5><a class="toc-backref" href="#id82">4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</a><a class="headerlink" href="#threat-eavesdropping-or-leaking-authorization-codes" title="Permalink to this headline">¶</a></h5>
<p>An attacker could try to eavesdrop transmission of the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
between <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> and <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>.
Furthermore, authorization codes are passed via the browser
which may unintentionally leak those codes to untrusted web sites and attackers by different ways:</p>
<blockquote>
<div><ul class="simple">
<li>Referrer headers:
browsers frequently pass a &#8220;referer&#8221; header
when a web page embeds content,
or when a user travels from one web page to another web page.
These referrer headers may be sent even
when the origin site does not trust the destination site.
The referee header is commonly logged for traffic analysis purposes.</li>
<li>Request logs:
web server request logs commonly include query parameters on requests.</li>
<li><a class="reference internal" href="glossary.html#term-open-redirectors"><em class="xref std std-term">Open redirectors</em></a>:
web sites sometimes need to send users to another destination via a redirector.
Open redirectors pose a particular risk to web-based delegation protocols
because the redirector can leak verification codes to untrusted destination sites.</li>
<li>Browser history:
web browsers commonly record visited URLs in the browser history.
Another user of the same web browser may be able
to view URLs that were visited by previous users.</li>
</ul>
</div></blockquote>
<p>Note:</p>
<p>A description of a similar attacks on the <em class="xref std std-term">SAML</em> protocol can be found at
<a class="reference external" href="http://www.oasis-open.org/committees/download.php/3405/">http://www.oasis-open.org/committees/download.php/3405/</a> oasis-sstc-saml-bindings-1.1.pdf (S.4.1.1.9.1),
<a class="reference external" href="http://www.thomasgross.net/publications/papers/">http://www.thomasgross.net/publications/papers/</a> GroPfi2006-SAML2_Analysis_Janus.WSSS_06.pdf and
<a class="reference external" href="http://">http://</a> www.oasis-open.org/committees/download.php/11191/ sstc-gross-sec-analysis-response-01.pdf.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Authorization server as well as the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> MUST ensure that
these transmissions are protected using transport-layer mechanisms
such as <a class="reference internal" href="glossary.html#term-tls"><em class="xref std std-term">TLS</em></a> or SSL (see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
<li>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> shall require the client to authenticate wherever possible,
so the binding of the authorization code to a certain client can be validated in a reliable way
(see <a class="reference internal" href="#oauth-threat-5-2-4-4"><em>Section 5.2.4.4</em></a> ).</li>
<li>Limited <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a> of authorization codes - <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a></li>
<li>The authorization server SHOULD enforce a one time usage restriction
(see <a class="reference internal" href="#oauth-threat-5-1-5-4"><em>Section 5.1.5.4</em></a>).</li>
<li>If an Authorization Server observes multiple attempts to redeem a <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>,
the Authorization Server may want to revoke all tokens granted based on the authorization code
(see <a class="reference internal" href="#oauth-threat-5-2-1-1"><em>Section 5.2.1.1</em></a> ).</li>
<li>In the absence of these countermeasures,
reducing <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> (<a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>) and
<em class="xref std std-term">expiry time</em> (<a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>)
for <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access tokens</em></a> can be used to reduce the damage in case of leaks.</li>
<li>The client server may reload the target page of the redirection URI
in order to automatically cleanup the browser cache.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-authorization-codes-from-authorization-server-database">
<span id="oauth-threat-4-4-1-2"></span><h5><a class="toc-backref" href="#id83">4.4.1.2.  Threat: Obtain authorization codes from authorization server database</a><a class="headerlink" href="#threat-obtain-authorization-codes-from-authorization-server-database" title="Permalink to this headline">¶</a></h5>
<p>This threat is applicable
if the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> stores <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization codes</em></a> as handles in a database.</p>
<p>An attacker may obtain authorization codes from the authorization server&#8217;s database
by gaining access to the database or launching a <em class="xref std std-term">SQL injection</em> attack.</p>
<p>Impact:
disclosure of all authorization codes,
most likely along with the respective <a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a> and <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> values.</p>
<blockquote>
<div><ul class="simple">
<li><strong>Credential storage protection</strong> can be employed - <a class="reference internal" href="#oauth-threat-5-1-4-1"><em>Section 5.1.4.1</em></a></li>
<li>System security measures - <a class="reference internal" href="#oauth-threat-5-1-4-1-1"><em>Section 5.1.4.1.1</em></a></li>
<li>Store access token hashes only - <a class="reference internal" href="#oauth-threat-5-1-4-1-3"><em>Section 5.1.4.1.3</em></a></li>
<li>Standard SQL injection countermeasures - <a class="reference internal" href="#oauth-threat-5-1-4-1-2"><em>Section 5.1.4.1.2</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-online-guessing-of-authorization-codes">
<span id="oauth-threat-4-4-1-3"></span><h5><a class="toc-backref" href="#id84">4.4.1.3.  Threat: Online guessing of authorization codes</a><a class="headerlink" href="#threat-online-guessing-of-authorization-codes" title="Permalink to this headline">¶</a></h5>
<p>An attacker may try to guess valid <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> values and
send it using the <a class="reference internal" href="glossary.html#term-grant-type"><em class="xref std std-term">grant type</em></a> &#8220;code&#8221;
in order to obtain a valid <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.</p>
<p>Impact:
disclosure of single access token, probably also associated <em class="xref std std-ref">refresh token</em>.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>For handle-based designs: <a class="reference internal" href="#oauth-threat-5-1-5-11"><em>Section 5.1.5.11</em></a></li>
<li>For assertion-based designs: <a class="reference internal" href="#oauth-threat-5-1-5-9"><em>Section 5.1.5.9</em></a></li>
<li>Authenticate the client, adds another value the attacker has to guess - <a class="reference internal" href="#oauth-threat-5-2-3-4"><em>Section 5.2.3.4</em></a></li>
<li>Binding of authorization code to <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>,
adds another value the attacker has to guess - <a class="reference internal" href="#oauth-threat-5-2-4-5"><em>Section 5.2.4.5</em></a></li>
<li>Short <em class="xref std std-term">expiration time</em> - <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-malicious-client-obtains-authorization">
<span id="oauth-threat-4-4-1-4"></span><h5><a class="toc-backref" href="#id85">4.4.1.4.  Threat: Malicious client obtains authorization</a><a class="headerlink" href="#threat-malicious-client-obtains-authorization" title="Permalink to this headline">¶</a></h5>
<p>A malicious client could counterfeit a valid client and
obtain an access authorization that way.
The malicious client could even utilize screen scraping techniques
in order to simulate the user consent in the authorization flow.</p>
<p>Assumption:
It is not the task of the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
to protect the end-user&#8217;s device from malicious software.
This is the responsibility of the platform running
on the particular device probably in cooperation
with other components of the respective ecosystem
(e.g. an application management infrastructure).
The sole responsibility of the authorization server is to control access
to the end-user&#8217;s resources living in resource servers and
to prevent unauthorized access to them.
Based on this assumption,
the following countermeasures are available to cope with the threat.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul>
<li><p class="first">The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> should authentication the client,
if possible (see <a class="reference internal" href="#oauth-threat-5-2-3-4"><em>Section 5.2.3.4</em></a>).</p>
<p>Note:
the authentication takes
place after the end-user has authorized the access.</p>
</li>
<li><p class="first">The authorization server should validate the client&#8217;s <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>
against the pre-registered redirection URI, if one exists (see <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a>).</p>
<p>Note:
The validation of the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> is
the only technical mean to recognize a malicious <em class="xref std std-ref">client id</em>
in advance of the authorization process.
Further note this does not work for <em class="xref std std-term">native applications</em>
because in contrast to <em class="xref std std-ref">web applications</em> this URI is not bound to a single communication endpoint.
The valid client&#8217;s redirection URI (typically with custom scheme) can be used by a malicious client on any device.</p>
</li>
<li><p class="first">After authenticating the end-user,
the authorization server should ask him/her for <em class="xref std std-term">consent</em>.
In this context, the user shall be explained
the <em class="xref std std-term">purpose</em>, <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a>, and <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a> of the authorization.
Moreover, the authorization server must view to the end-user the <strong>meta data</strong> <a class="footnote-reference" href="#id14" id="id13">[6]</a>
it associates with the particular client.
It is up to the user to validate the binding of this data to the particular application
(e.g.  Name) and to approve the authorization request.
(see <a class="reference internal" href="#oauth-threat-5-2-4-3"><em>Section 5.2.4.3</em></a> ).</p>
</li>
<li><p class="first">The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> must not perform automatic re-authorizations
for clients it is unable to reliably authenticate or validate (see <em class="xref std std-term">Section 5.2.4.1</em> ).</p>
</li>
<li><p class="first">If the authorization server automatically authenticates the end-user,
it may nevertheless require some user input in order to prevent screen scraping.
Examples are <em class="xref std std-term">CAPTCHAs</em> or user-specific secret like <em class="xref std std-term">PIN codes</em>.</p>
</li>
<li><p class="first">The authorization server may also limit the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of tokens it issues to clients
it cannot reliably authenticate (see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a> ).</p>
</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[6]</a></td><td>Connect&#8217;s UserInfo ?</td></tr>
</tbody>
</table>
</div>
<div class="section" id="threat-authorization-code-phishing">
<span id="oauth-threat-4-4-1-5"></span><h5><a class="toc-backref" href="#id86">4.4.1.5.  Threat: Authorization code phishing</a><a class="headerlink" href="#threat-authorization-code-phishing" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Is this NOT redirect URI phishing?
Becase Authorization Code can be transfered in POST data to clients ?</p>
</div>
<p>A hostile party could impersonate the client site and
get access to the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>.
This could be achieved using DNS or ARP <strong>spoofing</strong>.
This applies to clients, which are web applications, thus
the <em class="xref std std-term">redirect URI</em> is not local to the host
where the user&#8217;s browser is running.</p>
<p>Impact:
This affects web applications and may lead to a disclosure of authorization codes and,
potentially, the corresponding access and <em class="xref std std-ref">refresh tokens</em>.</p>
<p>Countermeasures:</p>
<p>It is strongly recommended that one of the following countermeasures
is utilized in order to prevent this attack:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> of the client SHOULD point to a HTTPS protected endpoint
and the browser shall be utilized to authenticate this redirection URI
using server authentication (see <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a>).</li>
<li>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> SHOULD require the client to be authenticated,
i.e. confidential client, so the binding of the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
to a certain client can be validated in a reliable way (see <em class="xref std std-ref">Section 5.2.4.4</em>).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-user-session-impersonation">
<span id="oauth-threat-4-4-1-6"></span><h5><a class="toc-backref" href="#id87">4.4.1.6.  Threat: User session impersonation</a><a class="headerlink" href="#threat-user-session-impersonation" title="Permalink to this headline">¶</a></h5>
<p>A hostile party could impersonate the client site and
impersonate the user&#8217;s <a class="reference internal" href="session.html#term-session"><em class="xref std std-term">session</em></a> <a class="footnote-reference" href="#id16" id="id15">[7]</a> on this client.
This could be achieved using DNS or ARP spoofing.</p>
<p>This applies to clients, which are <em class="xref std std-ref">web applications</em>,
thus the <em class="xref std std-ref">redirect URI</em> is not local to the host
where the user&#8217;s browser is running.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[7]</a></td><td>Session key ?</td></tr>
</tbody>
</table>
<p>Impact:
An attacker who intercepts the <em class="xref std std-ref">authorization code</em>
as it is sent by the browser to the callback endpoint can gain access to <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a>
by submitting the authorization code to the <em class="xref std std-ref">client</em>.
The client will exchange the authorization code for an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>
and use the access token to access <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a>
for the benefit of the attacker,
delivering protected resources to the attacker,
or modifying protected resources as directed by the attacker.
If <a class="reference internal" href="oauth.html"><em>OAuth</em></a> is used by the client to delegate authentication to a social site
(e.g. as in the implementation of the &#8220;Facebook Login&#8221; button),
the attacker can use the intercepted authorization code to log in to the client as the user.</p>
<p>Note:
Authenticating the client during authorization code exchange will not help
to detect such an attack as it is the legitimate client that obtains the tokens.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>In order to prevent an attacker from impersonating the end-users session,
the <em class="xref std std-ref">redirection URI</em> of the client MUST point to a HTTPS protected endpoint
and the browser shall be utilized to authenticate this redirection URI
using server authentication (see <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a>)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-authorization-code-leakage-through-counterfeit-client">
<span id="oauth-threat-4-4-1-7"></span><h5><a class="toc-backref" href="#id88">4.4.1.7.  Threat: Authorization code leakage through counterfeit client</a><a class="headerlink" href="#threat-authorization-code-leakage-through-counterfeit-client" title="Permalink to this headline">¶</a></h5>
<p>The attack leverages the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> <a class="reference internal" href="glossary.html#term-grant-type"><em class="xref std std-term">grant type</em></a>
in an attempt to get another user (victim) to log-in,
authorize access to his/her resources,
and subsequently obtain the authorization code
and inject it into a client application
using the attacker&#8217;s account.
The goal is to associate an access authorization for resources of the victim
with the user account of the attacker on a client site.</p>
<p>The attacker abuses an existing client application and
combines it with his own counterfeit client web site.
The attack depends on the victim expecting the client application
to request access to a certain resource server.
The victim, seeing only a normal request from an expected application, approves the request.
The attacker then uses the victim&#8217;s authorization
to gain access to the information unknowingly authorized by the victim.</p>
<img alt="images/4.4.1.7.png" src="images/4.4.1.7.png" style="width: 600px;" />
<p>The attacker conducts the following flow:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The attacker accesses the client web site (or application) and
initiates data access to a particular resource server.
The client web site in turn initiates an authorization request to the
resource server&#8217;s <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
Instead of proceeding with the authorization process,
the attacker modifies the authorization server end-user authorization URL
as constructed by the client to include a redirection URI parameter referring
to a web site under his control (attacker&#8217;s web site).</li>
<li>The attacker tricks another user (the victim) to open that
modified end-user authorization URI and to authorize access
(e.g.  an email link, or blog link).
The way the attacker achieve that goal is out of scope.</li>
<li>Having clicked the link,
the victim is requested to authenticate and authorize the client site to have access.</li>
<li>After completion of the authorization process,
the authorization server redirects the user agent to the attacker&#8217;s web site
instead of the original client web site.</li>
<li>The attacker obtains the authorization code from his web site
by means out of scope of this document.</li>
<li>He then constructs a <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> to the target web site
(or application) based on the original authorization request&#8217;s redirection URI
and the newly obtained authorization code and directs his user agent to this URL.
The authorization code is injected into the original client site (or application).</li>
<li>The client site uses the authorization code to fetch a token
from the authorization server and associates this token with the attacker&#8217;s user account on this site.</li>
<li>The attacker may now access the victims resources using the client site.</li>
</ol>
</div></blockquote>
<p>Impact:
The attackers gains access to the victim&#8217;s resources as
associated with his account on the client site.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The attacker must use another redirection URI for its
authorization process than the target web site
because it needs to intercept the flow.
So if the authorization server associates the
authorization code with the redirection URI of a particular end-user authorization
and validates this redirection URI with the redirection URI passed to the tokens endpoint,
such an attack is detected (see <a class="reference internal" href="#oauth-threat-5-2-4-5"><em>Section 5.2.4.5</em></a>).</li>
<li>The authorization server may also enforce the usage and validation
of pre-registered redirect URIs (see <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>Section 5.2.3.5</em></a>).
This will allow for an early recognition of session fixation attempts.</li>
<li>For native applications,
one could also consider to use deployment-specific client ids and secrets (see <a class="reference internal" href="#oauth-threat-5-2-3-4"><em>Section 5.2.3.4</em></a> ),
along with the binding of authorization code to client_id (see <a class="reference internal" href="#oauth-threat-5-2-4-4"><em>Section 5.2.4.4</em></a> ),
to detect such an attack <strong>because the attacker does not have access the deployment-specific secret</strong>.
Thus he will not be able to exchange the authorization code.</li>
<li>The client may consider to use other flows,
which are not vulnerable to this kind of attacks such as &#8220;Implicit Grant&#8221; or
&#8220;Resource Owner Password Credentials&#8221;
(see <a class="reference internal" href="#oauth-threat-4-4-2"><em>Section 4.4.2</em></a> or <a class="reference internal" href="#oauth-threat-4-4-3"><em>Section 4.4.3</em></a>).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-csrf-attack-against-redirect-uri">
<span id="oauth-threat-4-4-1-8"></span><h5><a class="toc-backref" href="#id89">4.4.1.8.  Threat: CSRF attack against redirect-uri</a><a class="headerlink" href="#threat-csrf-attack-against-redirect-uri" title="Permalink to this headline">¶</a></h5>
<p>Cross-Site Request Forgery (<a class="reference internal" href="glossary.html#term-csrf"><em class="xref std std-term">CSRF</em></a>) is a web-based attack
whereby HTTP requests are transmitted from a user
that the website trusts or has authenticated
(e.g., via HTTP redirects or HTML forms).</p>
<p>CSRF attacks on <a class="reference internal" href="oauth.html"><em>OAuth</em></a> approvals can allow an attacker
to obtain authorization to OAuth <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a>
without the consent of the User.</p>
<p>This attack works against the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>
used in the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> flow.
An attacker could authorize an authorization code
to their own <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a> on an <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
He then aborts the redirect flow back to the client on his device
and tricks the victim into executing the redirect back to the client.
The client receives the redirect, fetches the token(s)
from the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
and associates the victim&#8217;s client session with the resources accessible
using the token.</p>
<p>Impact:
The user accesses resources on behalf of the attacker.
The effective impact depends on the type of resource accessed.
For example, the user may upload private items to an attacker&#8217;s resources.
Or when using OAuth in 3rd party login scenarios,
the user may associate his client account with the attacker&#8217;s identity
at the external identity provider.
This way the attacker could easily access the victim&#8217;s data
at the client by logging in from another device
with his credentials at the external identity provider.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter should be used to link the authorization request
with the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> used to deliver the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.
<a class="reference internal" href="#oauth-threat-5-3-6"><em>Section 5.3.6</em></a></li>
<li>Client developers and end-user can be educated <strong>not follow untrusted URLs</strong>.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-5-3-6"><em>5.3.6.  Link state parameter to user agent session</em></a></li>
</ul>
</div>
</div>
<div class="section" id="threat-clickjacking-attack-against-authorization">
<span id="oauth-threat-4-4-1-9"></span><h5><a class="toc-backref" href="#id90">4.4.1.9.  Threat: Clickjacking attack against authorization</a><a class="headerlink" href="#threat-clickjacking-attack-against-authorization" title="Permalink to this headline">¶</a></h5>
<p>With <a class="reference internal" href="glossary.html#term-clickjacking"><em class="xref std std-term">Clickjacking</em></a>,
a malicious site loads the target site in a transparent iframe
overlaid on top of a set of dummy buttons
which are carefully constructed to be placed directly
under important buttons on the target site.</p>
<p>When a user clicks a visible button,
they are actually clicking a button (such as an &#8220;Authorize&#8221; button) on the hidden page.</p>
<p>Impact:
An attacker can steal a user&#8217;s authentication credentials and
access their resources</p>
<p>Countermeasure</p>
<blockquote>
<div><ul class="simple">
<li>Native applications SHOULD use external browsers instead of
<strong>embedding browsers</strong> in an iFrame when requesting end-user authorization</li>
<li>For newer browsers,
avoidance of iFrames can be enforced server side
by using the <a class="reference internal" href="glossary.html#term-x-frame-option"><em class="xref std std-term">X-FRAME-OPTION</em></a> header - <a class="reference internal" href="#oauth-threat-5-2-2-6"><em>Section 5.2.2.6</em></a></li>
<li>For older browsers,
<a class="reference internal" href="glossary.html#term-javascript-framebusting"><em class="xref std std-term">javascript framebusting</em></a> techniques can be used
but may not be effective in all browsers.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-resource-owner-impersonation">
<span id="oauth-threat-4-4-1-10"></span><h5><a class="toc-backref" href="#id91">4.4.1.10.  Threat: Resource Owner Impersonation</a><a class="headerlink" href="#threat-resource-owner-impersonation" title="Permalink to this headline">¶</a></h5>
<p>When a <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> requests access to protected resources,
the authorization flow normally involves the resource owner&#8217;s explicit response
to the access request,
either granting or denying access to the protected resources.</p>
<p>A malicious client can exploit knowledge of the structure of this flow
in order to gain authorization without the resource owner&#8217;s consent,
by transmitting the necessary requests programmatically,
and simulating the flow against the authorization server.</p>
<p>That way,
the client may gain access to the victims resources without her approval.
An authorization server will be vulnerable to this threat,
if it uses non-interactive authentication mechanisms
or split the authorization flow across multiple pages.</p>
<p>The malicious client might embbed a hidden HTML user agent,
interpret the HTML forms sent by the authorization server,
and automatically answer with the corresponding form post requests.
As a pre-requisiete,
the attacker must be able to execute the authorization process
in the context of an already authenticated session of
the resource owner with the authorization server.</p>
<p>There are different ways to achieve this:</p>
<blockquote>
<div><ul class="simple">
<li>The malicious client could abuse an existing session
in an external browser or cross-browser cookies
on the particular device.</li>
<li>It could also request authorization for a particular scope and
silently abuse the resulting session in his browser instance to
&#8220;silently&#8221; request another scope.</li>
<li>Alternatively,
the attacker might exploit an authorization server&#8217;s aibility
to authenticate the resource owner automatically
and without user interactions, e.g. based on certificates.</li>
</ul>
</div></blockquote>
<p>In all cases,
such an attack is limited to clients running on the victim&#8217;s device,
within the user agent or as native app.</p>
<p>Please note:
Such attacks cannot be prevented using CSRF countermeasures,
since the attacker just &#8220;executes&#8221; the URLs
as prepared by the authorization server including any nonce e.t.c.</p>
<p>Countermeasures:</p>
<p>Authorization servers should decide,
based on an analysis of the risk associated with this threat,
whether to assume, detect, or to prevent this threat.</p>
<p>In order to prevent such an attack,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may force an user interaction
based on non-predictable input values as part of the user consent approval.
The authorization server could</p>
<blockquote>
<div><ul class="simple">
<li>combine password authentication and user consent in a single form,</li>
<li>make use of CAPTCHAs, or</li>
<li>or use one-time secrets send out of bound to the resource owner
(e.g. via text or instance message).</li>
</ul>
</div></blockquote>
<p>Alternatively in order to allow the resource owner to detect abuse,
the authorization server could notify the resource owner of any
approval by appropriate means, e.g. text or instant message or
e-Mail.</p>
</div>
<div class="section" id="threat-dos-exhaustion-of-resources-attacks">
<span id="oauth-threat-4-4-1-11"></span><h5><a class="toc-backref" href="#id92">4.4.1.11.  Threat: DoS, Exhaustion of resources attacks</a><a class="headerlink" href="#threat-dos-exhaustion-of-resources-attacks" title="Permalink to this headline">¶</a></h5>
<p>If an <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> includes a nontrivial amount of entropy
in authorization codes or access tokens
(limiting the number of possible codes/tokens) and
automatically grants either without user intervention and
has no limit on code or access tokens per user,
an attacker could exhaust the pool by repeatedly directing user(s) browser
to request code or access tokens.
This is because more entropy means a larger number of tokens can be issued.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The authorization server should consider limiting the number of
access tokens granted per user.
The authorization server should
include a nontrivial amount of entropy in authorization codes.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-dos-using-manufactured-authorization-codes">
<span id="oauth-threat-4-4-1-12"></span><h5><a class="toc-backref" href="#id93">4.4.1.12.  Threat: DoS using manufactured authorization codes</a><a class="headerlink" href="#threat-dos-using-manufactured-authorization-codes" title="Permalink to this headline">¶</a></h5>
<p>An attacker who owns a botnet can locate the redirect URIs of clients
that listen on HTTP,
access them with random authorization codes,
and cause a large number of HTTPS connections to be concentrated
onto the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.</p>
<p>This can result in a <em class="xref std std-term">DoS attack</em> on the authorization server.</p>
<p>This attack can still be effective even
when <a class="reference internal" href="glossary.html#term-csrf"><em class="xref std std-term">CSRF</em></a> defense/the &#8216;state&#8217; parameter are deployed on the client side.
With such a defense,
the attacker might need to incur an additional HTTP request
to obtain a valid CSRF code/ state parameter.</p>
<p>This apparently cuts down the effectiveness of the attack by a factor of 2.
However, if the HTTPS/HTTP cost ratio is higher than 2
(the cost factor is estimated to be around 3.5x at
<a class="reference external" href="http://www.semicomplete.com/blog/geekery/ssl-latency.html">http://www.semicomplete.com/blog/geekery/ssl-latency.html</a>),
the attacker still achieves a magnification of resource utilization at
the expense of the authorization server.</p>
<p>Impact:
There are a few effects that the attacker can accomplish with this OAuth flow
that they cannot easily achieve otherwise.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Connection laundering:
With the clients as the relay between the attacker and the authorization server,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> learns little or no information
about the identity of the attacker.
Defenses such rate limiting on the offending attacker machines are less effective
due to the difficulty to identify the attacking machines.
Although an attacker could also launder its
connections through an anonymizing systems such as Tor, the
effectiveness of that approach depends on the capacity of the
annoying system.  On the other hand, a potentially large number
of OAuth clients could be utilized for this attack.</li>
<li>Asymmetric resource utilization:
The attacker incurs the cost of an HTTP connection and
causes an HTTPS connection to be made on the authorization server;
and the attacker can co-ordinate the
timing of such HTTPS connections across multiple clients
relatively easily.  Although the attacker could achieve something
similar, say, by including an iframe pointing to the HTTPS URL of
the authorization server in an HTTP web page and lure web users
to visit that page, timing attacks using such a scheme may be
more difficult as it seems nontrivial to synchronize a large
number of users to simultaneously visit a particular site under
the attacker&#8217;s control.</li>
</ol>
</div></blockquote>
<p>Countermeasures</p>
<blockquote>
<div><ul class="simple">
<li>Though not a complete countermeasure by themselves, CSRF defense
and the &#8216;state&#8217; parameter created with secure random codes SHOULD
be deployed on the client side.  The client SHOULD forward the
authorization code to the authorization server only after both the
CSRF token and the &#8216;state&#8217; parameter are validated.</li>
<li>If the client authenticates the user, either through a single sign
on protocol ( such as OpenID / Facebook Connect ) or through local
authentication, the client SHOULD suspend the access by a user
account if the number of invalid authorization codes submitted by
this user exceeds a certain threshold.</li>
<li>The authorization server SHOULD send an error response to the
client reporting an invalid authorization code and rate limit or
disallow connections from clients whose number of invalid requests
exceeds a threshold.</li>
<li>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MAY in addition sign
the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> using the public key from its SSL certificate,
and require the client to validate the signature.
To enhance interoperability
between multiple clients and authorization servers, a standard
procedure to create and validate the signature (including what
attributes to sign) MAY be developed and agreed between the
clients and the servers.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="implicit-grant">
<span id="oauth-threat-4-4-2"></span><h4><a class="toc-backref" href="#id94">4.4.2.  Implicit Grant</a><a class="headerlink" href="#implicit-grant" title="Permalink to this headline">¶</a></h4>
<p>In the implicit grant type flow,
the access token is directly returned to the client as a <em class="xref std std-term">fragment part</em> of the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>.
It is assumed that the <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a> is not sent to the redirection URI target
since HTTP user agents do not send fragments server requests.
Thus an attacker cannot eavesdrop the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> on this communication path and
It cannot leak through HTTP referee headers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
</ul>
</div>
<p>Threat list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-4-2-1"><em>4.4.2.1.  Threat: Access token leak in transport/end-points</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-2"><em>4.4.2.2.  Threat: Access token leak in browser history</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-3"><em>4.4.2.3.  Threat: Malicious client obtains authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-4"><em>4.4.2.4.  Threat: Manipulation of scripts</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-5"><em>4.4.2.5.  Threat: CSRF attack against redirect-uri</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-access-token-leak-in-transport-end-points">
<span id="oauth-threat-4-4-2-1"></span><h5><a class="toc-backref" href="#id95">4.4.2.1.  Threat: Access token leak in transport/end-points</a><a class="headerlink" href="#threat-access-token-leak-in-transport-end-points" title="Permalink to this headline">¶</a></h5>
<p>This <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a> might be eavesdropped by an attacker.
The token is sent from server to client via a <em class="xref std std-term">URI fragment</em> of <em class="xref std std-term">the redirection URI</em>.
If the communication is not secured or the end-point is not secured,
the token could be leaked by parsing the returned URI.</p>
<p>Impact:
the attacker would be able to assume the same rights granted by the token.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> must ensure confidentiality of
the response from the authorization server to the client
(see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">&#8220;confidentiality of the response&#8221; ? Section 5.1.1 is about &#8220;confidentiality of the request&#8221;.</p>
</div>
</div>
<div class="section" id="threat-access-token-leak-in-browser-history">
<span id="oauth-threat-4-4-2-2"></span><h5><a class="toc-backref" href="#id96">4.4.2.2.  Threat: Access token leak in browser history</a><a class="headerlink" href="#threat-access-token-leak-in-browser-history" title="Permalink to this headline">¶</a></h5>
<p>An attacker could obtain the <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a> from the <em class="xref std std-term">browsers history</em>.
Note this means the attacker needs access to the particular device.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Shorten <em class="xref std std-term">token duration</em> (see <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>)
and reduced <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of the token may reduce the impact of that attack
(see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>).</li>
<li>Make these requests non-cachable <a class="footnote-reference" href="#id18" id="id17">[8]</a></li>
<li>Native applications can directly embed a browser widget and
therewith gain full control of the cache.
So the application can <strong>cleanup browser history</strong>
after authorization process</li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[8]</a></td><td>How to make non-cachealbe request (response ?) ?</td></tr>
</tbody>
</table>
</div>
<div class="section" id="oauth-threat-4-4-2-3">
<span id="id19"></span><h5><a class="toc-backref" href="#id97">4.4.2.3.  Threat: Malicious client obtains authorization</a><a class="headerlink" href="#oauth-threat-4-4-2-3" title="Permalink to this headline">¶</a></h5>
<p>An malicious <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> could attempt to obtain a token by fraud.</p>
<p>The same countermeasures as for <a class="reference internal" href="#oauth-threat-4-4-1-4"><em>Section 4.4.1.4</em></a> are applicable,
except client authentication.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Malicious Javascript can send <a class="reference internal" href="standard.html#term-30"><em class="xref std std-term">access_token</em></a> in <em class="xref std std-ref">URI fragment</em> to somewhere.</p>
</div>
</div>
<div class="section" id="threat-manipulation-of-scripts">
<span id="oauth-threat-4-4-2-4"></span><h5><a class="toc-backref" href="#id98">4.4.2.4.  Threat: Manipulation of scripts</a><a class="headerlink" href="#threat-manipulation-of-scripts" title="Permalink to this headline">¶</a></h5>
<p>A hostile party could act as the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> web server and
replace or modify the actual implementation of the client (script).
This could be achieved using DNS or ARP spoofing.
This applies to clients implemented
within the Web Browser in a scripting language.</p>
<p>Impact:
The attacker could obtain user credential information and
assume the full identity of the user.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> must authenticate the server from which
scripts are obtained (see <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a>).</li>
<li>The client must ensure that scripts obtained have not been altered in transport
(see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
<li>Introduce <strong>one time per-use secrets</strong> (e.g. <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">client_secret</em></a>) values
that can only be used by scripts in a small time window once loaded from a server.
The intention would be to reduce the effectiveness of
copying client-side scripts for re-use in an attackers modified code.
[[pending discussion]]</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="oauth-threat-4-4-2-5">
<span id="id20"></span><h5><a class="toc-backref" href="#id99">4.4.2.5.  Threat: CSRF attack against redirect-uri</a><a class="headerlink" href="#oauth-threat-4-4-2-5" title="Permalink to this headline">¶</a></h5>
<p>Cross-Site Request Forgery (<a class="reference internal" href="glossary.html#term-csrf"><em class="xref std std-term">CSRF</em></a>) is a web-based attack
whereby HTTP requests are transmitted from a user
that the website trusts or has authenticated
(e.g., via HTTP redirects or HTML forms).
CSRF attacks on OAuth approvals can allow an attacker
to obtain authorization to OAuth protected resources
without the consent of the User.</p>
<p>This attack works against the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> used in the implicit grant flow.
An attacker could acquire an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> to their own protected resources.
He could then construct a redirection URI and embed their access token in that URI.
If he can trick the user into following the redirection URI and
the client does not have protection against this attack,
the user may have the attacker&#8217;s access token authorized within their client.</p>
<p>Impact:
The user accesses resources on behalf of the attacker.
The effective impact depends on the type of resource accessed.
For example, the user may upload private items to an attacker&#8217;s resources.
Or when using OAuth in 3rd party login scenarios,
the user may associate his client account with the attacker&#8217;s identity
at the external identity provider.
This way the attacker could easily access the victim&#8217;s data
at the client by logging in from another device with his credentials
at the external identity provider.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter should be used to link the authorization request
with the redirection URI used deliver the access token.
This will ensure the client is not tricked into completing any redirect callback
unless it is linked to an <a class="reference internal" href="glossary.html#term-authorization-request"><em class="xref std std-term">authorization request</em></a>
the client initiated.
The <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter should be unguessable and
the client should be capable of keeping the <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter <strong>secret</strong>.</li>
<li>Client developers and end-user can be educated not follow untrusted URLs.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="resource-owner-password-credentials">
<span id="oauth-threat-4-4-3"></span><h4><a class="toc-backref" href="#id100">4.4.3.  Resource Owner Password Credentials</a><a class="headerlink" href="#resource-owner-password-credentials" title="Permalink to this headline">¶</a></h4>
<p>The &#8220;Resource Owner Password Credentials&#8221; grant type (see [I-D.ietf-oauth-v2], <a class="reference internal" href="oauth.html#oauth-4-3"><em>Section 4.3</em></a>),
often used for legacy/migration reasons, allows a client to request an access token using an end-users user-id
and password along with its own credential.
This grant type has higher risk because it maintains the uid/password anti-pattern.</p>
<p>Additionally, because the user does not have control over
the authorization process, clients using this grant type are not
limited by scope, but instead have potentially the same capabilities
as the user themselves.  As there is no authorization step, the
ability to offer token revocation is bypassed.</p>
<p>Impact:
The resource server can only differentiate scope based on the
access token being associated with a particular client.  The client
could also acquire long-living tokens and pass them up to a attacker
web service for further abuse.  The client, eavesdroppers, or end-
points could eavesdrop user id and password.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Except for migration reasons, minimize use of this grant type</li>
<li>The authorization server must validate the client id associated
with the particular refresh token with every refresh request -
<a class="reference internal" href="#oauth-threat-5-2-2-2"><em>Section 5.2.2.2</em></a></li>
<li>Authorization server MUST ensure that these transmissions are
protected using transport-layer mechanisms such as TLS or SSL
(see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
</ul>
</div>
<p>Threat list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-1"><em>4.4.3.1.  Threat: Accidental exposure of passwords at client site</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-2"><em>4.4.3.2.  Threat: Client obtains scopes without end-user authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-3"><em>4.4.3.3.  Threat: Client obtains refresh token through automatic authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-4"><em>4.4.3.4.  Threat: Obtain user passwords on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-5"><em>4.4.3.5.  Threat: Obtain user passwords from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-6"><em>4.4.3.6.  Threat: Online guessing</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="threat-accidental-exposure-of-passwords-at-client-site">
<span id="oauth-threat-4-4-3-1"></span><h5><a class="toc-backref" href="#id101">4.4.3.1.  Threat: Accidental exposure of passwords at client site</a><a class="headerlink" href="#threat-accidental-exposure-of-passwords-at-client-site" title="Permalink to this headline">¶</a></h5>
<p>If the client does not provide enough protection, an attacker or
disgruntled employee could retrieve the passwords for a user.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Use other flows, which do not rely on the client&#8217;s cooperation for
secure resource owner credential handling</li>
<li>Use digest authentication instead of plaintext credential
processing</li>
<li>Obfuscation of passwords in logs</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-client-obtains-scopes-without-end-user-authorization">
<span id="oauth-threat-4-4-3-2"></span><h5><a class="toc-backref" href="#id102">4.4.3.2.  Threat: Client obtains scopes without end-user authorization</a><a class="headerlink" href="#threat-client-obtains-scopes-without-end-user-authorization" title="Permalink to this headline">¶</a></h5>
<p>All interaction with the resource owner is performed by the client.
it might, intentionally or unintentionally, happen that the
client obtains a token with scope unknown for or unintended by the
resource owner.  For example, the resource owner might think the
client needs and acquires read-only access to its media storage only
but the client tries to acquire an access token with full access
permissions.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Use other flows, which do not rely on the client&#8217;s cooperation for
resource owner interaction</li>
<li>The authorization server may generally restrict the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> of
access tokens (<a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>) issued by this flow.  If the
particular client is trustworthy and can be authenticated in a
reliable way, the authorization server could relax that
restriction.  Resource owners may prescribe (e.g. in their
preferences) what the maximum permission for client using this
flow shall be.</li>
<li>The authorization server could notify the resource owner by an
appropriate media, e.g. e-Mail, of the grant issued (see
<a class="reference internal" href="#oauth-threat-5-1-3"><em>Section 5.1.3</em></a>).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-client-obtains-refresh-token-through-automatic-authorization">
<span id="oauth-threat-4-4-3-3"></span><h5><a class="toc-backref" href="#id103">4.4.3.3.  Threat: Client obtains refresh token through automatic authorization</a><a class="headerlink" href="#threat-client-obtains-refresh-token-through-automatic-authorization" title="Permalink to this headline">¶</a></h5>
<p>All interaction with the <a class="reference internal" href="oauth.html#term-resource-owner"><em class="xref std std-term">resource owner</em></a> is performed by the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>. <a class="footnote-reference" href="#id22" id="id21">[9]</a>
Thus it might, intentionally or unintentionally, happen that
the client obtains a long-term authorization represented by a <em class="xref std std-ref">refresh token</em>
even if the resource owner did not intend so.</p>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[9]</a></td><td>What does this mean? Initiation?  Server-initiated flow is not allowed ?</td></tr>
</tbody>
</table>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Use other flows, which do not rely on the client&#8217;s cooperation for
resource owner interaction</li>
<li>The authorization server may generally refuse to issue refresh
tokens in this flow (see <a class="reference internal" href="#oauth-threat-5-2-2-1"><em>Section 5.2.2.1</em></a>).
If the particular client is trustworthy and can be authenticated in a reliable way
(see client authentication), the authorization server could relax
that restriction.  Resource owners may allow or deny (e.g. in
their preferences) to issue refresh tokens using this flow as
well.</li>
</ul>
<dl class="docutils">
<dt>o  The authorization server could notify the resource owner by an</dt>
<dd>appropriate media, e.g. e-Mail, of the refresh token issued (see
<a class="reference internal" href="#oauth-threat-5-1-3"><em>Section 5.1.3</em></a>).</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-user-passwords-on-transport">
<span id="oauth-threat-4-4-3-4"></span><h5><a class="toc-backref" href="#id104">4.4.3.4.  Threat: Obtain user passwords on transport</a><a class="headerlink" href="#threat-obtain-user-passwords-on-transport" title="Permalink to this headline">¶</a></h5>
<p>An attacker could attempt to eavesdrop the transmission of end-user credentials
with the grant type &#8220;password&#8221; between client and server.</p>
<p>Impact:
disclosure of a single end-users password.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Confidentiality of Requests - <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a></li>
<li>alternative authentication means, which do not require to send
plaintext credentials over the wire (Examples: Digest
authentication)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-user-passwords-from-authorization-server-database">
<span id="oauth-threat-4-4-3-5"></span><h5><a class="toc-backref" href="#id105">4.4.3.5.  Threat: Obtain user passwords from authorization server database</a><a class="headerlink" href="#threat-obtain-user-passwords-from-authorization-server-database" title="Permalink to this headline">¶</a></h5>
<p>An attacker may obtain valid username/password combinations from
the authorization server&#8217;s database by
gaining access to the database or launching a SQL injection attack.</p>
<p>Impact:
disclosure of all username/password combinations.
The impact may exceed the domain of the authorization server since many users
tend to use the same credentials on different services.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Credential storage protection can be employed - <a class="reference internal" href="#oauth-threat-5-1-4-1"><em>Section 5.1.4.1</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-online-guessing">
<span id="oauth-threat-4-4-3-6"></span><h5><a class="toc-backref" href="#id106">4.4.3.6.  Threat: Online guessing</a><a class="headerlink" href="#threat-online-guessing" title="Permalink to this headline">¶</a></h5>
<p>An attacker may try to guess valid username/password combinations
using the grant type &#8220;password&#8221;.</p>
<p>Impact:
Revelation of a single username/password combination.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Password policy - <a class="reference internal" href="#oauth-threat-5-1-4-2-1"><em>Section 5.1.4.2.1</em></a></li>
<li>Lock accounts - <a class="reference internal" href="#oauth-threat-5-1-4-2-3"><em>Section 5.1.4.2.3</em></a></li>
<li>Tar pit - <a class="reference internal" href="#oauth-threat-5-1-4-2-4"><em>Section 5.1.4.2.4</em></a></li>
<li>CAPTCHA - <a class="reference internal" href="#oauth-threat-5-1-4-2-5"><em>Section 5.1.4.2.5</em></a></li>
<li>Abandon on grant type &#8220;password&#8221;</li>
<li>Client authentication (see <em class="xref std std-term">Section 5.2.3</em> ) will provide another
authentication factor and thus hinder the attack.</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="refreshing-an-access-token">
<span id="oauth-threat-4-5"></span><h3><a class="toc-backref" href="#id107">4.5.  Refreshing an Access Token</a><a class="headerlink" href="#refreshing-an-access-token" title="Permalink to this headline">¶</a></h3>
<p>Threat list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-5-1"><em>4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-2"><em>4.5.2.  Threat: Obtaining refresh token from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-3"><em>4.5.3.  Threat: Obtain refresh token by online guessing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-4"><em>4.5.4.  Threat: Obtain refresh token phishing by counterfeit authorization server</em></a></li>
</ul>
</div></blockquote>
<img alt="images/4.5.png" src="images/4.5.png" style="width: 600px;" />
<div class="section" id="threat-eavesdropping-refresh-tokens-from-authorization-server">
<span id="oauth-threat-4-5-1"></span><h4><a class="toc-backref" href="#id108">4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</a><a class="headerlink" href="#threat-eavesdropping-refresh-tokens-from-authorization-server" title="Permalink to this headline">¶</a></h4>
<p>An attacker may eavesdrop <em class="xref std std-ref">refresh tokens</em>
when they are transmitted from the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> to the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Authorization servers MUST ensure that these transmissions are
protected using transport-layer mechanisms such as <a class="reference internal" href="glossary.html#term-tls"><em class="xref std std-term">TLS</em></a> or <em class="xref std std-ref">SSL</em>
(see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
<li>If end-to-end confidentiality cannot be guaranteed, reducing <em class="xref std std-ref">scope</em>
(see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>)
and <em class="xref std std-term">expiry time</em> (see <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>) for
issued access tokens can be used to reduce the damage in case of leaks.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtaining-refresh-token-from-authorization-server-database">
<span id="oauth-threat-4-5-2"></span><h4><a class="toc-backref" href="#id109">4.5.2.  Threat: Obtaining refresh token from authorization server database</a><a class="headerlink" href="#threat-obtaining-refresh-token-from-authorization-server-database" title="Permalink to this headline">¶</a></h4>
<p>This threat is applicable if the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> stores
<em class="xref std std-ref">refresh tokens</em> as <strong>handles</strong> in a database.
An attacker may obtain refresh tokens from the authorization server&#8217;s database
by gaining access to the database or launching a SQL injection attack.</p>
<p>Impact: disclosure of all refresh tokens</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Credential storage protection - <a class="reference internal" href="#oauth-threat-5-1-4-1"><em>Section 5.1.4.1</em></a></li>
<li>Bind <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a> to <a class="reference internal" href="glossary.html#term-client-id"><em class="xref std std-term">client id</em></a>, if the attacker cannot obtain the
required id and secret - <a class="reference internal" href="#oauth-threat-5-1-5-8"><em>Section 5.1.5.8</em></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-refresh-token-by-online-guessing">
<span id="oauth-threat-4-5-3"></span><h4><a class="toc-backref" href="#id110">4.5.3.  Threat: Obtain refresh token by online guessing</a><a class="headerlink" href="#threat-obtain-refresh-token-by-online-guessing" title="Permalink to this headline">¶</a></h4>
<p>An attacker may try to guess valid <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> values and
send it using the <a class="reference internal" href="glossary.html#term-grant-type"><em class="xref std std-term">grant type</em></a> &#8220;<a class="reference internal" href="oauth.html#term-53"><em class="xref std std-term">refresh_token</em></a>&#8221;
in order to obtain a valid <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.</p>
<p>Impact:
exposure of single refresh token and derivable access tokens.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>For handle-based designs - <a class="reference internal" href="#oauth-threat-5-1-5-11"><em>Section 5.1.5.11</em></a></li>
<li>For assertion-based designs - <a class="reference internal" href="#oauth-threat-5-1-5-9"><em>Section 5.1.5.9</em></a></li>
<li>Bind token to client id, because the attacker would guess the
matching client id, too (see <a class="reference internal" href="#oauth-threat-5-1-5-8"><em>Section 5.1.5.8</em></a>)</li>
<li>Authenticate the client, adds another element the attacker has to
guess (see <a class="reference internal" href="#oauth-threat-5-2-3-4"><em>Section 5.2.3.4</em></a>)</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-obtain-refresh-token-phishing-by-counterfeit-authorization-server">
<span id="oauth-threat-4-5-4"></span><h4><a class="toc-backref" href="#id111">4.5.4.  Threat: Obtain refresh token phishing by counterfeit authorization server</a><a class="headerlink" href="#threat-obtain-refresh-token-phishing-by-counterfeit-authorization-server" title="Permalink to this headline">¶</a></h4>
<p>An attacker could try to obtain valid <a class="reference internal" href="glossary.html#term-refresh-tokens"><em class="xref std std-term">refresh tokens</em></a>
by <strong>proxying requests</strong> to the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
Given the assumption that the authorization server URL is well-known
at development time or
can at least be obtained from a well-known <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>,
the attacker must utilize some kind of spoofing in order to succeed.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Server authentication (as described in <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a> )</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="accessing-protected-resources">
<span id="oauth-threat-4-6"></span><h3><a class="toc-backref" href="#id112">4.6.  Accessing Protected Resources</a><a class="headerlink" href="#accessing-protected-resources" title="Permalink to this headline">¶</a></h3>
<p>Threat list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-4-6-1"><em>4.6.1.  Threat: Eavesdropping access tokens on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-2"><em>4.6.2.  Threat: Replay authorized resource server requests</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-3"><em>4.6.3.  Threat: Guessing access tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-4"><em>4.6.4. Threat: Access token phishing by counterfeit resource server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-5"><em>4.6.5.  Threat: Abuse of token by legitimate resource server or client</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-6"><em>4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div></blockquote>
<img alt="images/4.6.png" src="images/4.6.png" style="width: 600px;" />
<div class="section" id="threat-eavesdropping-access-tokens-on-transport">
<span id="oauth-threat-4-6-1"></span><h4><a class="toc-backref" href="#id113">4.6.1.  Threat: Eavesdropping access tokens on transport</a><a class="headerlink" href="#threat-eavesdropping-access-tokens-on-transport" title="Permalink to this headline">¶</a></h4>
<p>An attacker could try to obtain a valid <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>
on transport between <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> and <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>.
As access tokens are <strong>shared secrets</strong> between <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization</em></a>
and <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>,
they MUST by treated with the same care as other credentials
(e.g. end-user passwords).</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Access tokens sent as <a class="reference internal" href="glossary.html#term-bearer"><em class="xref std std-term">bearer</em></a> tokens, SHOULD NOT be sent
in the clear over an insecure channel.
Instead transport protection means shall be utilized to prevent eavesdropping by an attacker
(see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).</li>
</ul>
<dl class="docutils">
<dt>o  A short lifetime reduces impact in case tokens are compromised</dt>
<dd>(see <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>).</dd>
<dt>o  The access token can be bound to a client&#8217;s identity and</dt>
<dd>require the client to authenticate with the resource server (see
<a class="reference internal" href="#oauth-threat-5-4-2"><em>Section 5.4.2</em></a>).
Client authentication MUST be performed without
exposing the required secret to the transport channel.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-replay-authorized-resource-server-requests">
<span id="oauth-threat-4-6-2"></span><h4><a class="toc-backref" href="#id114">4.6.2.  Threat: Replay authorized resource server requests</a><a class="headerlink" href="#threat-replay-authorized-resource-server-requests" title="Permalink to this headline">¶</a></h4>
<p>An attacker could attempt to replay valid requests
in order to obtain or to modify/destroy user data.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>The <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> should utilize transport security measure in
order to prevent such attacks (see <a class="reference internal" href="#oauth-threat-5-1-1"><em>Section 5.1.1</em></a>).
This would prevent the attacker from capturing valid requests.</li>
</ul>
<dl class="docutils">
<dt>o  Alternatively, the resource server could employ signed requests</dt>
<dd>(see <a class="reference internal" href="#oauth-threat-5-4-3"><em>Section 5.4.3</em></a> ) along with <em class="xref std std-term">nounces</em> and
<em class="xref std std-term">timestamps</em> in order to uniquely identify requests.
The resource server MUST detect and refuse every replayed request.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-guessing-access-tokens">
<span id="oauth-threat-4-6-3"></span><h4><a class="toc-backref" href="#id115">4.6.3.  Threat: Guessing access tokens</a><a class="headerlink" href="#threat-guessing-access-tokens" title="Permalink to this headline">¶</a></h4>
<p>Where the token is a handle,
the attacker may use attempt to guess the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> values
based on knowledge they have from other access tokens.</p>
<p>Impact:
Access to a single user&#8217;s data.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Handle Tokens should have a reasonable <em class="xref std std-term">entropy</em> (see
<a class="reference internal" href="#oauth-threat-5-1-5-11"><em>Section 5.1.5.11</em></a>)
in order to make guessing a valid token value
difficult.</li>
</ul>
<dl class="docutils">
<dt>o  <a class="reference internal" href="oauth_assertion.html#term-assertion"><em class="xref std std-term">Assertion</em></a> (or self-contained token ) tokens contents SHALL be</dt>
<dd>protected by a digital signature (see <a class="reference internal" href="#oauth-threat-5-1-5-9"><em>Section 5.1.5.9</em></a>).</dd>
<dt>o  Security can be further strengthened by using a short access token <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a></dt>
<dd><dl class="first last docutils">
<dt>(see <a class="reference internal" href="#oauth-threat-5-1-5-2"><em>Section 5.1.5.2</em></a>  and</dt>
<dd><a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a> ).</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="threat-access-token-phishing-by-counterfeit-resource-server">
<span id="oauth-threat-4-6-4"></span><h4><a class="toc-backref" href="#id116">4.6.4. Threat: Access token phishing by counterfeit resource server</a><a class="headerlink" href="#threat-access-token-phishing-by-counterfeit-resource-server" title="Permalink to this headline">¶</a></h4>
<p>An attacker may pretend to be a particular <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>
and to accept tokens from a particular <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
If the client sends a valid <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access tokens</em></a> to this counterfeit resource server,
the server in turn may use that token to access other services on behalf of the resource owner.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Clients SHOULD not make authenticated requests with an access token
to unfamiliar resource servers, regardless of the presence of a secure channel.
If the resource server address is well-known to the client, it may authenticate the resource servers
(see <a class="reference internal" href="#oauth-threat-5-1-2"><em>Section 5.1.2</em></a> ).</li>
<li>Associate the endpoint address of the resource server the client talked to with the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>
(e.g. in an <a class="reference internal" href="oauth_assertion.html#term-audience"><em class="xref std std-term">audience</em></a> field) and validate association at legitimate resource server.
The endpoint address validation policy may be strict (exact match) or more relaxed (e.g. same host).
This would require to tell the authorization server the resource server endpoint address in the authorization process.</li>
<li>Associate an access token with a client and authenticate the client with resource server requests
(typically via <strong>signature</strong> in order to not disclose secret to a potential attacker).
This prevents the attack because the counterfeit server is assumed to miss the capabilities
to correctly authenticate on behalf of the legitimate client to the resource server (<a class="reference internal" href="#oauth-threat-5-4-2"><em>Section 5.4.2</em></a>).</li>
<li>Restrict the <em class="xref std std-term">token scope</em> (see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>)
and or limit the token to a certain resource server (<a class="reference internal" href="#oauth-threat-5-1-5-5"><em>Section 5.1.5.5</em></a>).</li>
</ul>
</div></blockquote>
<img alt="images/4.6.4.png" src="images/4.6.4.png" style="width: 600px;" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Refrered by a <a class="reference external" href="http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20111107/001266.html">discussion on a ML thread by initiated by Nat</a></p>
</div>
</div>
<div class="section" id="threat-abuse-of-token-by-legitimate-resource-server-or-client">
<span id="oauth-threat-4-6-5"></span><h4><a class="toc-backref" href="#id117">4.6.5.  Threat: Abuse of token by legitimate resource server or client</a><a class="headerlink" href="#threat-abuse-of-token-by-legitimate-resource-server-or-client" title="Permalink to this headline">¶</a></h4>
<p>A legitimate <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> could attempt to use an access token to
access another resource servers.
Similarly, a <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> could try to use a token obtained
for one server on another resource server.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Tokens should be restricted to particular resource servers (see
<a class="reference internal" href="#oauth-threat-5-1-5-5"><em>Section 5.1.5.5</em></a>).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-leak-of-confidential-data-in-http-proxies">
<span id="oauth-threat-4-6-6"></span><h4><a class="toc-backref" href="#id118">4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</a><a class="headerlink" href="#threat-leak-of-confidential-data-in-http-proxies" title="Permalink to this headline">¶</a></h4>
<p>The HTTP Authorization scheme (OAuth HTTP Authorization Scheme) is optional.
However, [RFC2616](Fielding, R., Gettys, J., Mogul, J.,
Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &#8220;Hypertext
Transfer Protocol &#8211; HTTP/1.1,&#8221; .)
relies on the <a class="reference internal" href="glossary.html#term-authorization-header"><em class="xref std std-term">Authorization</em></a> and
<em class="xref std std-term">WWW-Authenticate headers</em>
to distinguish authenticated content
so that it can be protected.</p>
<p>Proxies and caches, in particular, may fail to adequately protect requests
not using these headers.
For example, private authenticated content may be stored in
(and thus retrievable from) publicly-accessible caches.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Resource servers not using the HTTP Authorization scheme (OAuth
HTTP Authorization Scheme - see <a class="reference internal" href="#oauth-threat-5-4-1"><em>Section 5.4.1</em></a>)
should take care to
use other mechanisms, such as the <em class="xref std std-term">Cache-Control</em> header, to ensure
that authenticated content is protected.</li>
<li>Reducing <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> (see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a> )
and <em class="xref std std-term">expiry time</em> (<a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>)
for access tokens can be used to reduce the damage in case of leaks.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="threat-token-leakage-via-logfiles-and-http-referrers">
<span id="oauth-threat-4-6-7"></span><h4><a class="toc-backref" href="#id119">4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</a><a class="headerlink" href="#threat-token-leakage-via-logfiles-and-http-referrers" title="Permalink to this headline">¶</a></h4>
<p>If <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> are sent via <a class="reference internal" href="glossary.html#term-uri-query-parameters"><em class="xref std std-term">URI query parameters</em></a>,
such tokens may leak to log files and <em class="xref std std-term">HTTP referrers</em>.</p>
<p>Countermeasures:</p>
<blockquote>
<div><ul class="simple">
<li>Use <a class="reference internal" href="glossary.html#term-authorization-headers"><em class="xref std std-term">authorization headers</em></a> or POST parameters instead of URI
request parameters (see <a class="reference internal" href="#oauth-threat-5-4-1"><em>Section 5.4.1</em></a>).</li>
<li>Set logging configuration appropriately</li>
<li>Prevent unauthorized persons from access to system log files
(see <a class="reference internal" href="#oauth-threat-5-1-4-1-1"><em>Section 5.1.4.1.1</em></a> )</li>
<li>HTTP referrers can be prevented by reloading the target page again
without URI parameters</li>
<li>Abuse of leaked access tokens can be prevented by enforcing
authenticated requests (see <a class="reference internal" href="#oauth-threat-5-4-2"><em>Section 5.4.2</em></a>).</li>
<li>The impact of token leakage may be reduced by limiting <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a>
(see <a class="reference internal" href="#oauth-threat-5-1-5-1"><em>Section 5.1.5.1</em></a>)
and <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a> (see <a class="reference internal" href="#oauth-threat-5-1-5-3"><em>Section 5.1.5.3</em></a>)
and enforcing <strong>one time token</strong> usage (see <a class="reference internal" href="#oauth-threat-5-1-5-4"><em>Section 5.1.5.4</em></a>).</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="security-considerations">
<span id="oauth-threat-5"></span><h2><a class="toc-backref" href="#id120">5.  Security Considerations</a><a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h2>
<p>This section describes
the <strong>countermeasures</strong> as recommended to mitigate the threats
as described in <a class="reference internal" href="#oauth-threat-4"><em>Section 4</em></a>.</p>
<div class="section" id="general">
<span id="oauth-threat-5-1"></span><h3><a class="toc-backref" href="#id121">5.1.  General</a><a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<p>The general section covers consideratios that apply generally across all OAuth components
(<a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>, <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>, <em class="xref std std-term">token server</em>, and user-agents).</p>
<div class="section" id="confidentiality-of-requests">
<span id="oauth-threat-5-1-1"></span><h4><a class="toc-backref" href="#id122">5.1.1.  Confidentiality of Requests</a><a class="headerlink" href="#confidentiality-of-requests" title="Permalink to this headline">¶</a></h4>
<p>This is applicable to all requests sent
from <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> to <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> or <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>.</p>
<p>While OAuth provides a mechanism for verifying the <strong>integrity</strong> of requests,
it provides no guarantee of request <strong>confidentiality</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No request confidentiality by OAuth</p>
</div>
<p>Unless further precautions are taken,
eavesdroppers will have full access to request content and
may be able to mount interception
or replay attacks through using content of request, e.g. secrets or tokens.</p>
<p>Attacks can be mitigated by using transport-layer mechanisms
such as <a class="reference internal" href="glossary.html#term-tls"><em class="xref std std-term">TLS</em></a> or <a class="reference internal" href="glossary.html#term-ssl"><em class="xref std std-term">SSL</em></a>.
VPN may considered as well.</p>
<p>This is a countermeasure against the following threats:</p>
<blockquote>
<div><p>o  Replay of access tokens obtained on tokens endpoint or resource server&#8217;s endpoint</p>
<p>o  Replay of refresh tokens obtained on tokens endpoint</p>
<p>o  Replay of authorization codes obtained on tokens endpoint (redirect?)</p>
<p>o  Replay of user passwords and client secrets</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-1"><em>4.3.1.  Threat: Eavesdropping access tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2"><em>4.4.2.  Implicit Grant</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3"><em>4.4.3.  Resource Owner Password Credentials</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-4"><em>4.4.2.4.  Threat: Manipulation of scripts</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-4"><em>4.4.3.4.  Threat: Obtain user passwords on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-1"><em>4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-1"><em>4.6.1.  Threat: Eavesdropping access tokens on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-2"><em>4.6.2.  Threat: Replay authorized resource server requests</em></a></li>
</ul>
</div>
</div>
<div class="section" id="server-authentication">
<span id="oauth-threat-5-1-2"></span><h4><a class="toc-backref" href="#id123">5.1.2.  Server authentication</a><a class="headerlink" href="#server-authentication" title="Permalink to this headline">¶</a></h4>
<p>HTTPS server authentication or similar means can be used to authenticate the identity of a server.
The goal is to reliably bind the DNS name of the server
to the public key presented by the server during connection establishment.</p>
<p>The client MUST validate the binding of the server to its domain name.
If the server fails to prove that binding,
it is condered a <em class="xref std std-term">men-in-the-middle</em>.
The security measure depends on the certification authorities the client trusts for that purpose.
Clients should carefully select those trusted CAs
and protect the storage for trusted CA certificates from modifications.</p>
<p>This is a countermeasure against the following threats:</p>
<blockquote>
<div><ul class="simple">
<li><em class="xref std std-term">Spoofing</em></li>
<li><em class="xref std std-term">Proxying</em></li>
<li><a class="reference internal" href="glossary.html#term-phishing"><em class="xref std std-term">Phishing</em></a> by conterfeit servers</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-2-1"><em>4.2.1.  Threat: Password phishing by counterfeit authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-5"><em>4.4.1.5.  Threat: Authorization code phishing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-6"><em>4.4.1.6.  Threat: User session impersonation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-4"><em>4.4.2.4.  Threat: Manipulation of scripts</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-4"><em>4.5.4.  Threat: Obtain refresh token phishing by counterfeit authorization server</em></a></li>
</ul>
</div>
</div>
<div class="section" id="always-keep-the-resource-owner-informed">
<span id="oauth-threat-5-1-3"></span><h4><a class="toc-backref" href="#id124">5.1.3.  Always keep the resource owner informed</a><a class="headerlink" href="#always-keep-the-resource-owner-informed" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">User is intelligent device.</p>
</div>
<p>Transparency to the <a class="reference internal" href="oauth.html#term-resource-owner"><em class="xref std std-term">resource owner</em></a> is a key element of the OAuth protocol.
The user shall always be in control of the authorization processes and
get the necessary information to meet informed decisions.
Moreover,
user involvement is a further security countermeasure.
The user can probably recognize certain kinds of attacks better
than the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
Information can be presented/exchanged during the authorization process,
after the authorization process,
and every time the user wishes to get informed by using techniques such as:</p>
<blockquote>
<div><ul class="simple">
<li>User consent forms</li>
<li>Notification messages (e-Mail, SMS, ...)</li>
<li>Activity/Event logs</li>
<li>User self-care applications or portals</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-2"><em>4.4.3.2.  Threat: Client obtains scopes without end-user authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-3"><em>4.4.3.3.  Threat: Client obtains refresh token through automatic authorization</em></a></li>
</ul>
</div>
</div>
<div class="section" id="credentials">
<span id="oauth-threat-5-1-4"></span><h4><a class="toc-backref" href="#id125">5.1.4.  Credentials</a><a class="headerlink" href="#credentials" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Credential:</p>
<blockquote class="last">
<div><ul>
<li><p class="first"><a class="reference internal" href="glossary.html#term-206"><em class="xref std std-term">client secret</em></a></p>
</li>
<li><p class="first"><em class="xref std std-term">user password</em></p>
</li>
<li><p class="first"><a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a></p>
<blockquote>
<div><ul class="simple">
<li><em class="xref std std-term">reflesh token</em></li>
<li><em class="xref std std-term">acess token</em></li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a></p>
</li>
</ul>
</div></blockquote>
</div>
<p>This sections describes countermeasures used to protect all kinds of <em class="xref std std-term">credentials</em>
from unauthorized access and abuse.
Credentials are <strong>long term secrets</strong>, such as <a class="reference internal" href="glossary.html#term-client-secrets"><em class="xref std std-term">client secrets</em></a> and <em class="xref std std-term">user passwords</em>
as well as all kinds of <a class="reference internal" href="glossary.html#term-tokens"><em class="xref std std-term">tokens</em></a>
(refresh and access token) or <em class="xref std std-term">authorization codes</em>.</p>
<p>Protections:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-1-4-1"><em>5.1.4.1.  Credential Storage Protection</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-2"><em>5.1.4.2.  Online attacks on secrets</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="credential-storage-protection">
<span id="oauth-threat-5-1-4-1"></span><h5><a class="toc-backref" href="#id126">5.1.4.1.  Credential Storage Protection</a><a class="headerlink" href="#credential-storage-protection" title="Permalink to this headline">¶</a></h5>
<p>Administrators should undertake industry best practices
to protect the <strong>storage of credentials</strong>.</p>
<p>Such practices may include but are not limited to the following sub-sections.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-2"><em>4.4.1.2.  Threat: Obtain authorization codes from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-5"><em>4.4.3.5.  Threat: Obtain user passwords from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-2"><em>4.5.2.  Threat: Obtaining refresh token from authorization server database</em></a></li>
</ul>
</div>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-1-4-1-1"><em>5.1.4.1.1.  Standard System Security Means</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-1-2"><em>5.1.4.1.2.  Standard SQL Injection Countermeasures</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-1-3"><em>5.1.4.1.3.  No cleartext storage of credentials</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-1-4"><em>5.1.4.1.4.  Encryption of credentials</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-1-5"><em>5.1.4.1.5.  Use of asymmetric cryptography</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="standard-system-security-means">
<span id="oauth-threat-5-1-4-1-1"></span><h6><a class="toc-backref" href="#id127">5.1.4.1.1.  Standard System Security Means</a><a class="headerlink" href="#standard-system-security-means" title="Permalink to this headline">¶</a></h6>
<p>A server system may be <strong>locked down</strong>
so that no attacker may get access to sensible configuration files and databases.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-2"><em>4.3.2.  Threat: Obtain access tokens from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-2"><em>4.4.1.2.  Threat: Obtain authorization codes from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
</div>
<div class="section" id="standard-sql-injection-countermeasures">
<span id="oauth-threat-5-1-4-1-2"></span><h6><a class="toc-backref" href="#id128">5.1.4.1.2.  Standard <em class="xref std std-term">SQL Injection</em> Countermeasures</a><a class="headerlink" href="#standard-sql-injection-countermeasures" title="Permalink to this headline">¶</a></h6>
<p>If a <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client identifier</em></a> or
other authentication component is queried or compared
against a SQL Database it may become possible for an <em class="xref std std-term">injection</em> attack to occur
if parameters received are not validated before submission to the database.</p>
<blockquote>
<div><ul class="simple">
<li>Ensure that server code is using the <strong>minimum database privileges</strong>
possible to reduce the &#8220;surface&#8221; of possible attacks.</li>
<li><strong>Avoid dynamic SQL</strong> using concatenated input.
If possible, use static SQL.</li>
<li>When using dynamic SQL, parameterize queries using <strong>bind arguments</strong>.
Bind arguments eliminate possibility of SQL injections.</li>
<li><strong>Filter and sanitize</strong> the input.
For example, if an identifier has a known format,
ensure that the supplied value matches the identifier syntax rules.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-2"><em>4.3.2.  Threat: Obtain access tokens from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-2"><em>4.4.1.2.  Threat: Obtain authorization codes from authorization server database</em></a></li>
</ul>
</div>
</div>
<div class="section" id="no-cleartext-storage-of-credentials">
<span id="oauth-threat-5-1-4-1-3"></span><h6><a class="toc-backref" href="#id129">5.1.4.1.3.  No cleartext storage of credentials</a><a class="headerlink" href="#no-cleartext-storage-of-credentials" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No Cleartext. But Hashed.</p>
</div>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may consider to not store credential in clear text.
Typical approaches are to store hashes instead.
If the credential lacks a reasonable entropy level
(because it is a user password) an additional salt will harden the storage
to prevent offline <em class="xref std std-term">dictionary attacks</em>.</p>
<p>Note:
Some authentication protocols require the authorization server
to have access to the secret in the clear.
Those protocols cannot be implemented if the server only has access to hashes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-2"><em>4.3.2.  Threat: Obtain access tokens from authorization server database</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-2"><em>4.4.1.2.  Threat: Obtain authorization codes from authorization server database</em></a></li>
</ul>
</div>
</div>
<div class="section" id="encryption-of-credentials">
<span id="oauth-threat-5-1-4-1-4"></span><h6><a class="toc-backref" href="#id130">5.1.4.1.4.  Encryption of credentials</a><a class="headerlink" href="#encryption-of-credentials" title="Permalink to this headline">¶</a></h6>
<p>For <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> applications,
insecurely persisted client credentials are easy targets for attackers to obtain.
Store client credentials using an encrypted persistence mechanism
such as a <em class="xref std std-term">keystore</em> or database.</p>
<p>Note that compiling client credentials directly into client code
makes client applications vulnerable to scanning
as well as difficult to administer should client credentials change over time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">DON&#8217;T embed credentioas into programme code.</p>
</div>
</div>
<div class="section" id="use-of-asymmetric-cryptography">
<span id="oauth-threat-5-1-4-1-5"></span><h6><a class="toc-backref" href="#id131">5.1.4.1.5.  Use of asymmetric cryptography</a><a class="headerlink" href="#use-of-asymmetric-cryptography" title="Permalink to this headline">¶</a></h6>
<p>Usage of <em class="xref std std-term">asymmetric cryptography</em> will free the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
of the obligation to manage credentials.
Nevertheless, it MUST ensure the <a class="reference internal" href="glossary.html#term-integrity"><em class="xref std std-term">integrity</em></a> of the respective public keys.</p>
</div>
</div>
<div class="section" id="online-attacks-on-secrets">
<span id="oauth-threat-5-1-4-2"></span><h5><a class="toc-backref" href="#id132">5.1.4.2.  Online attacks on secrets</a><a class="headerlink" href="#online-attacks-on-secrets" title="Permalink to this headline">¶</a></h5>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-1-4-2-1"><em>5.1.4.2.1.  Password policy</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-2-2"><em>5.1.4.2.2.  High entropy of secrets</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-2-3"><em>5.1.4.2.3.  Lock accounts</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-2-4"><em>5.1.4.2.4.  Tar pit</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-4-2-5"><em>5.1.4.2.5.  Usage of CAPTCHAs</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="password-policy">
<span id="oauth-threat-5-1-4-2-1"></span><h6><a class="toc-backref" href="#id133">5.1.4.2.1.  Password policy</a><a class="headerlink" href="#password-policy" title="Permalink to this headline">¶</a></h6>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may decide to enforce a <strong>complex user password policy</strong>
in order to increase the user passwords&#8217; entropy.</p>
<p>This will hinder online password attacks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-6"><em>4.4.3.6.  Threat: Online guessing</em></a></li>
</ul>
</div>
</div>
<div class="section" id="high-entropy-of-secrets">
<span id="oauth-threat-5-1-4-2-2"></span><h6><a class="toc-backref" href="#id134">5.1.4.2.2.  High entropy of secrets</a><a class="headerlink" href="#high-entropy-of-secrets" title="Permalink to this headline">¶</a></h6>
<p>When creating token handles or other secrets not intended for usage by human users,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST include a reasonable level of entropy
in order to mitigate the risk of guessing attacks.</p>
<p>The token value MUST be constructed from a cryptographically strong random or
pseudo-random number sequence [RFC1750] generated by the Authorization Server.</p>
<p>The probability of any two <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">Authorization Code</em></a> values being identical
MUST be less than or equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-5"><em>4.3.5.  Threat: Obtain client secret by online guessing</em></a></li>
</ul>
</div>
</div>
<div class="section" id="lock-accounts">
<span id="oauth-threat-5-1-4-2-3"></span><h6><a class="toc-backref" href="#id135">5.1.4.2.3.  Lock accounts</a><a class="headerlink" href="#lock-accounts" title="Permalink to this headline">¶</a></h6>
<p>Online attacks on passwords can be mitigated
by locking the respective accounts
after a certain number of failed attempts.</p>
<p>Note:
This measure can be abused to lock down legitimate service users.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-5"><em>4.3.5.  Threat: Obtain client secret by online guessing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-6"><em>4.4.3.6.  Threat: Online guessing</em></a></li>
</ul>
</div>
</div>
<div class="section" id="tar-pit">
<span id="oauth-threat-5-1-4-2-4"></span><h6><a class="toc-backref" href="#id136">5.1.4.2.4.  Tar pit</a><a class="headerlink" href="#tar-pit" title="Permalink to this headline">¶</a></h6>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may react on failed attempts to authenticate
by username/password by temporarily locking the respective account
and delaying the response for a certain duration.</p>
<p>This duration may increase with the number of failed attempts.
The objective is to slow the attackers attempts on a certain username down.</p>
<p>Note:
this may require a more complex and stateful design of the authorization server.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-6"><em>4.4.3.6.  Threat: Online guessing</em></a></li>
<li>&#8220;An accumulation of natural tar or asphalt at the earth&#8217;s surface,
especially one that traps animals and preserves their bones. &#8221;,
<a class="reference external" href="http://www.thefreedictionary.com/tar+pit">tar pit(TheFreeDictional) -</a></li>
</ul>
</div>
</div>
<div class="section" id="usage-of-captchas">
<span id="oauth-threat-5-1-4-2-5"></span><h6><a class="toc-backref" href="#id137">5.1.4.2.5.  Usage of CAPTCHAs</a><a class="headerlink" href="#usage-of-captchas" title="Permalink to this headline">¶</a></h6>
<p>The idea is to prevent programs from automatically checking huge
number of passwords by requiring human interaction.</p>
<p>Note:
this has a negative impact on user experience.</p>
</div>
</div>
</div>
<div class="section" id="tokens-access-refresh-code">
<span id="oauth-threat-5-1-5"></span><h4><a class="toc-backref" href="#id138">5.1.5.  Tokens (access, refresh, code)</a><a class="headerlink" href="#tokens-access-refresh-code" title="Permalink to this headline">¶</a></h4>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-1-5-1"><em>5.1.5.1.  Limit token scope</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-2"><em>5.1.5.2.  Expiration time</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-3"><em>5.1.5.3.  Short expiration time</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-4"><em>5.1.5.4.  Limit number of usages/ One time usage</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-5"><em>5.1.5.5.  Bind tokens to a particular resource server (Audience)</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-6"><em>5.1.5.6.  Use endpoint address as token audience</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-7"><em>5.1.5.7.  Audience and Token scopes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-8"><em>5.1.5.8.  Bind token to client id</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-9"><em>5.1.5.9.  Signed tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-10"><em>5.1.5.10.  Encryption of token content</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-11"><em>5.1.5.11.  Random token value with high entropy</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-1-5-12"><em>5.1.5.12.  Assertion formats</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="limit-token-scope">
<span id="oauth-threat-5-1-5-1"></span><h5><a class="toc-backref" href="#id139">5.1.5.1.  Limit token scope</a><a class="headerlink" href="#limit-token-scope" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may decide to reduce or limit
the <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> associated with a <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a>.</p>
<p>Basis of this decision is out of scope, examples are:</p>
<blockquote>
<div><ul class="simple">
<li>a client-specific policy,
e.g. issue only less powerful tokens to unauthenticated clients,</li>
<li>service-specific policy,
e.g. it a very sensible service,</li>
<li>resource-owner specific setting, or</li>
<li>combinations of such policies and preferences.</li>
</ul>
</div></blockquote>
<p>The authorization server may allow different scopes dependent on the grant type.
For example,
end-user authorization via direct interaction with the end-user (authorization code) might be considered
more reliable than direct authorization via gran type username/password.
This means will reduce the impact of the following threats:</p>
<blockquote>
<div><ul class="simple">
<li>token leakage</li>
<li>token issuance to malicious software</li>
<li>unintended issuance of to powerful tokens with resource owner credentials flow</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-2-2"><em>4.2.2.  Threat: User unintentionally grants too much access scope</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-2-3"><em>4.2.3.  Threat: Malicious client obtains existing authorization by fraud</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-3-1"><em>4.3.1.  Threat: Eavesdropping access tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-2"><em>4.4.2.2.  Threat: Access token leak in browser history</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-3-2"><em>4.4.3.2.  Threat: Client obtains scopes without end-user authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-1"><em>4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-6"><em>4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
<img alt="images/5.1.5.1.png" src="images/5.1.5.1.png" style="width: 600px;" />
</div>
<div class="section" id="expiration-time">
<span id="oauth-threat-5-1-5-2"></span><h5><a class="toc-backref" href="#id140">5.1.5.2.  Expiration time</a><a class="headerlink" href="#expiration-time" title="Permalink to this headline">¶</a></h5>
<p>Tokens should generally expire after a reasonable <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a>.
This complements and strengthens other security measures
(such as signatures) and reduces the impact of all kinds of token leaks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-6-3"><em>4.6.3.  Threat: Guessing access tokens</em></a></li>
</ul>
</div>
</div>
<div class="section" id="short-expiration-time">
<span id="oauth-threat-5-1-5-3"></span><h5><a class="toc-backref" href="#id141">5.1.5.3.  Short expiration time</a><a class="headerlink" href="#short-expiration-time" title="Permalink to this headline">¶</a></h5>
<p>A short <em class="xref std std-term">expiration time</em> for tokens is a protection means against the following threats:</p>
<blockquote>
<div><p>o  replay</p>
<p>o  reduce impact of token leak</p>
<p>o  reduce likelihood of successful online guessing</p>
</div></blockquote>
<p>Note:</p>
<p>Short <em class="xref std std-term">token duration</em> requires preciser clock synchronisation
between authorization server and resource server.
Furthermore, shorter duration may require more token refreshments (<a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>)
or repeated end-user authorization processes (<a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> and <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-1"><em>4.3.1.  Threat: Eavesdropping access tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-3"><em>4.4.1.3.  Threat: Online guessing of authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-2-2"><em>4.4.2.2.  Threat: Access token leak in browser history</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-1"><em>4.5.1.  Threat: Eavesdropping refresh tokens from authorization server</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-1"><em>4.6.1.  Threat: Eavesdropping access tokens on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-6"><em>4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
</div>
<div class="section" id="limit-number-of-usages-one-time-usage">
<span id="oauth-threat-5-1-5-4"></span><h5><a class="toc-backref" href="#id142">5.1.5.4.  Limit number of usages/ One time usage</a><a class="headerlink" href="#limit-number-of-usages-one-time-usage" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may restrict the number of requests or
operations which can be performed with a certain token.
This mechanism can be used to mitigate the following threats:</p>
<blockquote>
<div><ul class="simple">
<li>replay of tokens</li>
<li>reduce likelihood of successful online guessing</li>
</ul>
</div></blockquote>
<p>For example,
if an Authorization Server observes more than one attempt to redeem <a class="footnote-reference" href="#id24" id="id23">[10]</a>  a <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>,
the Authorization Server MAY want to revoke all <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access tokens</em></a> granted
based on the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> as well as reject the current request.</p>
<p>As with the authorization code,
access tokens MAY also have a limited number of operations.
This forces client applications to either re-authenticate and
use a <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> to obtain a fresh access token,
or it forces the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> to re-authorize the access token by involving the user.</p>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[10]</a></td><td>To turn in (coupons, for example) and receive something in exchange.  (<a class="reference external" href="http://www.thefreedictionary.com/redeem">TheFreeDictionary</a> )</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="bind-tokens-to-a-particular-resource-server-audience">
<span id="oauth-threat-5-1-5-5"></span><h4><a class="toc-backref" href="#id143">5.1.5.5.  Bind tokens to a particular resource server (Audience)</a><a class="headerlink" href="#bind-tokens-to-a-particular-resource-server-audience" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="glossary.html#term-authorization-servers"><em class="xref std std-term">Authorization servers</em></a> in multi-service environments
may consider to issue tokens with different content to different resource servers and
to explicitely indicate in the token the target server
a token is intended to be sent to (cf. Audience in SAML Assertions).
This countermeasure can be used in the following situations:</p>
<blockquote>
<div><ul class="simple">
<li>It reduce the impact of a successful replay attempt,
since the token is applicable to a single resource server, only.</li>
<li>prevents abuse of a token by a rough resource server or client,
since the token can only be used on that server.
It is rejected by other servers.</li>
<li>It reduce the impact of a leakage of a valid token to a conterfeit resource server.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-6-5"><em>4.6.5.  Threat: Abuse of token by legitimate resource server or client</em></a></li>
</ul>
</div>
<img alt="images/5.1.5.5.png" src="images/5.1.5.5.png" style="width: 600px;" />
<div class="section" id="use-endpoint-address-as-token-audience">
<span id="oauth-threat-5-1-5-6"></span><h5><a class="toc-backref" href="#id144">5.1.5.6.  Use endpoint address as token audience</a><a class="headerlink" href="#use-endpoint-address-as-token-audience" title="Permalink to this headline">¶</a></h5>
<p>This may be used to indicate to a <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>,
which endpoint address has been used to obtain the <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a>.</p>
<p>This measure will allow to detect requests from a counterfeit resource server,
since such token will contain the endpoint address of that server.</p>
</div>
<div class="section" id="audience-and-token-scopes">
<span id="oauth-threat-5-1-5-7"></span><h5><a class="toc-backref" href="#id145">5.1.5.7.  Audience and Token scopes</a><a class="headerlink" href="#audience-and-token-scopes" title="Permalink to this headline">¶</a></h5>
<p>Deployments may consider to use only tokens with explicitly defined <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a>,
where every <a class="reference internal" href="uma_core.html#term-scope"><em class="xref std std-term">scope</em></a> is associated with a particular <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a>.</p>
<p>This approach can be used to mitigate attacks,
where a <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> or <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> uses a <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a>
for a different then the intended purpose.</p>
</div>
<div class="section" id="bind-token-to-client-id">
<span id="oauth-threat-5-1-5-8"></span><h5><a class="toc-backref" href="#id146">5.1.5.8.  Bind token to client id</a><a class="headerlink" href="#bind-token-to-client-id" title="Permalink to this headline">¶</a></h5>
<p>An <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may bind a <a class="reference internal" href="standard.html#term-token"><em class="xref std std-term">token</em></a> to a certain <em class="xref std std-term">client identity</em>.
This identity match must be validated for every request with that token.
This means can be used, to</p>
<blockquote>
<div><ul class="simple">
<li>detect token leakage and</li>
<li>prevent token abuse.</li>
</ul>
</div></blockquote>
<p>Note:
Validating the client identity may require the target server to
authenticate the client&#8217;s identity.  This authentication can be based
on secrets managed independent of the token (e.g. pre-registered
client id/secret on authorization server) or sent with the token
itself (e.g. as part of the encrypted token content).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-5-3"><em>4.5.3.  Threat: Obtain refresh token by online guessing</em></a></li>
</ul>
</div>
</div>
<div class="section" id="signed-tokens">
<span id="oauth-threat-5-1-5-9"></span><h5><a class="toc-backref" href="#id147">5.1.5.9.  Signed tokens</a><a class="headerlink" href="#signed-tokens" title="Permalink to this headline">¶</a></h5>
<p>Self-contained tokens SHOULD be signed in order to detect any attempt to modify or produce faked tokens.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-3"><em>4.4.1.3.  Threat: Online guessing of authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-3"><em>4.5.3.  Threat: Obtain refresh token by online guessing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-3"><em>4.6.3.  Threat: Guessing access tokens</em></a></li>
</ul>
</div>
</div>
<div class="section" id="encryption-of-token-content">
<span id="oauth-threat-5-1-5-10"></span><h5><a class="toc-backref" href="#id148">5.1.5.10.  Encryption of token content</a><a class="headerlink" href="#encryption-of-token-content" title="Permalink to this headline">¶</a></h5>
<p>Self-contained may be <strong>encrypted</strong> for privacy reasons or
to protect system internal data.</p>
</div>
<div class="section" id="random-token-value-with-high-entropy">
<span id="oauth-threat-5-1-5-11"></span><h5><a class="toc-backref" href="#id149">5.1.5.11.  Random token value with high entropy</a><a class="headerlink" href="#random-token-value-with-high-entropy" title="Permalink to this headline">¶</a></h5>
<p>When creating token handles,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST include a reasonable level of <em class="xref std std-term">entropy</em>
in order to mitigate the risk of guessing attacks.</p>
<p>The token value MUST be constructed from a cryptographically strong random
or pseudo-random number sequence [RFC1750] generated by the Authorization Server.</p>
<p>The probability of any two token values being identical MUST be less than or
equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-3"><em>4.4.1.3.  Threat: Online guessing of authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-3"><em>4.5.3.  Threat: Obtain refresh token by online guessing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-3"><em>4.6.3.  Threat: Guessing access tokens</em></a></li>
</ul>
</div>
</div>
<div class="section" id="assertion-formats">
<span id="oauth-threat-5-1-5-12"></span><h5><a class="toc-backref" href="#id150">5.1.5.12.  Assertion formats</a><a class="headerlink" href="#assertion-formats" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Standard assertion format:</p>
<blockquote class="last">
<div><ul class="simple">
<li><em class="xref std std-term">SAML</em></li>
<li><a class="reference internal" href="standard.html#term-jwt"><em class="xref std std-term">JWT</em></a></li>
</ul>
</div></blockquote>
</div>
<p>For service providers intending to implement an assertion-based token design
it is highly recommended to adopt a standard <a class="reference internal" href="oauth_assertion.html#term-assertion"><em class="xref std std-term">assertion</em></a> format
(such as <em class="xref std std-term">SAML</em> or <a class="reference internal" href="standard.html#term-jwt"><em class="xref std std-term">JWT</em></a>) that implements [draft-ietf-oauth-assertions].</p>
</div>
</div>
<div class="section" id="access-tokens">
<span id="oauth-threat-5-1-6"></span><h4><a class="toc-backref" href="#id151">5.1.6.  Access tokens</a><a class="headerlink" href="#access-tokens" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>keep them in transient memory (accessible by the client application only)   <a class="footnote-reference" href="#id27" id="id25">[11]</a></li>
<li>protect from exposure to 3rd parties (malicious application)</li>
<li>limit number of access tokens granted to a user <a class="footnote-reference" href="#id28" id="id26">[12]</a></li>
</ul>
</div></blockquote>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[11]</a></td><td>When logging must be required ?  Logging server can be separated in network not exposed to outside.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[12]</a></td><td>Number of  tokens for the set of Authz Server, Resource Server and End-User ? Or token itself?</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="authorization-server">
<span id="oauth-threat-5-2"></span><h3><a class="toc-backref" href="#id152">5.2.  Authorization Server</a><a class="headerlink" href="#authorization-server" title="Permalink to this headline">¶</a></h3>
<p>This section describes considerations related to the <tt class="xref doc docutils literal"><span class="pre">OAuth</span></tt>
<a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">Authorization Server</em></a> end-point.</p>
<p>Endpoints:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-2-1"><em>5.2.1.  Authorization Codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2"><em>5.2.2.  Refresh tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3"><em>5.2.3.  Public client authentication and authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-4"><em>5.2.4.  End-user authorization</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="authorization-codes">
<span id="oauth-threat-5-2-1"></span><h4><a class="toc-backref" href="#id153">5.2.1.  Authorization Codes</a><a class="headerlink" href="#authorization-codes" title="Permalink to this headline">¶</a></h4>
<div class="section" id="automatic-revocation-of-derived-tokens-if-abuse-is-detected">
<span id="oauth-threat-5-2-1-1"></span><h5><a class="toc-backref" href="#id154">5.2.1.1.  Automatic revocation of derived tokens if abuse is detected</a><a class="headerlink" href="#automatic-revocation-of-derived-tokens-if-abuse-is-detected" title="Permalink to this headline">¶</a></h5>
<p>If an <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">Authorization Server</em></a> observes multiple attempts
to redeem an <a class="reference internal" href="oauth.html#term-authorization-grant"><em class="xref std std-term">authorization grant</em></a> (e.g. such as an <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>),
the Authorization Server may want to revoke all tokens granted
based on the authorization grant.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="refresh-tokens">
<span id="oauth-threat-5-2-2"></span><h4><a class="toc-backref" href="#id155">5.2.2.  Refresh tokens</a><a class="headerlink" href="#refresh-tokens" title="Permalink to this headline">¶</a></h4>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-2-2-1"><em>5.2.2.1.  Restricted issuance of refresh tokens</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2-2"><em>5.2.2.2.  Binding of refresh token to client_id</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2-3"><em>5.2.2.3. Refresh Token Rotation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2-4"><em>5.2.2.4.  Refresh Token Revocation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2-5"><em>5.2.2.5.  Device identification</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-2-6"><em>5.2.2.6.  X-FRAME-OPTION header</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="restricted-issuance-of-refresh-tokens">
<span id="oauth-threat-5-2-2-1"></span><h5><a class="toc-backref" href="#id156">5.2.2.1.  Restricted issuance of refresh tokens</a><a class="headerlink" href="#restricted-issuance-of-refresh-tokens" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Authorization server doesn&#8217;t have to issue a refresh token while issuing an access token.</p>
</div>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may decide based on an appropriate <strong>policy</strong> not to issue <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh tokens</em></a>.
Since refresh tokens are <strong>long term credentials</strong>, they may be subject theft.
For example,
if the authorization server does not trust a client to securely store such tokens,
it may refuse to issue such a client a refresh token.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-3"><em>4.4.3.3.  Threat: Client obtains refresh token through automatic authorization</em></a></li>
</ul>
</div>
</div>
<div class="section" id="binding-of-refresh-token-to-client-id">
<span id="oauth-threat-5-2-2-2"></span><h5><a class="toc-backref" href="#id157">5.2.2.2.  Binding of refresh token to client_id</a><a class="headerlink" href="#binding-of-refresh-token-to-client-id" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST bind every <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a>
to <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">the id of the client</em></a>
such a token was originally issued to and validate this binding for every request to refresh that token.
This measure is a countermeasure against refresh token theft or leakage.</p>
<p>Note: This binding MUST be protected from unauthorized modifications.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3"><em>4.4.3.  Resource Owner Password Credentials</em></a></li>
</ul>
</div>
</div>
<div class="section" id="refresh-token-rotation">
<span id="oauth-threat-5-2-2-3"></span><h5><a class="toc-backref" href="#id158">5.2.2.3. Refresh Token Rotation</a><a class="headerlink" href="#refresh-token-rotation" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Return new refresh token when client refreshes access token.</p>
</div>
<p><a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">Refresh token</em></a> rotation is intended to automatically detect
and prevent attempts to use the same refresh token in parallel
from different apps/devices.</p>
<p>This happens if a token gets stolen from the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>
and is subsequently used by the attacker and the legitimate client.</p>
<p>The basic idea is to change the refresh token value with every refresh request
in order to detect attempts to obtain <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access tokens</em></a> using old refresh tokens.
Since the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> cannot determine
whether the attacker or the legitimate client is trying to access,
in case of such an access attempt the valid refresh token and the access authorization
associated with it are both revoked.</p>
<p>The <a class="reference internal" href="oauth.html"><em>OAuth specification</em></a> supports this measure
in that the tokens response allows the authorization server
to return a new refresh token even for requests with grant type &#8220;refresh_token&#8221;.</p>
<p>Note:
this measure may cause problems in clustered environments
since usage of the currently valid refresh token must be ensured.
In such an environment, other measures might be more appropriate.</p>
</div>
<div class="section" id="refresh-token-revocation">
<span id="oauth-threat-5-2-2-4"></span><h5><a class="toc-backref" href="#id159">5.2.2.4.  Refresh Token Revocation</a><a class="headerlink" href="#refresh-token-revocation" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may allow
clients or end-users to explicitly request the invalidation of refresh tokens.</p>
<p>This is a countermeasure against:</p>
<blockquote>
<div><ul class="simple">
<li>device theft,</li>
<li>impersonation of <a class="reference internal" href="oauth.html#term-resource-owner"><em class="xref std std-term">resource owner</em></a>, or</li>
<li>suspected compromised client applications.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="device-identification">
<span id="oauth-threat-5-2-2-5"></span><h5><a class="toc-backref" href="#id160">5.2.2.5.  Device identification</a><a class="headerlink" href="#device-identification" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may require to bind authentication credentials
to a <em class="xref std std-term">device identifier</em> or token assigned to that device.</p>
<p>As the <a class="reference internal" href="glossary.html#term-imei"><em class="xref std std-term">IMEI</em></a> can be spoofed, that is not suitable,
For mobile phones, a registration process can be used
to assign a unique token to the device using an SMS message.
That token or identifier can then be validated with when authenticating user credentials.</p>
<p>This is a countermeasure against the following threats:</p>
<blockquote>
<div><ul class="simple">
<li>token theft from a particular device</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="x-frame-option-header">
<span id="oauth-threat-5-2-2-6"></span><h5><a class="toc-backref" href="#id161">5.2.2.6.  X-FRAME-OPTION header</a><a class="headerlink" href="#x-frame-option-header" title="Permalink to this headline">¶</a></h5>
<p>For newer browsers,
avoidance of iFrames can be enforced server side by using the <a class="reference internal" href="glossary.html#term-x-frame-option"><em class="xref std std-term">X-FRAME-OPTION</em></a> header.
This header can have two values, deny and same origin,
which will block any framing or framing by sites with a different origin, respectively.</p>
<p>This is a countermeasure against the following threats:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="glossary.html#term-clickjacking"><em class="xref std std-term">Clickjacking</em></a> attacks</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-9"><em>4.4.1.9.  Threat: Clickjacking attack against authorization</em></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="public-client-authentication-and-authorization">
<span id="oauth-threat-5-2-3"></span><h4><a class="toc-backref" href="#id162">5.2.3.  Public client authentication and authorization</a><a class="headerlink" href="#public-client-authentication-and-authorization" title="Permalink to this headline">¶</a></h4>
<p>As described in <a class="reference internal" href="#oauth-threat-3"><em>Section 3 (Security Features)</em></a>,
clients are identified, authenticated and authorized for several purposes, such as a</p>
<blockquote>
<div><ul class="simple">
<li>Collate sub-sequent requests to the same client,</li>
<li>Indicate the trustworthiness of a particular client to the end-user,</li>
<li>Authorize access of clients to certain features on the
authorization or resource server, and</li>
<li>Log a client identity to log files for analysis or statics.</li>
</ul>
</div></blockquote>
<p>Due to the different capabilities and characteristics of the different client types,
there are different ways to support achieve objectives,
which will be described in this section.</p>
<p>Authorization server providers should be aware of the security policy and
deployment of a particular clients and adapt its treatment accordingly.</p>
<p>For example, one approach could be to treat all clients
as less trustworthy and unsecure.
On the other extreme, a service provider could activate every client installation
by hand of an administrator and that way gain confidence in the identity of
the software package and the security of the environment the client is installed in.
And there are several approaches in between.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-3-6"><em>4.4.3.6.  Threat: Online guessing</em></a></li>
</ul>
</div>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-2-3-1"><em>5.2.3.1.  Don&#8217;t issue secrets to public clients or clients with inappropriate security policy</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-2"><em>5.2.3.2.  Public clients without secret require user consent</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-3"><em>5.2.3.3.  Client_id only in combination with redirect_uri</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-4"><em>5.2.3.4.  Deployment-specific client secrets</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-5"><em>5.2.3.5.  Validation of pre-registered redirect_uri</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-6"><em>5.2.3.6.  Client secret revocation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-3-7"><em>5.2.3.7.  Use strong client authentication (e.g. client_assertion / client_token)</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="don-t-issue-secrets-to-public-clients-or-clients-with-inappropriate-security-policy">
<span id="oauth-threat-5-2-3-1"></span><h5><a class="toc-backref" href="#id163">5.2.3.1.  Don&#8217;t issue secrets to public clients or clients with inappropriate security policy</a><a class="headerlink" href="#don-t-issue-secrets-to-public-clients-or-clients-with-inappropriate-security-policy" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Clients:</p>
<blockquote class="last">
<div><ul class="simple">
<li><a class="reference internal" href="glossary.html#term-public-client"><em class="xref std std-term">public client</em></a></li>
<li><em class="xref std std-term">private client</em></li>
</ul>
</div></blockquote>
</div>
<p><a class="reference internal" href="glossary.html#term-authorization-servers"><em class="xref std std-term">Authorization servers</em></a> should not issue secrets
to &#8220;public&#8221; clients that cannot protect secrets.
This prevents the server from overestimating the value of
a successful authentication of the client.</p>
<p>For example,
it is of limited benefit to create a single client id and secret
which is shared by all installations of a native
application.  Such a scenario requires that this secret must be
transmitted from the developer via the respective distribution
channel, e.g. an application market, to all installations of the
application on end-user devices.  A secret, burned into the source
code of the application or a associated resource bundle, cannot be
entirely protected from reverse engineering.  Secondly, such secrets
cannot be revoked since this would immediately put all installations
out of work.  Moreover, since the authorization server cannot really
trust on the client&#8217;s identity, it would be dangerous to indicate to
end-users the trustworthiness of the client.</p>
<p>There are other ways to achieve a reasonable security level, as
described in the following sections.</p>
</div>
<div class="section" id="public-clients-without-secret-require-user-consent">
<span id="oauth-threat-5-2-3-2"></span><h5><a class="toc-backref" href="#id164">5.2.3.2.  Public clients without secret require user consent</a><a class="headerlink" href="#public-clients-without-secret-require-user-consent" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="glossary.html#term-authorization-servers"><em class="xref std std-term">Authorization servers</em></a> should not allow <em class="xref std std-term">automatic authorization</em>
for <a class="reference internal" href="oauth.html#term-public-clients"><em class="xref std std-term">public clients</em></a>.
The authorization may issue a <a class="reference internal" href="glossary.html#term-client-id"><em class="xref std std-term">client id</em></a>,
but SHOULD require that all authorizations are approved by the <a class="reference internal" href="messages.html#term-end-user"><em class="xref std std-term">end-user</em></a>.</p>
<p>This is a countermeasure for clients without secret against the following threats:</p>
<blockquote>
<div><ul class="simple">
<li>Impersonation of <a class="reference internal" href="glossary.html#term-public-client"><em class="xref std std-term">public client</em></a> applications</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="client-id-only-in-combination-with-redirect-uri">
<span id="oauth-threat-5-2-3-3"></span><h5><a class="toc-backref" href="#id165">5.2.3.3.  Client_id only in combination with redirect_uri</a><a class="headerlink" href="#client-id-only-in-combination-with-redirect-uri" title="Permalink to this headline">¶</a></h5>
<p>The authorization may issue a <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> and
bind the client_id to a certain pre-configured <a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a>.</p>
<p>Any <a class="reference internal" href="glossary.html#term-authorization-request"><em class="xref std std-term">authorization request</em></a> with another redirection URI is refused automatically.
Alternatively,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST not accept any dynamic redirection URI
for such a client_id and
instead always redirect to the well-known pre-configured redirection URI.</p>
<p>This is a countermeasure for clients without secrets against the following threats:</p>
<blockquote>
<div><ul class="simple">
<li><em class="xref std std-term">Cross-site scripting attacks</em></li>
<li>Impersonation of <a class="reference internal" href="glossary.html#term-public-client"><em class="xref std std-term">public client</em></a> applications</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="deployment-specific-client-secrets">
<span id="oauth-threat-5-2-3-4"></span><h5><a class="toc-backref" href="#id166">5.2.3.4.  Deployment-specific client secrets</a><a class="headerlink" href="#deployment-specific-client-secrets" title="Permalink to this headline">¶</a></h5>
<p>A <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may issue separate
client identifiers and corresponding secrets
to the different deployments of a client.</p>
<p>The effect of such an approach would be to turn otherwise &#8220;public&#8221; clients
back into &#8220;confidential&#8221; clients.</p>
<p>For <strong>web applications</strong>,
this could mean to create one <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> and <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">client_secret</em></a> per web site
a software package is installed on.
So the provider of that particular site could request <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client id</em></a> and
<a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">secret</em></a> from the authorization server during setup of the web site.</p>
<p>This would also allow to validate some of the properties of that web site,
such as <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>, address, and whatever proofs useful.
The web site provider has to ensure the security of the client secret on the site.</p>
<p>For <strong>native applications</strong>,
things are more complicated because every installation of the application
on any device is another deployment.</p>
<p>Deployment specific secrets will require</p>
<blockquote>
<div><ol class="arabic simple">
<li>Either to obtain a client_id and client_secret during <strong>download process</strong> from the application market,
or</li>
<li>During <strong>installation</strong> on the device.</li>
</ol>
</div></blockquote>
<p>Either approach will require an automated mechanism for issuing client ids and secrets,
which is currently not defined by OAuth.</p>
<p>The first approach would allow to achieve a level
where the client is authenticated and identified,
whereas the second option only allows to authenticate the client
but not to validate properties of the client.</p>
<p>But this would at least help to prevent several replay attacks.
Moreover, deployment-specific client_id and secret allow to selectively revoke all refresh tokens
of a specific deployment at once.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-5-3"><em>4.5.3.  Threat: Obtain refresh token by online guessing</em></a></li>
</ul>
</div>
</div>
<div class="section" id="validation-of-pre-registered-redirect-uri">
<span id="oauth-threat-5-2-3-5"></span><h5><a class="toc-backref" href="#id167">5.2.3.5.  Validation of pre-registered redirect_uri</a><a class="headerlink" href="#validation-of-pre-registered-redirect-uri" title="Permalink to this headline">¶</a></h5>
<p>An <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> SHOULD require all clients
to register their <a class="reference internal" href="standard.html#term-redirect-uri"><em class="xref std std-term">redirect_uri</em></a>
and the redirect_uri should be the full URI as defined in [I-D.ietf-oauth-v2].</p>
<p>The way this registration is performed is out of scope of this document.
Every actual redirection URI sent with the respective <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client_id</em></a> to <em class="xref std std-term">the end-user</em> authorization endpoint
must match the registered redirection URI.
Where it does not match,
the authorization server must assume the inbound GET request has been sent by an attacker and refuse it.</p>
<p>Note:
the authorization server MUST NOT redirect the user agent
back to the redirection URI of such an authorization request.</p>
<blockquote>
<div><dl class="docutils">
<dt>o  Authorization code leakage through counterfeit web site:</dt>
<dd>allows to detect attack attempts already after first redirect to end-user authorization endpoint
(<a class="reference internal" href="#oauth-threat-4-4-1-7"><em>Section 4.4.1.7</em></a>).</dd>
<dt>o  For clients with validated properties,</dt>
<dd>this measure also helps to detect malicious applications early in the end-user authorization process.
This reduces the need for a interactive validation by the user
(<a class="reference internal" href="#oauth-threat-4-4-1-4"><em>Section 4.4.1.4</em></a>, <a class="reference internal" href="#oauth-threat-4-4-2-3"><em>Section 4.4.2.3</em></a>).</dd>
</dl>
<p>o  Open Redirector attack via client redirection endpoint. ( <a class="reference internal" href="#oauth-threat-4-1-5"><em>Section 4.1.5</em></a>. )</p>
<p>o  Open Redirector phishing attack via authorization server redirection endpoint ( <a class="reference internal" href="#oauth-threat-4-2-4"><em>Section 4.2.4</em></a>)</p>
</div></blockquote>
<p>The underlying assumption of this measure is that
an attacker must use another redirection URI in order to get access to the authorization code.
Deployments might consider the possibility of an attacker using spoofing attacks to a victims device to circumvent this security measure.</p>
<p>Note:
Pre-registering clients might not scale in some deployments (manual process)
or require dynamic client registration (not specified yet).
With the lack of dynamic client registration,
it only works for clients bound to certain deployments at development/ configuration time.
As soon as dynamic resource server discovery gets involved, that&#8217;s no longer feasible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-2-3"><em>4.2.3.  Threat: Malicious client obtains existing authorization by fraud</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-2-4"><em>4.2.4.  Threat: Open redirector</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
</ul>
</div>
</div>
<div class="section" id="client-secret-revocation">
<span id="oauth-threat-5-2-3-6"></span><h5><a class="toc-backref" href="#id168">5.2.3.6.  Client secret revocation</a><a class="headerlink" href="#client-secret-revocation" title="Permalink to this headline">¶</a></h5>
<p>An <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may revoke a client&#8217;s secret
in order to prevent abuse of a revealed secret.</p>
<p>Note:
This measure will immediately invalidate any <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
or <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> issued to the respective <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>.
This might be unintentionally for <em class="xref std std-term">client identifiers</em> and <a class="reference internal" href="glossary.html#term-206"><em class="xref std std-term">secrets</em></a>
used across multiple deployments of a particular native or web application.</p>
<p>This a countermeasure against:</p>
<blockquote>
<div><ul class="simple">
<li>Abuse of revealed <a class="reference internal" href="glossary.html#term-client-secrets"><em class="xref std std-term">client secrets</em></a> for <em class="xref std std-term">private clients</em></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="use-strong-client-authentication-e-g-client-assertion-client-token">
<span id="oauth-threat-5-2-3-7"></span><h5><a class="toc-backref" href="#id169">5.2.3.7.  Use strong client authentication (e.g. client_assertion / client_token)</a><a class="headerlink" href="#use-strong-client-authentication-e-g-client-assertion-client-token" title="Permalink to this headline">¶</a></h5>
<p>By using an alternative form of authentication such as client assertion <a class="reference internal" href="oauth_assertion.html"><em>[draft-ietf-oauth-assertions]</em></a>,
the need to distribute <a class="reference internal" href="reg.html#term-23"><em class="xref std std-term">client_secret</em></a> is eliminated.</p>
<p>This may require the use of a secure private key store or
other supplemental authentication system as specified by the client assertion issuer
in its authentication process.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-3-5"><em>4.3.5.  Threat: Obtain client secret by online guessing</em></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="end-user-authorization">
<span id="oauth-threat-5-2-4"></span><h4><a class="toc-backref" href="#id170">5.2.4.  End-user authorization</a><a class="headerlink" href="#end-user-authorization" title="Permalink to this headline">¶</a></h4>
<p>This secion involves considerations for authorization flows involving the end-user.</p>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-2-4-1"><em>5.2.4.1.  Automatic processing of repeated authorizations requires client validation</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-4-2"><em>5.2.4.2.  Informed decisions based on transparency</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-4-3"><em>5.2.4.3.  Validation of client properties by end-user</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-4-4"><em>5.2.4.4.  Binding of authorization code to client_id</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-2-4-5"><em>5.2.4.5.  Binding of authorization code to redirect_uri</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="automatic-processing-of-repeated-authorizations-requires-client-validation">
<span id="oauth-threat-5-2-4-1"></span><h5><a class="toc-backref" href="#id171">5.2.4.1.  Automatic processing of repeated authorizations requires client validation</a><a class="headerlink" href="#automatic-processing-of-repeated-authorizations-requires-client-validation" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Authenicate/validate client:</p>
<blockquote class="last">
<div><ul class="simple">
<li>client_id + client_secret</li>
<li>client assertion / client token (handle)</li>
<li>redirect URI</li>
</ul>
</div></blockquote>
</div>
<p>Authorization servers SHOULD NOT automatically process repeat authorizations
where the client is not authenticated through a client secret
or some other authentication mechanism such as signing with security certificates
(5.7.2.7 <a class="footnote-reference" href="#id31" id="id29">[13]</a> .  Use strong client authentication (e.g. client_assertion / client_token))
or validation of a pre-registered redirect URI (5.7.2.5 <a class="footnote-reference" href="#id32" id="id30">[14]</a> .  Validation of pre-registered redirection URI ).</p>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[13]</a></td><td>MUST be 5.2.3.7 , <a class="reference internal" href="#oauth-threat-5-2-3-7"><em>5.2.3.7.  Use strong client authentication (e.g. client_assertion / client_token)</em></a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id30">[14]</a></td><td>MUST be 5.2.3.5 , <a class="reference internal" href="#oauth-threat-5-2-3-5"><em>5.2.3.5.  Validation of pre-registered redirect_uri</em></a></td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
</ul>
</div>
</div>
<div class="section" id="informed-decisions-based-on-transparency">
<span id="oauth-threat-5-2-4-2"></span><h5><a class="toc-backref" href="#id172">5.2.4.2.  Informed decisions based on transparency</a><a class="headerlink" href="#informed-decisions-based-on-transparency" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> SHOULD clearly explain to the end-user
what happens in the authorization process and
what the consequences are.</p>
<p>For example, the user shall understand what access he is about to grant
to which <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> for what <a class="reference internal" href="glossary.html#term-duration"><em class="xref std std-term">duration</em></a>.</p>
<p>It shall also be obvious to the user,
whether the server is able to reliably certify certain client properties
(web site address, security policy).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-2-2"><em>4.2.2.  Threat: User unintentionally grants too much access scope</em></a></li>
</ul>
</div>
</div>
<div class="section" id="validation-of-client-properties-by-end-user">
<span id="oauth-threat-5-2-4-3"></span><h5><a class="toc-backref" href="#id173">5.2.4.3.  Validation of client properties by end-user</a><a class="headerlink" href="#validation-of-client-properties-by-end-user" title="Permalink to this headline">¶</a></h5>
<p>In the authorization process,
the user is typically asked to approve a client&#8217;s request for authorization.
This is an important security mechanism by itself
because the end-user can be involved in the validation of client properties,
such as whether the <strong>client name</strong> known to the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> fits the name of the web site
or the application the end-user is using.
This measure is especially helpful in all situation
where the authorization server is unable to authenticate the client.
It is a countermeasure against:</p>
<blockquote>
<div><ul class="simple">
<li>Malicious application</li>
<li>A client application masquerading as another client</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-4"><em>4.4.1.4.  Threat: Malicious client obtains authorization</em></a></li>
</ul>
</div>
</div>
<div class="section" id="binding-of-authorization-code-to-client-id">
<span id="oauth-threat-5-2-4-4"></span><h5><a class="toc-backref" href="#id174">5.2.4.4.  Binding of authorization code to client_id</a><a class="headerlink" href="#binding-of-authorization-code-to-client-id" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST bind every <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
to <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">the id of the respective client</em></a> which initiated the end-user authorization process.</p>
<p>This measure is a countermeasure against:</p>
<blockquote>
<div><ul class="simple">
<li>replay of authorization codes with different client credentials
since an attacker cannot use another client_id to exchange an
authorization code into a token</li>
<li>Online guessing of authorization codes</li>
</ul>
</div></blockquote>
<p>Note: This binding MUST be protected from unauthorized modifications.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-1"><em>4.4.1.1.  Threat: Eavesdropping or leaking authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-5"><em>4.4.1.5.  Threat: Authorization code phishing</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
</ul>
</div>
</div>
<div class="section" id="binding-of-authorization-code-to-redirect-uri">
<span id="oauth-threat-5-2-4-5"></span><h5><a class="toc-backref" href="#id175">5.2.4.5.  Binding of authorization code to redirect_uri</a><a class="headerlink" href="#binding-of-authorization-code-to-redirect-uri" title="Permalink to this headline">¶</a></h5>
<p>The <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST bind every <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>
to the actual <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a> used as redirect target of the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a>
in the end-user authorization process.</p>
<p>This binding MUST be validated when the client attempts
to exchange the respective authorization code for an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.</p>
<p>This measure is a countermeasure against authorization code leakage
through counterfeit web sites
since an attacker cannot use another redirection URI to exchange an authorization code into a token.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-3"><em>4.4.1.3.  Threat: Online guessing of authorization codes</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-4-1-7"><em>4.4.1.7.  Threat: Authorization code leakage through counterfeit client</em></a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="client-app-security">
<span id="oauth-threat-5-3"></span><h3><a class="toc-backref" href="#id176">5.3.  Client App Security</a><a class="headerlink" href="#client-app-security" title="Permalink to this headline">¶</a></h3>
<p>This section deals with considerations for <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> applications.</p>
<p>Measures:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-3-1"><em>5.3.1.  Don&#8217;t store credentials in code or resources bundled with software packages</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-3-2"><em>5.3.2.  Standard web server protection measures (for config files and databases)</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-3-3"><em>5.3.3.  Store secrets in a secure storage</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-3-4"><em>5.3.4.  Utilize device lock to prevent unauthorized device access</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-3-5"><em>5.3.5.  Platform security measures</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-3-6"><em>5.3.6.  Link state parameter to user agent session</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="don-t-store-credentials-in-code-or-resources-bundled-with-software-packages">
<span id="oauth-threat-5-3-1"></span><h4><a class="toc-backref" href="#id177">5.3.1.  Don&#8217;t store credentials in code or resources bundled with software packages</a><a class="headerlink" href="#don-t-store-credentials-in-code-or-resources-bundled-with-software-packages" title="Permalink to this headline">¶</a></h4>
<p>Because of the numbers of copies of <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> software,
there is limited benefit to create a single <a class="reference internal" href="glossary.html#term-client-id"><em class="xref std std-term">client id</em></a> and <a class="reference internal" href="glossary.html#term-206"><em class="xref std std-term">secret</em></a>
which is shared by all installations of an application.</p>
<p>Such an application by itself would be considered a &#8220;public&#8221; client
as it cannot be presumed to be able to keep client secrets.</p>
<p>A secret, burned into the source code of the application
or a associated resource bundle,
cannot be entirely protected from reverse engineering.</p>
<p>Secondly,
such secrets cannot be revoked
since this would immediately put all installations out of work.</p>
<p>Moreover,
since the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> cannot really trust
on the client&#8217;s identity,
it would be dangerous to indicate to end-users the trustworthiness of the client.</p>
</div>
<div class="section" id="standard-web-server-protection-measures-for-config-files-and-databases">
<span id="oauth-threat-5-3-2"></span><h4><a class="toc-backref" href="#id178">5.3.2.  Standard web server protection measures (for config files and databases)</a><a class="headerlink" href="#standard-web-server-protection-measures-for-config-files-and-databases" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="store-secrets-in-a-secure-storage">
<span id="oauth-threat-5-3-3"></span><h4><a class="toc-backref" href="#id179">5.3.3.  Store secrets in a secure storage</a><a class="headerlink" href="#store-secrets-in-a-secure-storage" title="Permalink to this headline">¶</a></h4>
<p>The are different way to store secrets of all kinds
(tokens, client secrets) securely on a device or server.</p>
<p>Most multi-user operation systems segregate the personal storage of
the different system users.  Moreover, most modern smartphone
operating systems even support to store app-specific data in separate
areas of the file systems and protect it from access by other
applications.  Additionally, applications can implements confidential
data itself using a user-supplied secret, such as PIN or password.</p>
<p>Another option is to swap refresh token storage to a trusted backend
server.  This mean in turn requires a resilient authentication
mechanisms between client and backend server.  Note: Applications
must ensure that confidential data are kept confidential even after
reading from secure storage, which typically means to keep this data
in the local memory of the application.</p>
</div>
<div class="section" id="utilize-device-lock-to-prevent-unauthorized-device-access">
<span id="oauth-threat-5-3-4"></span><h4><a class="toc-backref" href="#id180">5.3.4.  Utilize device lock to prevent unauthorized device access</a><a class="headerlink" href="#utilize-device-lock-to-prevent-unauthorized-device-access" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="platform-security-measures">
<span id="oauth-threat-5-3-5"></span><h4><a class="toc-backref" href="#id181">5.3.5.  Platform security measures</a><a class="headerlink" href="#platform-security-measures" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>Validation process</li>
<li>software package signatures</li>
<li>Remote removal</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="link-state-parameter-to-user-agent-session">
<span id="oauth-threat-5-3-6"></span><h4><a class="toc-backref" href="#id182">5.3.6.  Link <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter to user agent session</a><a class="headerlink" href="#link-state-parameter-to-user-agent-session" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="standard.html#term-29"><em class="xref std std-term">state</em></a> parameter is used to link client requests
and prevent <a class="reference internal" href="glossary.html#term-csrf"><em class="xref std std-term">CSRF</em></a> attacks, for example against the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>.</p>
<p>An attacker could inject their own <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> or <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> [#],
which can result in the client using an access token
associated with the attacker&#8217;s protected resources rather than the victim&#8217;s
(e.g.
save the victim&#8217;s bank account information to a <a class="reference internal" href="uma_core.html#term-protected-resource"><em class="xref std std-term">protected resource</em></a> i
controlled by the attacker).</p>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[15]</td><td>Why access token CSRF to redirection URL ? Authorization Code can be CSRF-ed to redirect URL.</td></tr>
</tbody>
</table>
<p>The <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> SHOULD utilize the &#8220;<strong>state</strong>&#8221; request parameter
to send the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> a value
that binds the request to the user-agent&#8217;s authenticated state
(e.g. a hash of the session cookie used to authenticate the user-agent)
when making an authorization request.</p>
<p>Once authorization has been obtained from the end-user,
the <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> redirects the end-user&#8217;s user-agent
back to the <a class="reference internal" href="oauth.html#term-client"><em class="xref std std-term">client</em></a> with the required binding value contained in the &#8220;state&#8221; parameter.</p>
<p>The binding value enables the client to verify the validity of the request
by matching the binding value to the user-agent&#8217;s authenticated state.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-4-1-8"><em>4.4.1.8.  Threat: CSRF attack against redirect-uri</em></a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="resource-servers">
<span id="oauth-threat-5-4"></span><h3><a class="toc-backref" href="#id183">5.4.  Resource Servers</a><a class="headerlink" href="#resource-servers" title="Permalink to this headline">¶</a></h3>
<p>The following section details security considerations for <a class="reference internal" href="glossary.html#term-resource-servers"><em class="xref std std-term">resource servers</em></a>.</p>
<p>Considerations:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#oauth-threat-5-4-1"><em>5.4.1.  Authorization headers</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-4-2"><em>5.4.2.  Authenticated requests</em></a></li>
<li><a class="reference internal" href="#oauth-threat-5-4-3"><em>5.4.3.  Signed requests</em></a></li>
</ul>
</div></blockquote>
<div class="section" id="authorization-headers">
<span id="oauth-threat-5-4-1"></span><h4><a class="toc-backref" href="#id184">5.4.1.  Authorization headers</a><a class="headerlink" href="#authorization-headers" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="glossary.html#term-authorization-header"><em class="xref std std-term">Authorization headers</em></a> are recognized
and specially treated by HTTP proxies and servers.
Thus the usage of such headers for sending
<a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> to <a class="reference internal" href="glossary.html#term-resource-servers"><em class="xref std std-term">resource servers</em></a> reduces the likelihood of leakage
or unintended storage of authenticated requests in general and
especially Authorization headers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-6-6"><em>4.6.6.  Threat: Leak of confidential data in HTTP-Proxies</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
</div>
<div class="section" id="authenticated-requests">
<span id="oauth-threat-5-4-2"></span><h4><a class="toc-backref" href="#id185">5.4.2.  Authenticated requests</a><a class="headerlink" href="#authenticated-requests" title="Permalink to this headline">¶</a></h4>
<p>An <a class="reference internal" href="oauth.html#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may bind tokens to a certain <a class="reference internal" href="standard.html#term-client-id"><em class="xref std std-term">client identitiy</em></a>
and encourage <a class="reference internal" href="glossary.html#term-resource-servers"><em class="xref std std-term">resource servers</em></a> to validate that binding.
This will require the <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> to authenticate
the originator of a request as the legitimate owner of a particular token.
There are a couple of options to implement this countermeasure:</p>
<blockquote>
<div><ul class="simple">
<li>The authorization server may associate the distinguished name of
the client with the token (either internally or in the payload of an self-contained token).
The client then uses client certificate-based HTTP authentication
on the resource server&#8217;s endpoint to authenticate its identity
and the resource server validates the name with the name referenced by the token.</li>
<li>same as before, but the client uses his private key to sign the request
to the resource server
(public key is either contained in the token or sent along with the request)</li>
<li>Alternatively, the authorization server may issue a token-bound secret,
which the client uses to sign the request.
The resource server obtains the secret either directly from the authorization server
or it is contained in an encrypted section of the token.
That way the resource server does not &#8220;know&#8221; the client
but is able to validate whether the authorization server issued the token to that client</li>
</ul>
</div></blockquote>
<p>This mechanisms is a countermeasure against abuse of tokens by counterfeit resource servers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-6-1"><em>4.6.1.  Threat: Eavesdropping access tokens on transport</em></a></li>
<li><a class="reference internal" href="#oauth-threat-4-6-7"><em>4.6.7.  Threat: Token leakage via logfiles and HTTP referrers</em></a></li>
</ul>
</div>
</div>
<div class="section" id="signed-requests">
<span id="oauth-threat-5-4-3"></span><h4><a class="toc-backref" href="#id186">5.4.3.  Signed requests</a><a class="headerlink" href="#signed-requests" title="Permalink to this headline">¶</a></h4>
<p>A <a class="reference internal" href="oauth.html#term-resource-server"><em class="xref std std-term">resource server</em></a> may decide to accept signed requests only,
either to replace transport level security measures
or to complement such measures.</p>
<p>Every signed request must be uniquely identifiable and
must not be processed twice by the resource server.
This countermeasure helps to mitigate:</p>
<blockquote>
<div><ul class="simple">
<li>modifications of the message and</li>
<li>replay attempts</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-threat-4-6-2"><em>4.6.2.  Threat: Replay authorized resource server requests</em></a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="iana-considerations">
<span id="oauth-threat-6"></span><h2><a class="toc-backref" href="#id187">6.  IANA Considerations</a><a class="headerlink" href="#iana-considerations" title="Permalink to this headline">¶</a></h2>
<p>This document makes no request of IANA.</p>
<p>Note to RFC Editor: this section may be removed on publication as an RFC.</p>
</div>
<div class="section" id="acknowledgements">
<span id="oauth-threat-7"></span><h2><a class="toc-backref" href="#id188">7.  Acknowledgements</a><a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>We would like to thank Hui-Lan Lu, Francisco Corella, Peifung E Lam,
Shane B Weeden, Skylar Woodward, Niv Steingarten and James H. Manger
for their comments and contributions.</p>
</div>
<div class="section" id="references">
<span id="oauth-threat-8"></span><h2><a class="toc-backref" href="#id189">8.  References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<div class="section" id="normative-references">
<span id="oauth-threat-8-1"></span><h3><a class="toc-backref" href="#id190">8.1.  Normative References</a><a class="headerlink" href="#normative-references" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl class="docutils">
<dt>[I-D.ietf-oauth-v2]</dt>
<dd>Hammer-Lahav, E., Recordon, D., and D. Hardt, &#8220;The OAuth
2.0 Authorization Protocol&#8221;, draft-ietf-oauth-v2-22 (work
in progress), September 2011.</dd>
<dt>[RFC2119]  Bradner, S., &#8220;Key words for use in RFCs to Indicate</dt>
<dd>Requirement Levels&#8221;, BCP 14, RFC 2119, March 1997.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="informative-references">
<span id="oauth-threat-8-2"></span><h3><a class="toc-backref" href="#id191">8.2.  Informative References</a><a class="headerlink" href="#informative-references" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl class="docutils">
<dt>[I-D.ietf-oauth-v2-bearer]</dt>
<dd>Jones, M., Hardt, D., and D. Recordon, &#8220;The OAuth 2.0
Authorization Protocol: Bearer Tokens&#8221;,
draft-ietf-oauth-v2-bearer-11 (work in progress),
October 2011.</dd>
<dt>[I-D.ietf-oauth-v2-http-mac]</dt>
<dd>Hammer-Lahav, E., Barth, A., and B. Adida, &#8220;HTTP
Authentication: MAC Access Authentication&#8221;,
draft-ietf-oauth-v2-http-mac-00 (work in progress),
May 2011.</dd>
<dt>[I-D.lodderstedt-oauth-revocation]</dt>
<dd>Lodderstedt, T., Dronia, S., and M. Scurtescu, &#8220;Token
Revocation&#8221;, draft-lodderstedt-oauth-revocation-03 (work
in progress), September 2011.</dd>
<dt>[portable-contacts]</dt>
<dd>Smarr, J., &#8220;Portable Contacts 1.0 Draft C&#8221;, August 2008.</dd>
</dl>
</div></blockquote>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="oauth_responses.html">OAuth 2.0 Multiple Response Type Encoding Practices</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="bearer.html">The OAuth 2.0 Protocol: Bearer Tokens</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, HDKNR.COM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre.
    </div>
  </body>
</html>