

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The OAuth 2.0 Authorization Framework &mdash; identity 1.0 documentation</title>
    
    <link rel="stylesheet" href="static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    <link rel="stylesheet" href="static/openid.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="identity 1.0 documentation" href="index.html" />
    <link rel="next" title="The OAuth 2.0 Authorization Framework: Bearer Token Usage" href="oauth_bearer.html" />
    <link rel="prev" title="Digital Identity" href="index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>identity 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>The OAuth 2.0 Authorization Framework</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Digital Identity</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="oauth_bearer.html">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="the-oauth-2-0-authorization-framework">
<span id="oauth-head"></span><h1><a class="toc-backref" href="#id19">The OAuth 2.0 Authorization Framework</a><a class="headerlink" href="#the-oauth-2-0-authorization-framework" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-oauth-2-0-authorization-framework" id="id19">The OAuth 2.0 Authorization Framework</a><ul>
<li><a class="reference internal" href="#abstract" id="id20">Abstract</a></li>
<li><a class="reference internal" href="#introduction" id="id21">1.  Introduction</a><ul>
<li><a class="reference internal" href="#roles" id="id22">1.1.  Roles</a></li>
<li><a class="reference internal" href="#protocol-flow" id="id23">1.2.  Protocol Flow</a></li>
<li><a class="reference internal" href="#authorization-grant" id="id24">1.3.  Authorization Grant</a><ul>
<li><a class="reference internal" href="#authorization-code" id="id25">1.3.1.  Authorization Code</a></li>
<li><a class="reference internal" href="#implicit" id="id26">1.3.2.  Implicit</a></li>
<li><a class="reference internal" href="#resource-owner-password-credentials" id="id27">1.3.3.  Resource Owner Password Credentials</a></li>
<li><a class="reference internal" href="#client-credentials" id="id28">1.3.4.  Client Credentials</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-token" id="id29">1.4. Access Token</a></li>
<li><a class="reference internal" href="#refresh-token" id="id30">1.5. Refresh Token</a></li>
<li><a class="reference internal" href="#tls-version" id="id31">1.6. TLS Version</a></li>
<li><a class="reference internal" href="#http-redirections" id="id32">1.7. HTTP Redirections</a></li>
<li><a class="reference internal" href="#interoperability" id="id33">1.8. Interoperability</a></li>
<li><a class="reference internal" href="#notational-conventions" id="id34">1.9. Notational Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#client-registration" id="id35">2. Client Registration</a><ul>
<li><a class="reference internal" href="#client-types" id="id36">2.1. Client Types</a></li>
<li><a class="reference internal" href="#client-identifier" id="id37">2.2. Client Identifier</a></li>
<li><a class="reference internal" href="#client-authentication" id="id38">2.3. Client Authentication</a><ul>
<li><a class="reference internal" href="#client-password" id="id39">2.3.1. Client Password</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unregistered-clients" id="id40">2.4. Unregistered Clients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocol-endpoints" id="id41">3. Protocol Endpoints</a><ul>
<li><a class="reference internal" href="#authorization-endpoint" id="id42">3.1. Authorization Endpoint</a><ul>
<li><a class="reference internal" href="#response-type" id="id43">3.1.1. Response Type</a></li>
<li><a class="reference internal" href="#redirection-endpoint" id="id44">3.1.2. Redirection Endpoint</a><ul>
<li><a class="reference internal" href="#endpoint-request-confidentiality" id="id45">3.1.2.1. Endpoint Request Confidentiality</a></li>
<li><a class="reference internal" href="#registration-requirements" id="id46">3.1.2.2. Registration Requirements</a></li>
<li><a class="reference internal" href="#dynamic-configuration" id="id47">3.1.2.3. Dynamic Configuration</a></li>
<li><a class="reference internal" href="#invalid-endpoint" id="id48">3.1.2.4. Invalid Endpoint</a></li>
<li><a class="reference internal" href="#endpoint-content" id="id49">3.1.2.5. Endpoint Content</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#token-endpoint" id="id50">3.2. Token Endpoint</a><ul>
<li><a class="reference internal" href="#oauth-client-authentication" id="id51">3.2.1. Client Authentication</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-token-scope" id="id52">3.3. Access Token Scope</a></li>
</ul>
</li>
<li><a class="reference internal" href="#obtaining-authorization" id="id53">4. Obtaining Authorization</a><ul>
<li><a class="reference internal" href="#authorization-code-grant" id="id54">4.1. Authorization Code Grant</a><ul>
<li><a class="reference internal" href="#authorization-request" id="id55">4.1.1. Authorization Request</a></li>
<li><a class="reference internal" href="#authorization-response" id="id56">4.1.2. Authorization Response</a><ul>
<li><a class="reference internal" href="#error-response" id="id57">4.1.2.1. Error Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-token-request" id="id58">4.1.3. Access Token Request</a></li>
<li><a class="reference internal" href="#access-token-response" id="id59">4.1.4. Access Token Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implicit-grant" id="id60">4.2.  Implicit Grant</a><ul>
<li><a class="reference internal" href="#oauth-4-2-1" id="id61">4.2.1. Authorization Request</a></li>
<li><a class="reference internal" href="#oauth-4-2-2" id="id62">4.2.2. Access Token Response</a><ul>
<li><a class="reference internal" href="#oauth-4-2-2-1" id="id63">4.2.2.1. Error Response</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#resource-owner-password-credentials-grant" id="id64">4.3. Resource Owner Password Credentials Grant</a></li>
<li><a class="reference internal" href="#authorization-request-and-response" id="id65">4.3.1. Authorization Request and Response</a><ul>
<li><a class="reference internal" href="#oauth-4-3-2" id="id66">4.3.2. Access Token Request</a></li>
<li><a class="reference internal" href="#oauth-4-3-3" id="id67">4.3.3. Access Token Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#client-credentials-grant" id="id68">4.4. Client Credentials Grant</a><ul>
<li><a class="reference internal" href="#oauth-4-4-1" id="id69">4.4.1. Authorization Request and Response</a></li>
<li><a class="reference internal" href="#oauth-4-4-2" id="id70">4.4.2. Access Token Request</a></li>
<li><a class="reference internal" href="#oauth-4-4-3" id="id71">4.4.3. Access Token Response</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#issuing-an-access-token" id="id72">5.  Issuing an Access Token</a><ul>
<li><a class="reference internal" href="#successful-response" id="id73">5.1. Successful Response</a></li>
<li><a class="reference internal" href="#oauth-5-2" id="id74">5.2. Error Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#refreshing-an-access-token" id="id75">6. Refreshing an Access Token</a></li>
<li><a class="reference internal" href="#accessing-protected-resources" id="id76">7. Accessing Protected Resources</a><ul>
<li><a class="reference internal" href="#access-token-types" id="id77">7.1. Access Token Types</a></li>
<li><a class="reference internal" href="#oauth-7-2" id="id78">7.2. Error Response</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extensibility" id="id79">8. Extensibility</a><ul>
<li><a class="reference internal" href="#defining-access-token-types" id="id80">8.1.  Defining Access Token Types</a></li>
<li><a class="reference internal" href="#defining-new-endpoint-parameters" id="id81">8.2.  Defining New Endpoint Parameters</a></li>
<li><a class="reference internal" href="#defining-new-authorization-grant-types" id="id82">8.3.  Defining New Authorization Grant Types</a></li>
<li><a class="reference internal" href="#defining-new-authorization-endpoint-response-types" id="id83">8.4.  Defining New Authorization Endpoint Response Types</a></li>
<li><a class="reference internal" href="#defining-additional-error-codes" id="id84">8.5.  Defining Additional Error Codes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#native-applications" id="id85">9. Native Applications</a></li>
<li><a class="reference internal" href="#security-considerations" id="id86">10. Security Considerations</a><ul>
<li><a class="reference internal" href="#oauth-10-1" id="id87">10.1.  Client Authentication</a></li>
<li><a class="reference internal" href="#client-impersonation" id="id88">10.2.  Client Impersonation</a></li>
<li><a class="reference internal" href="#access-tokens" id="id89">10.3. Access Tokens</a></li>
<li><a class="reference internal" href="#refresh-tokens" id="id90">10.4.  Refresh Tokens</a></li>
<li><a class="reference internal" href="#authorization-codes" id="id91">10.5.  Authorization Codes</a></li>
<li><a class="reference internal" href="#authorization-code-redirection-uri-manipulation" id="id92">10.6.  Authorization Code Redirection URI Manipulation</a></li>
<li><a class="reference internal" href="#oauth-10-7" id="id93">10.7.  Resource Owner Password Credentials</a></li>
<li><a class="reference internal" href="#request-confidentiality" id="id94">10.8.  Request Confidentiality</a></li>
<li><a class="reference internal" href="#ensuring-endpoint-authenticity" id="id95">10.9.  Ensuring Endpoint Authenticity</a></li>
<li><a class="reference internal" href="#credentials-guessing-attacks" id="id96">10.10.  Credentials-Guessing Attacks</a></li>
<li><a class="reference internal" href="#phishing-attacks" id="id97">10.11.  Phishing Attacks</a></li>
<li><a class="reference internal" href="#cross-site-request-forgery" id="id98">10.12.  Cross-Site Request Forgery</a></li>
<li><a class="reference internal" href="#clickjacking" id="id99">10.13.  Clickjacking</a></li>
<li><a class="reference internal" href="#code-injection-and-input-validation" id="id100">10.14.  Code Injection and Input Validation</a></li>
<li><a class="reference internal" href="#open-redirectors" id="id101">10.15.  Open Redirectors</a></li>
<li><a class="reference internal" href="#misuse-of-access-token-to-impersonate-resource-owner-in-implicit-flow" id="id102">10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit Flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iana-considerations" id="id103">11.  IANA Considerations</a></li>
<li><a class="reference internal" href="#references" id="id104">12. References</a><ul>
<li><a class="reference internal" href="#normative-references" id="id105">12.1. Normative References</a></li>
<li><a class="reference internal" href="#informative-references" id="id106">12.2. Informative References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#oauth-13" id="id107">13.  References</a></li>
<li><a class="reference internal" href="#appendix-a-augmented-backus-naur-form-abnf-syntax" id="id108">Appendix A. Augmented Backus-Naur Form (ABNF) Syntax</a><ul>
<li><a class="reference internal" href="#a-1-client-id-syntax" id="id109">A.1. &#8220;client_id&#8221; Syntax</a></li>
<li><a class="reference internal" href="#a-4-scope-syntax" id="id110">A.4. &#8220;scope&#8221; Syntax</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul class="simple">
<li>An annotated document based on <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a></li>
</ul>
<div class="section" id="abstract">
<span id="oauth-abstract"></span><h2><a class="toc-backref" href="#id20">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>The OAuth 2.0 authorization framework enables
a third-party application to obtain limited access to an HTTP service,
either on behalf of a <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>
by orchestrating an approval interaction
between the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> and the HTTP service,
or by allowing the third-party application
to obtain access on its own behalf.
This specification replaces and obsoletes the OAuth 1.0 protocol described in <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5849.html"><strong>RFC 5849</strong></a> .</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749">Abstract</a> )</p>
</div>
<div class="section" id="introduction">
<span id="oauth-1"></span><h2><a class="toc-backref" href="#id21">1.  Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In the traditional client-server authentication model,
the client requests an access-restricted resource (<a class="reference internal" href="glossary.html#term-protected-resource"><em class="xref std std-term">protected resource</em></a>)
on the server by authenticating with the server
using the resource owner&#8217;s credentials.
In order to provide third-party applications access to restricted resources,
the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> shares its credentials with the third party.
This creates several problems and limitations:</p>
<blockquote>
<div><ul class="simple">
<li>Third-party applications are required to store the resource
owner&#8217;s credentials for future use, typically a password in
clear-text.</li>
<li>Servers are required to support password authentication, despite
the security weaknesses inherent in passwords.</li>
<li>Third-party applications gain overly broad access to the resource
owner&#8217;s protected resources, leaving resource owners without any
ability to restrict duration or access to a limited subset of
resources.</li>
<li>Resource owners cannot revoke access to an individual third party
without revoking access to all third parties, and must do so by
changing the third party&#8217;s password.</li>
<li>Compromise of any third-party application results in compromise of
the end-user&#8217;s password and all of the data protected by that
password.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last">
<li><p class="first">credential scattering</p>
<blockquote>
<div><ul class="simple">
<li>security breach on a single client = danger other clients and the server</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">passwords are usually week secrets.</p>
</li>
<li><p class="first">huge access scope for single grant</p>
</li>
<li><p class="first">no revocation : give up credential. all clients or nothing.</p>
</li>
</ul>
</div>
<p>OAuth addresses these issues by introducing an authorization layer
and separating the role of the client from that of the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>.
In OAuth,
the <a class="reference internal" href="#term-client"><em class="xref std std-term">client</em></a> requests access to resources controlled by
the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> and hosted by the <a class="reference internal" href="#term-resource-server"><em class="xref std std-term">resource server</em></a>,
and is issued a different set of credentials
than those of the resource owner.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Authorization Layer</li>
<li>Role Separation</li>
</ul>
</div>
<p>Instead of using the resource owner&#8217;s credentials to access protected resources,
the client obtains an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> &#8211;
a string denoting a specific <a class="reference internal" href="oauth_introspect.html#term-scope"><em class="xref std std-term">scope</em></a>, <em class="xref std std-term">lifetime</em>, and other access attributes.
Access tokens are issued to third-party clients
by an <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> with the approval of the resource owner.
The client uses the access token to access the protected resources hosted by the resource server.</p>
<p>For example,
an <a class="reference internal" href="#term-end-user"><em class="xref std std-term">end-user</em></a> (resource owner) can <em class="xref std std-term">grant</em> a printing service (<a class="reference internal" href="#term-client"><em class="xref std std-term">client</em></a>)
access to her protected photos stored at a photo-sharing service (<a class="reference internal" href="#term-resource-server"><em class="xref std std-term">resource server</em></a>),
without sharing her username and password with the printing service.</p>
<p>Instead,
she authenticates directly with a server trusted by the photo-sharing service
(<a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>),
which issues the printing service delegation-specific credentials (<a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>).</p>
<p>This specification is designed for use with HTTP (<a class="reference internal" href="oauth_meta.html#term-rfc2616"><em class="xref std std-term">[RFC2616]</em></a>).
The use of OAuth over any protocol other than HTTP is out of scope.</p>
<p>The OAuth 1.0 protocol (<a class="reference internal" href="#term-rfc5849"><em class="xref std std-term">[RFC5849]</em></a>),
published as an informational document,
was the result of a small ad hoc community effort.
This Standards Track specification builds on the OAuth 1.0 deployment experience,
as well as additional use cases and extensibility requirements gathered
from the wider IETF community.
The OAuth 2.0 protocol is not backward compatible with OAuth 1.0.
The two versions may co-exist on the network,
and implementations may choose to support both.
However,
it is the intention of this specification that new implementations support OAuth 2.0
as specified in this document and
that OAuth 1.0 is used only to support existing deployments.
The OAuth 2.0 protocol shares very few implementation details
with the OAuth 1.0 protocol.
Implementers familiar with OAuth 1.0 should approach this document
without any assumptions as to its structure and details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>NO backward compatibility to <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5849.html"><strong>RFC 5849</strong></a></li>
<li>NO implementation sharing with 1.0</li>
</ul>
</div>
<p>(<a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1">http://tools.ietf.org/html/rfc6749#section-1</a>)</p>
<div class="section" id="roles">
<span id="oauth-1-1"></span><h3><a class="toc-backref" href="#id22">1.1.  Roles</a><a class="headerlink" href="#roles" title="Permalink to this headline">¶</a></h3>
<p>OAuth defines four roles:</p>
<dl class="glossary docutils">
<dt id="term-resource-owner"><span id="term-resource-owners"></span>resource owner<br />resource owners</dt>
<dd>An entity capable of granting access to a <a class="reference internal" href="glossary.html#term-protected-resource"><em class="xref std std-term">protected resource</em></a>.
When the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> is a person, it is referred to as an
<a class="reference internal" href="#term-end-user"><em class="xref std std-term">end-user</em></a>.</dd>
<dt id="term-resource-server"><span id="term-resource-servers"></span>resource server<br />resource servers</dt>
<dd>The server hosting the <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a>,
capable of accepting and responding to <a class="reference internal" href="glossary.html#term-protected-resource"><em class="xref std std-term">protected resource</em></a> requests
using <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a>.</dd>
<dt id="term-client"><span id="term-clients"></span>client<br />clients</dt>
<dd>An application making <a class="reference internal" href="glossary.html#term-protected-resource"><em class="xref std std-term">protected resource</em></a> requests on behalf of the
<em class="xref std std-ref">resource owner</em> and with its authorization.  The term &#8220;client&#8221; does
not imply any particular implementation characteristics (e.g.,
whether the application executes on a server, a desktop, or other
devices).</dd>
<dt id="term-authorization-server"><span id="term-authorization-servers"></span>authorization server<br />authorization servers</dt>
<dd>The server issuing <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a> to the <a class="reference internal" href="#term-client"><em class="xref std std-term">client</em></a> after successfully
authenticating the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> and obtaining authorization.</dd>
</dl>
<p>The interaction between the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> and <em class="xref std std-ref">resource server</em>
is beyond the scope of this specification.
The <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> may be the same server as the resource server
or a separate entity.
A single authorization server may issue access tokens accepted by
multiple resource servers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<dl class="glossary docutils">
<dt id="term-entity">entity</dt>
<dd><ul class="first last simple">
<li>server or something like that.</li>
</ul>
</dd>
<dt id="term-end-user">end-user</dt>
<dd><ul class="first last simple">
<li>special <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> when it is is a person.</li>
</ul>
</dd>
</dl>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.1">http://tools.ietf.org/html/rfc6749#section-1.1</a> )</p>
</div>
<div class="section" id="protocol-flow">
<span id="oauth-1-2"></span><h3><a class="toc-backref" href="#id23">1.2.  Protocol Flow</a><a class="headerlink" href="#protocol-flow" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><pre>+--------+                               +---------------+
|        |--(A)- Authorization Request -&gt;|   Resource    |
|        |                               |     Owner     |
|        |&lt;-(B)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(C)-- Authorization Grant --&gt;| Authorization |
| Client |                               |     Server    |
|        |&lt;-(D)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(E)----- Access Token ------&gt;|    Resource   |
|        |                               |     Server    |
|        |&lt;-(F)--- Protected Resource ---|               |
+--------+                               +---------------+

                Figure 1: Abstract Protocol Flow</pre>
</div>
<p>The abstract OAuth 2.0 flow illustrated in Figure 1 describes the
interaction between the four roles and includes the following steps:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>The client requests authorization from the resource owner.  The
authorization request can be made directly to the resource owner
(as shown), or preferably indirectly via the authorization
server as an intermediary.</li>
<li>The client receives an authorization grant, which is a
credential representing the resource owner&#8217;s authorization,
expressed using one of four <a class="reference internal" href="#term-grant-types"><em class="xref std std-term">grant types</em></a> defined in this
specification or using an <a class="reference internal" href="glossary.html#term-extension-grant-type"><em class="xref std std-term">extension grant type</em></a>.  The
authorization grant type depends on the method used by the
client to request authorization and the types supported by the
authorization server.</li>
<li>The client requests an access token by authenticating with the
authorization server and presenting the authorization grant.</li>
<li>The authorization server authenticates the client and validates
the authorization grant, and if valid, issues an access token.</li>
<li>The client requests the protected resource from the resource
server and authenticates by presenting the access token.</li>
<li>The resource server validates the access token, and if valid,
serves the request.</li>
</ol>
</div></blockquote>
<p>The preferred method for the client to obtain an authorization grant
from the resource owner (depicted in steps (A) and (B)) is to use the
authorization server as an intermediary, which is illustrated in
Figure 3 in <a class="reference internal" href="#oauth-4-1"><em>Section 4.1</em></a>.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.2">http://tools.ietf.org/html/rfc6749#section-1.2</a> )</p>
</div>
<div class="section" id="authorization-grant">
<span id="oauth-1-3"></span><h3><a class="toc-backref" href="#id24">1.3.  Authorization Grant</a><a class="headerlink" href="#authorization-grant" title="Permalink to this headline">¶</a></h3>
<p>An <em class="xref std std-term">authorization grant</em> is a <em class="xref std std-term">credential</em>
representing the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>&#8216;s authorization
(to access its protected resources) used by the client to obtain an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>.
This specification defines four <a class="reference internal" href="#term-grant-types"><em class="xref std std-term">grant types</em></a> &#8211;
authorization code, implicit, resource owner password
credentials, and client credentials &#8211;
as well as an extensibility mechanism for defining additional types.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<dl class="glossary docutils">
<dt id="term-grant-types">grant types</dt>
<dd><ol class="first last arabic simple">
<li>authorization code</li>
<li>implicit</li>
<li>resource owner password credentials</li>
<li>client credentials</li>
</ol>
</dd>
</dl>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.3">http://tools.ietf.org/html/rfc6749#section-1.3</a> )</p>
<div class="section" id="authorization-code">
<span id="oauth-code"></span><span id="oauth-1-3-1"></span><h4><a class="toc-backref" href="#id25">1.3.1.  Authorization Code</a><a class="headerlink" href="#authorization-code" title="Permalink to this headline">¶</a></h4>
<p>The authorization code is obtained by using an authorization server
as an intermediary between the client and resource owner.  Instead of
requesting authorization directly from the resource owner, the client
directs the resource owner to an authorization server (via its
user-agent as defined in <a class="reference internal" href="oauth_meta.html#term-rfc2616"><em class="xref std std-term">[RFC2616]</em></a>), which in turn directs the
resource owner back to the client with the authorization code.</p>
<p>Before directing the resource owner back to the client with the
authorization code, the authorization server authenticates the
resource owner and obtains authorization.  Because the resource owner
only authenticates with the authorization server, the resource
owner&#8217;s credentials are never shared with the client.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>user authentication before code response</li>
</ul>
</div>
<p>The authorization code provides a few important security benefits,
such as the ability to authenticate the client, as well as the
transmission of the access token directly to the client without
passing it through the resource owner&#8217;s user-agent and potentially
exposing it to others, including the resource owner.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.3.1">http://tools.ietf.org/html/rfc6749#section-1.3.1</a> )</p>
</div>
<div class="section" id="implicit">
<span id="oauth-implicit"></span><span id="oauth-1-3-2"></span><h4><a class="toc-backref" href="#id26">1.3.2.  Implicit</a><a class="headerlink" href="#implicit" title="Permalink to this headline">¶</a></h4>
<p>The implicit grant is a simplified authorization code flow optimized
for clients implemented in a browser using a scripting language such
as <em class="xref std std-term">JavaScript</em>.
In the implicit flow,
instead of issuing the client an authorization code,
the client is issued an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> directly
(as the result of the resource owner authorization).
The grant type is implicit,
as no intermediate credentials (such as an authorization code)
are issued (and later used to obtain an access token).</p>
<p>When issuing an access token during the implicit grant flow,
the authorization server does not authenticate the client.  In some
cases, the client identity can be verified via the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>
used to deliver the access token to the client.  The access token may
be exposed to the resource owner or other applications with access to
the resource owner&#8217;s user-agent.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last">
<li><p class="first">resource requester( client ) IS not authenticated.</p>
</li>
<li><p class="first">Access token holders is valid requesters.</p>
</li>
<li><p class="first">redirection URL for tokens to be returned may be verified by tokens issuers.</p>
</li>
<li><p class="first">access tokes ARE EXPOSED to:</p>
<blockquote>
<div><ul class="simple">
<li>resource owner( end-user), because he operates his browser</li>
<li>other applications which running on the same user agent.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<p>Implicit grants improve the responsiveness and efficiency of some
clients (such as a client implemented as an in-browser application),
since it reduces the number of round trips required to obtain an
access token.
However, this convenience should be weighed against
the security implications of using implicit grants, such as those
described in Sections <a class="reference internal" href="#oauth-10-3"><em>10.3</em></a> and <a class="reference internal" href="#oauth-10-16"><em>10.16</em></a>,
especially when the authorization code grant type is available.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.3.2">http://tools.ietf.org/html/rfc6749#section-1.3.2</a> )</p>
</div>
<div class="section" id="resource-owner-password-credentials">
<span id="oauth-1-3-3"></span><h4><a class="toc-backref" href="#id27">1.3.3.  Resource Owner Password Credentials</a><a class="headerlink" href="#resource-owner-password-credentials" title="Permalink to this headline">¶</a></h4>
<p>The resource owner password credentials (i.e., username and password)
can be used directly as an authorization grant to obtain an access token.
The credentials should only be used when there is a high
degree of trust between the resource owner and the client (e.g., the
client is part of the device operating system or a highly privileged
application), and when other authorization grant types are not
available (such as an authorization code).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Resource owners store their credentials at clients</li>
<li>There MUST be tight trust relationship.</li>
</ul>
</div>
<p>Even though this grant type requires direct client access to the
resource owner credentials, the resource owner credentials are used
for a single request and are exchanged for an access token.  This
grant type can eliminate the need for the client to store the
resource owner credentials for future use, by exchanging the
credentials with a long-lived access token or refresh token.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.3.3">http://tools.ietf.org/html/rfc6749#section-1.3.3</a> )</p>
</div>
<div class="section" id="client-credentials">
<span id="oauth-1-3-4"></span><h4><a class="toc-backref" href="#id28">1.3.4.  Client Credentials</a><a class="headerlink" href="#client-credentials" title="Permalink to this headline">¶</a></h4>
<p>The client credentials
(or other forms of client authentication) can be used
as an authorization grant
when the authorization scope is limited to the protected resources
under the control of the client,
or to protected resources previously arranged with the authorization server.</p>
<p>Client credentials are used as an authorization grant
typically when the client is acting on its own behalf
(the client is also the resource owner)
or is requesting access to protected resources
based on an authorization previously arranged with the authorization server.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>when protected resoruces are uder the client&#8217;s controlls</li>
<li>when protected resources have been arrageded with authorizatio server before.</li>
<li>when a cliet are equal to the resource owner.</li>
<li><a class="reference internal" href="#oauth-4-4"><em>4.4. Client Credentials Grant</em></a></li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-1.3.4">http://tools.ietf.org/html/rfc6749#section-1.3.4</a> )</p>
</div>
</div>
<div class="section" id="access-token">
<span id="oauth-1-4"></span><h3><a class="toc-backref" href="#id29">1.4. Access Token</a><a class="headerlink" href="#access-token" title="Permalink to this headline">¶</a></h3>
<p>Access tokens are credentials used to access protected resources.
An access token is a string representing an authorization issued to the client.
The string is usually opaque to the client.
Tokens represent specific scopes and durations of access,
granted by the resource owner,
and enforced by the resource server and authorization server.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>credentials for protected resources</li>
<li>scope</li>
<li>duration</li>
<li>granted by resource owner</li>
<li>enforced by resource server &amp; authorization server</li>
</ul>
</div>
<p>The token may denote an identifier used to retrieve the authorization
information or may self-contain the authorization information in a
verifiable manner (i.e., a token string consisting of some data and a
signature).  Additional authentication credentials, which are beyond
the scope of this specification, may be required in order for the
client to use a token.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>may identifer to information</li>
<li>may contains authorization information</li>
</ul>
</div>
<p>The access token provides an abstraction layer, replacing different
authorization constructs (e.g., username and password) with a single
token understood by the resource server.  This abstraction enables
issuing access tokens more restrictive than the authorization grant
used to obtain them, as well as removing the resource server&#8217;s need
to understand a wide range of authentication methods.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>issuing token is more restrictive than authorization grant</li>
</ul>
</div>
<p>Access tokens can have different formats, structures, and methods of
utilization (e.g., cryptographic properties) based on the resource
server security requirements.  Access token attributes and the
methods used to access protected resources are beyond the scope of
this specification and are defined by companion specifications such as <a class="reference internal" href="oauth_introspect.html#term-rfc6750"><em class="xref std std-term">[RFC6750]</em></a>.</p>
<p>(<a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.4">http://tools.ietf.org/html/rfc6749.html#section-1.4</a> )</p>
</div>
<div class="section" id="refresh-token">
<span id="oauth-1-5"></span><h3><a class="toc-backref" href="#id30">1.5. Refresh Token</a><a class="headerlink" href="#refresh-token" title="Permalink to this headline">¶</a></h3>
<p>Refresh tokens are credentials used to obtain access tokens.
Refresh tokens are issued to the client by the authorization server and
are used to obtain a new access token
when the current access token becomes invalid or expires,
or to obtain additional access tokens with identical or narrower scope
(access tokens may have a shorter lifetime and fewer permissions
than authorized by the resource owner).
Issuing a refresh token is optional at the discretion of the authorization server.
If the authorization server issues a refresh token,
it is included when issuing an access token (i.e., step (D) in Figure 1).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>refresh token -&gt; access token</li>
<li>refresh token support is OPTIONAL.</li>
</ul>
</div>
<p>A refresh token is a string representing the authorization granted to
the client by the resource owner.  The string is usually opaque to
the client.  The token denotes an identifier used to retrieve the
authorization information.  Unlike access tokens, refresh tokens are
intended for use only with authorization servers and are never sent
to resource servers.</p>
<div class="highlight-python"><pre>+--------+                                           +---------------+
|        |--(A)------- Authorization Grant ---------&gt;|               |
|        |                                           |               |
|        |&lt;-(B)----------- Access Token -------------|               |
|        |               &amp; Refresh Token             |               |
|        |                                           |               |
|        |                            +----------+   |               |
|        |--(C)---- Access Token ----&gt;|          |   |               |
|        |                            |          |   |               |
|        |&lt;-(D)- Protected Resource --| Resource |   | Authorization |
| Client |                            |  Server  |   |     Server    |
|        |--(E)---- Access Token ----&gt;|          |   |               |
|        |                            |          |   |               |
|        |&lt;-(F)- Invalid Token Error -|          |   |               |
|        |                            +----------+   |               |
|        |                                           |               |
|        |--(G)----------- Refresh Token -----------&gt;|               |
|        |                                           |               |
|        |&lt;-(H)----------- Access Token -------------|               |
+--------+           &amp; Optional Refresh Token        +---------------+

             Figure 2: Refreshing an Expired Access Token</pre>
</div>
<p>The flow illustrated in Figure 2 includes the following steps:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>The client requests an access token by authenticating with the
authorization server and presenting an authorization grant.</li>
<li>The authorization server authenticates the client and validates
the authorization grant, and if valid, issues an access token
and a refresh token.</li>
<li>The client makes a protected resource request to the resource
server by presenting the access token.</li>
<li>The resource server validates the access token, and if valid,
serves the request.</li>
<li>Steps (C) and (D) repeat until the access token expires.  If the
client knows the access token expired, it skips to step (G);
otherwise, it makes another protected resource request.</li>
<li>Since the access token is invalid, the resource server returns
an invalid token error.</li>
<li>The client requests a new access token by authenticating with
the authorization server and presenting the refresh token.  The
client authentication requirements are based on the client type
and on the authorization server policies.</li>
<li>The authorization server authenticates the client and validates
the refresh token, and if valid, issues a new access token (and,
optionally, a new refresh token).</li>
</ol>
</div></blockquote>
<p>Steps (C), (D), (E), and (F) are outside the scope of this
specification, as described in <a class="reference internal" href="#oauth-7"><em>Section 7</em></a>.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.5">http://tools.ietf.org/html/rfc6749.html#section-1.5</a> )</p>
</div>
<div class="section" id="tls-version">
<span id="oauth-1-6"></span><h3><a class="toc-backref" href="#id31">1.6. TLS Version</a><a class="headerlink" href="#tls-version" title="Permalink to this headline">¶</a></h3>
<p>Whenever Transport Layer Security (TLS) is used by this
specification, the appropriate version (or versions) of TLS will vary
over time, based on the widespread deployment and known security
vulnerabilities.  At the time of this writing, TLS version 1.2
[RFC5246] is the most recent version, but has a very limited
deployment base and might not be readily available for
implementation.  TLS version 1.0 [RFC2246] is the most widely
deployed version and will provide the broadest interoperability.</p>
<p>Implementations MAY also support additional transport-layer security
mechanisms that meet their security requirements.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.6">http://tools.ietf.org/html/rfc6749.html#section-1.6</a> )</p>
</div>
<div class="section" id="http-redirections">
<span id="oauth-1-7"></span><h3><a class="toc-backref" href="#id32">1.7. HTTP Redirections</a><a class="headerlink" href="#http-redirections" title="Permalink to this headline">¶</a></h3>
<p>This specification makes extensive use of HTTP redirections, in which
the client or the authorization server directs the resource owner&#8217;s
user-agent to another destination.  While the examples in this
specification show the use of the HTTP 302 status code, any other
method available via the user-agent to accomplish this redirection is
allowed and is considered to be an implementation detail.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.7">http://tools.ietf.org/html/rfc6749.html#section-1.7</a> )</p>
</div>
<div class="section" id="interoperability">
<span id="oauth-1-8"></span><h3><a class="toc-backref" href="#id33">1.8. Interoperability</a><a class="headerlink" href="#interoperability" title="Permalink to this headline">¶</a></h3>
<p>OAuth 2.0 provides a rich authorization framework with well-defined
security properties.  However, as a rich and highly extensible
framework with many optional components, on its own, this
specification is likely to produce a wide range of non-interoperable
implementations.</p>
<p>In addition, this specification leaves a few required components
partially or fully undefined (e.g., client registration,
authorization server capabilities, endpoint discovery).  Without
these components, clients must be manually and specifically
configured against a specific authorization server and resource
server in order to interoperate.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Implements are required.</p>
<ul class="last simple">
<li>client registration</li>
<li>authorization server functions</li>
<li>discovery</li>
</ul>
</div>
<p>This framework was designed with the clear expectation that future
work will define prescriptive profiles and extensions necessary to
achieve full web-scale interoperability.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.8">http://tools.ietf.org/html/rfc6749.html#section-1.8</a> )</p>
</div>
<div class="section" id="notational-conventions">
<span id="oauth-1-9"></span><h3><a class="toc-backref" href="#id34">1.9. Notational Conventions</a><a class="headerlink" href="#notational-conventions" title="Permalink to this headline">¶</a></h3>
<p>The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;,
&#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this
specification are to be interpreted as described in [RFC2119].</p>
<p>This specification uses the Augmented Backus-Naur Form (ABNF)
notation of [RFC5234].  Additionally, the rule URI-reference is
included from &#8220;Uniform Resource Identifier (URI): Generic Syntax&#8221;
[RFC3986].</p>
<p>Certain security-related terms are to be understood in the sense
defined in [RFC4949].  These terms include, but are not limited to,
&#8220;attack&#8221;, &#8220;authentication&#8221;, &#8220;authorization&#8221;, &#8220;certificate&#8221;,
&#8220;confidentiality&#8221;, &#8220;credential&#8221;, &#8220;encryption&#8221;, &#8220;identity&#8221;, &#8220;sign&#8221;,
&#8220;signature&#8221;, &#8220;trust&#8221;, &#8220;validate&#8221;, and &#8220;verify&#8221;.</p>
<p>Unless otherwise noted, all the protocol parameter names and values
are case sensitive.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-1.9">http://tools.ietf.org/html/rfc6749.html#section-1.9</a> )</p>
</div>
</div>
<div class="section" id="client-registration">
<span id="oauth-2"></span><h2><a class="toc-backref" href="#id35">2. Client Registration</a><a class="headerlink" href="#client-registration" title="Permalink to this headline">¶</a></h2>
<p>Before initiating the protocol,
the <a class="reference internal" href="#term-client"><em class="xref std std-term">client</em></a> registers with the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.
The means through which the client registers
with the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> are beyond the scope of this specification
but typically involve end-user interaction with an HTML registration form.</p>
<p>Client registration does not require a direct interaction between the
client and the authorization server.
When supported by the authorization server,
registration can rely on other means for
establishing trust and obtaining the required client properties
(e.g., redirection URI, client type).
For example,
registration can be accomplished using a self-issued or third-party-issued assertion,
or by the authorization server performing client discovery using a
trusted channel.</p>
<p>When registering a client, the client developer SHALL:</p>
<ul class="simple">
<li>specify the <em class="xref std std-term">client type</em> as described in <a class="reference internal" href="#oauth-2-1"><em>Section 2.1</em></a>,</li>
<li>provide its <em class="xref std std-term">client redirection URIs</em> as described in <a class="reference internal" href="#oauth-3-1-2"><em>Section 3.1.2</em></a>,
and</li>
<li>include any other information required by the authorization server
(e.g., <em class="xref std std-term">application name</em>, website, description, logo image, the
acceptance of legal terms).</li>
</ul>
<p>(<a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2">http://tools.ietf.org/html/rfc6749.html#section-2</a>)</p>
<div class="section" id="client-types">
<span id="oauth-2-1"></span><h3><a class="toc-backref" href="#id36">2.1. Client Types</a><a class="headerlink" href="#client-types" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>no assumption for client type. must check</li>
</ul>
</div>
<p>OAuth defines two <em class="xref std std-term">client types</em>,
based on their ability to authenticate securely
with the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
(i.e., ability to maintain the confidentiality of their client credentials):</p>
<dl class="glossary docutils">
<dt id="term-confidential">confidential</dt>
<dd>Clients capable of maintaining the confidentiality of their
credentials (e.g., client implemented on a secure server with
restricted access to the client credentials), or capable of secure
client authentication using other means.</dd>
<dt id="term-public">public</dt>
<dd>Clients incapable of maintaining the confidentiality of their
credentials (e.g., clients executing on the device used by the
resource owner, such as an installed native application or a web
browser-based application), and incapable of secure client
authentication via any other means.</dd>
</dl>
<p>The <em class="xref std std-term">client type</em> designation is based on
the authorization server&#8217;s definition of secure authentication
and its acceptable exposure levels of client credentials.
The authorization server SHOULD NOT make assumptions about the client type.</p>
<p>A client may be implemented as a distributed set of components,
each with a different client type and security context
(e.g., a distributed client with both a confidential server-based component
and a public browser-based component).
If the authorization server does not provide support
for such clients or does not provide guidance
with regard to their registration,
the client SHOULD register each component as a separate client.</p>
<p>This specification has been designed around the following <em class="xref std std-term">client profiles</em>:</p>
<dl class="glossary docutils">
<dt id="term-web-application">web application</dt>
<dd><p class="first">A web application is a <a class="reference internal" href="#term-confidential"><em class="xref std std-term">confidential</em></a> client
running on a web server.</p>
<p>Resource owners access the client via an HTML user
interface rendered in a user-agent on the device used by the
resource owner.</p>
<p class="last">The client credentials as well as any access token
issued to the client are stored on the web server and
are not exposed to or accessible by the resource owner.</p>
</dd>
<dt id="term-user-agent-based-application">user-agent-based application</dt>
<dd>A user-agent-based application is a <a class="reference internal" href="#term-public"><em class="xref std std-term">public</em></a> client in which the
client code is downloaded from a web server and executes within a
user-agent (e.g., web browser) on the device used by the resource
owner.  Protocol data and credentials are easily accessible (and
often visible) to the resource owner.  Since such applications
reside within the user-agent, they can make seamless use of the
user-agent capabilities when requesting authorization.</dd>
<dt id="term-native-application">native application</dt>
<dd><p class="first">A native application is a <a class="reference internal" href="#term-public"><em class="xref std std-term">public</em></a> client
installed and executed on the device used by the resource owner.</p>
<p class="last">Protocol data and credentials are accessible to the resource owner.
It is assumed that any client authentication credentials included in the
application can be extracted.  On the other hand, dynamically
issued credentials such as access tokens or refresh tokens can
receive an acceptable level of protection.  At a minimum, these
credentials are protected from hostile servers with which the
application may interact.  On some platforms, these credentials
might be protected from other applications residing on the same
device.</p>
</dd>
</dl>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.1">http://tools.ietf.org/html/rfc6749.html#section-2.1</a> )</p>
</div>
<div class="section" id="client-identifier">
<span id="oauth-2-2"></span><h3><a class="toc-backref" href="#id37">2.2. Client Identifier</a><a class="headerlink" href="#client-identifier" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> issues the registered client
a client identifier &#8211; a unique string representing the registration
information provided by the client.
The client identifier is not a secret;
it is exposed to the resource owner and MUST NOT be used
alone for client authentication.
The client identifier is unique to the authorization server.</p>
<p>The client identifier string size is left undefined by this specification.
The client should avoid making assumptions about the
identifier size.
The authorization server SHOULD document the size of any identifier it issues.</p>
<dl class="glossary docutils">
<dt id="term-client-identifier">Client Identifier</dt>
<dd><ul class="first last simple">
<li>issued by authorization server</li>
<li>unique in the server</li>
<li>not secert, do not use as authentication credential by itself.</li>
<li>size of identfiiers SHOULD be documented.</li>
</ul>
</dd>
</dl>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.2">http://tools.ietf.org/html/rfc6749.html#section-2.2</a> )</p>
</div>
<div class="section" id="client-authentication">
<span id="oauth-2-3"></span><h3><a class="toc-backref" href="#id38">2.3. Client Authentication</a><a class="headerlink" href="#client-authentication" title="Permalink to this headline">¶</a></h3>
<p>If the client type is confidential,
the client and authorization
server establish a client authentication method suitable for the
security requirements of the authorization server.  The authorization
server MAY accept any form of client authentication meeting its
security requirements.</p>
<p>Confidential clients are typically issued (or establish) a set of
client credentials used for authenticating with the authorization
server (e.g., password, public/private key pair).</p>
<p>The authorization server MAY establish a client authentication method
with public clients.
However, the authorization server MUST NOT rely on public client authentication
for the purpose of identifying the client.</p>
<p>The client MUST NOT use more than one authentication method in each request.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Basic authentication MUST be support <a class="reference internal" href="#oauth-2-3-1"><em>2.3.1. Client Password</em></a>.</li>
<li>OpenID Connect documents client authentication in <tt class="xref doc docutils literal"><span class="pre">discvoery</span></tt>.</li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.3">http://tools.ietf.org/html/rfc6749.html#section-2.3</a> )</p>
<div class="section" id="client-password">
<span id="oauth-2-3-1"></span><h4><a class="toc-backref" href="#id39">2.3.1. Client Password</a><a class="headerlink" href="#client-password" title="Permalink to this headline">¶</a></h4>
<p>Clients in possession of a client password MAY use the HTTP Basic
authentication scheme as defined in <a class="reference internal" href="#term-rfc2617"><em class="xref std std-term">[RFC2617]</em></a> to authenticate with
the authorization server.  The client identifier is encoded using the
&#8220;application/x-www-form-urlencoded&#8221; encoding algorithm per
Appendix B, and the encoded value is used as the username; the client
password is encoded using the same algorithm and used as the
password.  The authorization server MUST support the HTTP Basic
authentication scheme for authenticating clients that were issued a
client password.</p>
<p>For example (with extra line breaks for display purposes only):</p>
<div class="highlight-python"><pre>Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3</pre>
</div>
<p>Alternatively, the authorization server MAY support including the
client credentials in the request-body using the following
parameters:</p>
<dl class="glossary docutils">
<dt id="term-client-id">client_id</dt>
<dd>REQUIRED.  The client identifier issued to the client during
the registration process described by Section 2.2.</dd>
<dt id="term-client-secret">client_secret</dt>
<dd>REQUIRED.  The client secret.  The client MAY omit the
parameter if the client secret is an empty string.</dd>
</dl>
<p>Including the client credentials in the request-body using the two
parameters is NOT RECOMMENDED and SHOULD be limited to clients unable
to directly utilize the HTTP Basic authentication scheme (or other
password-based HTTP authentication schemes).  The parameters can only
be transmitted in the request-body and MUST NOT be included in the
request URI.</p>
<p>For example, a request to refresh an access token (Section 6) using
the body parameters (with extra line breaks for display purposes
only):</p>
<div class="highlight-python"><pre>POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw</pre>
</div>
<p>The authorization server MUST require the use of TLS as described in
<a class="reference internal" href="#oauth-1-6"><em>Section 1.6</em></a> when sending requests using password authentication.</p>
<p>Since this client authentication method involves a password, the
authorization server MUST protect any endpoint utilizing it against
brute force attacks.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.3.1">http://tools.ietf.org/html/rfc6749.html#section-2.3.1</a> )</p>
<p id="oauth-2-3-2">2.3.2. Other Authentication Methods</p>
<p>The authorization server MAY support any suitable HTTP authentication
scheme matching its security requirements.  When using other
authentication methods, the authorization server MUST define a
mapping between the client identifier (registration record) and
authentication scheme.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>OpenID Connect documents client authentication methods in <a class="reference internal" href="discovery.html"><em>OpenID Connect Discovery 1.0</em></a>.</li>
</ul>
</div>
<p>(<a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.3.1">http://tools.ietf.org/html/rfc6749.html#section-2.3.1</a> )</p>
</div>
</div>
<div class="section" id="unregistered-clients">
<span id="oauth-2-4"></span><h3><a class="toc-backref" href="#id40">2.4. Unregistered Clients</a><a class="headerlink" href="#unregistered-clients" title="Permalink to this headline">¶</a></h3>
<p>This specification does not exclude the use of unregistered clients.
However, the use of such clients is beyond the scope of this
specification and requires additional security analysis and review of
its interoperability impact</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-2.4">http://tools.ietf.org/html/rfc6749.html#section-2.4</a> )</p>
</div>
</div>
<div class="section" id="protocol-endpoints">
<span id="oauth-3"></span><h2><a class="toc-backref" href="#id41">3. Protocol Endpoints</a><a class="headerlink" href="#protocol-endpoints" title="Permalink to this headline">¶</a></h2>
<p>The authorization process utilizes two authorization server endpoints
(HTTP resources):</p>
<blockquote>
<div><ul class="simple">
<li>Authorization endpoint - used by the client to obtain
authorization from the resource owner via user-agent redirection.</li>
<li>Token endpoint - used by the client to exchange an authorization
grant for an access token, typically with client authentication.</li>
</ul>
</div></blockquote>
<p>As well as one client endpoint:</p>
<blockquote>
<div><ul class="simple">
<li>Redirection endpoint - used by the authorization server to return
responses containing authorization credentials to the client via
the resource owner user-agent.</li>
</ul>
</div></blockquote>
<p>Not every authorization grant type utilizes both endpoints.
Extension grant types MAY define additional endpoints as needed.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3">http://tools.ietf.org/html/rfc6749.html#section-3</a> )</p>
<div class="section" id="authorization-endpoint">
<span id="oauth-3-1"></span><h3><a class="toc-backref" href="#id42">3.1. Authorization Endpoint</a><a class="headerlink" href="#authorization-endpoint" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>verify resource owner identity</li>
<li>Discovery of the endpoint</li>
<li>POST or GET</li>
<li>TLS</li>
<li>Paremeters</li>
</ul>
</div>
<p>The <a class="reference internal" href="oauth_responses.html#term-authorization-endpoint"><em class="xref std std-term">authorization endpoint</em></a> is used to interact
with the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a> and obtain an <em class="xref std std-term">authorization grant</em>.</p>
<p>The authorization server MUST first verify the identity of the resource owner.
The way in which the authorization server authenticates the resource owner
(e.g., username and password login, session cookies)
is beyond the scope of this specification.</p>
<p>The means through which the client obtains the location of
the authorization endpoint are beyond the scope of this specification,
but the location is typically provided in the service documentation.</p>
<p>The endpoint URI MAY include an &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221;
formatted (per Appendix B) <a class="reference internal" href="glossary.html#term-query-component"><em class="xref std std-term">query component</em></a>
(<a class="reference internal" href="#term-rfc3986"><em class="xref std std-term">[RFC3986]</em></a> <em class="xref std std-ref">Section 3.4</em>),
which MUST be retained when adding additional query parameters.
The endpoint URI MUST NOT include a fragment component.</p>
<p>Since requests to the authorization endpoint result in user authentication
and the transmission of clear-text credentials
(in the HTTP response),
the authorization server MUST require the use of TLS
as described in <a class="reference internal" href="#oauth-1-6"><em>Section 1.6</em></a>
when sending requests to the authorization endpoint.</p>
<p>The authorization server MUST support the use of the HTTP &#8220;GET&#8221;
method <a class="reference internal" href="oauth_meta.html#term-rfc2616"><em class="xref std std-term">[RFC2616]</em></a> for the authorization endpoint and
MAY support the use of the &#8220;POST&#8221; method as well.</p>
<p>Parameters sent without a value MUST be treated
as if they were omitted from the request.
The authorization server MUST ignore unrecognized request parameters.
Request and response parameters MUST NOT be included more than once.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1">http://tools.ietf.org/html/rfc6749.html#section-3.1</a> )</p>
<div class="section" id="response-type">
<span id="oauth-response-type"></span><span id="oauth-3-1-1"></span><h4><a class="toc-backref" href="#id43">3.1.1. Response Type</a><a class="headerlink" href="#response-type" title="Permalink to this headline">¶</a></h4>
<p>The authorization endpoint is used by the authorization code grant
type and implicit grant type flows.  The client informs the
authorization server of the desired grant type using the following
parameter:</p>
<dl class="glossary docutils">
<dt id="term-response-type">response_type</dt>
<dd><p class="first">REQUIRED.</p>
<p class="last">The value MUST be one of &#8220;<strong>code</strong>&#8221; for requesting
an <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> as described by <a class="reference internal" href="#oauth-4-1-1"><em>Section 4.1.1</em></a>,
&#8220;<strong>token</strong>&#8221; for requesting an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> (<em class="xref std std-term">implicit grant</em>)
as described by <a class="reference internal" href="#oauth-4-2-1"><em>Section 4.2.1</em></a>,
or a <strong>registered extension value</strong> as described by <a class="reference internal" href="#oauth-8-4"><em>Section 8.4</em></a>.</p>
</dd>
</dl>
<p>Extension response types MAY contain a space-delimited (%x20) list of values,
where the order of values does not matter
(e.g., response type &#8220;a b&#8221; is the same as &#8220;b a&#8221;).
The meaning of such <strong>composite response types</strong> is defined by their respective specifications.</p>
<p>If an authorization request is missing the &#8220;<a class="reference internal" href="#term-42"><em class="xref std std-term">response_type</em></a>&#8221; parameter,
or if the response type is not understood,
the authorization server MUST return an error response as described in <em class="xref std std-term">Section 4.1.2.1</em>.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.1">http://tools.ietf.org/html/rfc6749.html#section-3.1.1</a> )</p>
</div>
<div class="section" id="redirection-endpoint">
<span id="oauth-redirect-uri"></span><span id="oauth-3-1-2"></span><h4><a class="toc-backref" href="#id44">3.1.2. Redirection Endpoint</a><a class="headerlink" href="#redirection-endpoint" title="Permalink to this headline">¶</a></h4>
<p>After completing its interaction with the resource owner,
the authorization server directs the resource owner&#8217;s user-agent
back to the client.
The authorization server redirects the user-agent
to the client&#8217;s redirection endpoint
previously established with the authorization server
during the <a class="reference internal" href="glossary.html#term-client-registration"><em class="xref std std-term">client registration</em></a> process
or when making the <a class="reference internal" href="glossary.html#term-authorization-request"><em class="xref std std-term">authorization request</em></a>.</p>
<p>The redirection endpoint URI MUST be an absolute URI
as defined by [RFC3986] Section 4.3.
The endpoint URI MAY include an &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221; formatted
(per Appendix B) query component ([RFC3986] Section 3.4),
which MUST be retained when adding additional query parameters.
The endpoint URI MUST NOT include a fragment component.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2">http://tools.ietf.org/html/rfc6749.html#section-3.1.2</a> )</p>
<div class="section" id="endpoint-request-confidentiality">
<span id="oauth-3-1-2-1"></span><h5><a class="toc-backref" href="#id45">3.1.2.1. Endpoint Request Confidentiality</a><a class="headerlink" href="#endpoint-request-confidentiality" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>TLS</li>
<li>otherwise NOTICE to the resource owner</li>
</ul>
</div>
<p>The redirection endpoint SHOULD require the use of TLS
as described in <a class="reference internal" href="#oauth-1-6"><em>Section 1.6</em></a>
when the requested response type is &#8220;code&#8221; or &#8220;token&#8221;,
or when the redirection request will result in the transmission of sensitive credentials over an open network.</p>
<p>This specification does not mandate the use of TLS
because at the time of this writing, requiring clients to deploy TLS is a significant hurdle
for many client developers.
If TLS is not available,
the authorization server SHOULD warn the resource owner
about the insecure endpoint prior to redirection
(e.g., display a message during the authorization request).</p>
<p>Lack of transport-layer security can have a severe impact on the
security of the client and the protected resources it is authorized
to access.  The use of transport-layer security is particularly
critical when the authorization process is used as a form of
delegated end-user authentication by the client (e.g., third-party
sign-in service).</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2.1">http://tools.ietf.org/html/rfc6749.html#section-3.1.2.1</a> )</p>
</div>
<div class="section" id="registration-requirements">
<span id="oauth-3-1-2-2"></span><h5><a class="toc-backref" href="#id46">3.1.2.2. Registration Requirements</a><a class="headerlink" href="#registration-requirements" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<ul class="last simple">
<li><strong>IMPORTANT</strong> : regisiter redirect URI, just in case.</li>
</ul>
</div>
<p>The authorization server MUST require the following clients to
register their redirection endpoint:</p>
<blockquote>
<div><ul class="simple">
<li>Public clients.</li>
<li>Confidential clients utilizing the implicit grant type.</li>
</ul>
</div></blockquote>
<p>The authorization server SHOULD require all clients to register their
redirection endpoint prior to utilizing the authorization endpoint.</p>
<p>The authorization server SHOULD require the client
to provide the complete redirection URI
(the client MAY use the &#8220;state&#8221; request parameter to achieve per-request customization).
If requiring the registration of the complete redirection URI is not possible,
the authorization server SHOULD require the registration of the URI scheme,
authority, and path (allowing the client to dynamically vary
only the query component of the redirection URI when requesting
authorization).</p>
<p>The authorization server MAY allow the client to register multiple
redirection endpoints.</p>
<p>Lack of a redirection URI registration requirement can enable an
attacker to use the authorization endpoint as an open redirector as
described in Section 10.15.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2.2">http://tools.ietf.org/html/rfc6749.html#section-3.1.2.2</a>  )</p>
</div>
<div class="section" id="dynamic-configuration">
<span id="oauth-3-1-2-3"></span><h5><a class="toc-backref" href="#id47">3.1.2.3. Dynamic Configuration</a><a class="headerlink" href="#dynamic-configuration" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>redirect_uri of authreq</li>
<li>comparison !</li>
</ul>
</div>
<p>If multiple redirection URIs have been registered, if only part of
the redirection URI has been registered, or if no redirection URI has
been registered, the client MUST include a redirection URI with the
authorization request using the &#8220;<em class="xref std std-ref">redirect_uri</em>&#8221; request parameter.</p>
<p>When a redirection URI is included in an authorization request,
the authorization server MUST compare and match the value received against
at least one of the registered redirection URIs
(or URI components) as defined in [RFC3986] Section 6,
if any redirection URIs were registered.
If the client registration included the full redirection URI,
the authorization server MUST compare the two URIs
using simple string comparison as defined in [RFC3986] Section 6.2.1.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2.3">http://tools.ietf.org/html/rfc6749.html#section-3.1.2.3</a> )</p>
</div>
<div class="section" id="invalid-endpoint">
<span id="oauth-3-1-2-4"></span><h5><a class="toc-backref" href="#id48">3.1.2.4. Invalid Endpoint</a><a class="headerlink" href="#invalid-endpoint" title="Permalink to this headline">¶</a></h5>
<p>If an authorization request fails validation due to a missing,
invalid, or mismatching redirection URI, the authorization server
SHOULD inform the resource owner of the error and MUST NOT
automatically redirect the user-agent to the invalid redirection URI.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2.4">http://tools.ietf.org/html/rfc6749.html#section-3.1.2.4</a> )</p>
</div>
<div class="section" id="endpoint-content">
<span id="oauth-3-1-2-5"></span><h5><a class="toc-backref" href="#id49">3.1.2.5. Endpoint Content</a><a class="headerlink" href="#endpoint-content" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<ul class="last simple">
<li>NO 3rd party script or others in HTML of redirect_uri</li>
</ul>
</div>
<p>The redirection request to the client&#8217;s endpoint typically results in
an HTML document response, processed by the user-agent.
If the HTML response is served directly as the result of the redirection request,
any script included in the HTML document will execute with full
access to the redirection URI and the credentials it contains.</p>
<p>The client SHOULD NOT include any third-party scripts
(e.g., third-party analytics, social plug-ins, ad networks)
in the redirection endpoint response.</p>
<p>Instead,
it SHOULD extract the credentials from the URI and redirect the user-agent
again to another endpoint without exposing the credentials (in the URI or elsewhere).
If third-party scripts are included,
the client MUST ensure that its own scripts
(used to extract and remove the credentials from the URI) will execute first.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.1.2.5">http://tools.ietf.org/html/rfc6749.html#section-3.1.2.5</a> )</p>
</div>
</div>
</div>
<div class="section" id="token-endpoint">
<span id="oauth-token-endpoint"></span><span id="oauth-3-2"></span><h3><a class="toc-backref" href="#id50">3.2. Token Endpoint</a><a class="headerlink" href="#token-endpoint" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>access token  &lt;- code /refresh token</li>
<li>discovery</li>
<li>URIにfragment入れるな</li>
<li>TLS</li>
<li>かならずPOST</li>
</ul>
</div>
<p>The token endpoint is used by the client to obtain an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> by
presenting its <em class="xref std std-term">authorization grant</em> or <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a>.
The token endpoint is used with every authorization grant except for the
implicit grant type (since an access token is issued directly).</p>
<p>The means through which the client obtains the location of the
token endpoint are beyond the scope of this specification,
but the location is typically provided in the service documentation.</p>
<p>The endpoint URI MAY include an &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221;
formatted (per Appendix B) query component ([RFC3986] Section 3.4),
which MUST be retained when adding additional query parameters.
The endpoint URI MUST NOT include a <em class="xref std std-term">fragment component</em>.</p>
<p>Since requests to the token endpoint result in
the transmission of clear-text credentials
(in the HTTP request and response),
the authorization server MUST require the use of TLS as described in Section 1.6
when sending requests to the token endpoint.</p>
<p>The client MUST use the HTTP &#8220;POST&#8221; method when making <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> requests.</p>
<p>Parameters sent without a value MUST be treated
as if they were omitted from the request.
The authorization server MUST ignore unrecognized request parameters.
Request and response parameters MUST NOT be included more than once.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.2">http://tools.ietf.org/html/rfc6749.html#section-3.2</a> )</p>
<div class="section" id="oauth-client-authentication">
<span id="oauth-3-2-1"></span><span id="id2"></span><h4><a class="toc-backref" href="#id51">3.2.1. Client Authentication</a><a class="headerlink" href="#oauth-client-authentication" title="Permalink to this headline">¶</a></h4>
<p>Confidential clients or other clients issued client credentials MUST
authenticate with the authorization server as described in
<a class="reference internal" href="#oauth-2-3"><em>Section 2.3</em></a> when making requests to the token endpoint.  Client
authentication is used for:</p>
<blockquote>
<div><ul class="simple">
<li>Enforcing the binding of refresh tokens and authorization codes to
the client they were issued to.  Client authentication is critical
when an authorization code is transmitted to the redirection
endpoint over an insecure channel or when the redirection URI has
not been registered in full.</li>
<li>Recovering from a compromised client by disabling the client or
changing its credentials, thus preventing an attacker from abusing
stolen refresh tokens.  Changing a single set of client
credentials is significantly faster than revoking an entire set of
refresh tokens.</li>
<li>Implementing authentication management best practices, which
require periodic credential rotation.  Rotation of an entire set
of refresh tokens can be challenging, while rotation of a single
set of client credentials is significantly easier.</li>
</ul>
</div></blockquote>
<p>A client MAY use the &#8220;<em class="xref std std-term">client_id&#8221;</em> request parameter
to identify itself when sending requests to the <a class="reference internal" href="uma_core.html#term-token-endpoint"><em class="xref std std-term">token endpoint</em></a>.</p>
<p>In the &#8220;<a class="reference internal" href="glossary.html#term-341"><em class="xref std std-term">authorization_code</em></a>&#8221; &#8220;<a class="reference internal" href="#term-67"><em class="xref std std-term">grant_type</em></a>&#8221; request to the <a class="reference internal" href="uma_core.html#term-token-endpoint"><em class="xref std std-term">token endpoint</em></a>,
an unauthenticated client MUST send its &#8220;<a class="reference internal" href="oauth_introspect.html#term-client-id"><em class="xref std std-term">client_id</em></a>&#8221; to prevent itself
from inadvertently accepting a <a class="reference internal" href="#term-39"><em class="xref std std-term">code</em></a> intended for a client with a different &#8220;<em class="xref std std-term">client_id&#8221;</em>.
This protects the client from substitution of the authentication code.
(It provides no additional security for the protected resource.)</p>
<p>( <span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a> )</p>
</div>
</div>
<div class="section" id="access-token-scope">
<span id="oauth-3-3"></span><h3><a class="toc-backref" href="#id52">3.3. Access Token Scope</a><a class="headerlink" href="#access-token-scope" title="Permalink to this headline">¶</a></h3>
<p>The authorization and token endpoints allow the client to specify the
scope of the access request using the &#8220;scope&#8221; request parameter.  In
turn, the authorization server uses the &#8220;scope&#8221; response parameter to
inform the client of the scope of the access token issued.</p>
<p>The value of the scope parameter is expressed as a list of space-
delimited, case-sensitive strings.  The strings are defined by the
authorization server.  If the value contains multiple space-delimited
strings, their order does not matter, and each string adds an
additional access range to the requested scope.</p>
<div class="highlight-python"><pre>scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span>
<span class="go">&#39;!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x23</span><span class="p">,</span><span class="mh">0x5B</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go"># $ % &amp; &#39; ( ) * + , - . /</span>
<span class="go">0 1 2 3 4 5 6 7 8 9</span>
<span class="go">: ; &lt; = &gt; ? @</span>
<span class="go">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x5D</span><span class="p">,</span><span class="mh">0x7E</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
<span class="gp">...</span>
<span class="go">] ^ _ `</span>
<span class="go">a b c d e f g h i j k l m n o p q r s t u v w x y z</span>
<span class="go">{ | } ~</span>
</pre></div>
</div>
</div>
<p>The authorization server MAY fully
or partially ignore the scope requested by the client,
based on the authorization server policy or
the resource owner&#8217;s instructions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Scope Policy on Authorizaton Server</li>
</ul>
</div>
<p>If the issued access token scope is different from the one requested by the client,
the authorization server MUST include the &#8220;scope&#8221; response parameter
to inform the client of the actual scope granted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>cases where &#8220;scope&#8221; MUST be returned</li>
</ul>
</div>
<p>If the client omits the scope parameter when requesting
authorization, the authorization server MUST either process the
request using a pre-defined default value
or fail the request indicating an invalid scope.
The authorization server SHOULD document its scope requirements
and default value (if defined).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Supporting Scopes Advertisement</li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-3.3">http://tools.ietf.org/html/rfc6749.html#section-3.3</a> )</p>
</div>
</div>
<div class="section" id="obtaining-authorization">
<span id="oauth-4"></span><h2><a class="toc-backref" href="#id53">4. Obtaining Authorization</a><a class="headerlink" href="#obtaining-authorization" title="Permalink to this headline">¶</a></h2>
<p>To request an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a>,
the client obtains authorization from the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>.</p>
<p>The authorization is expressed in the form of an <em class="xref std std-term">authorization grant</em>,
which the client uses to request the access token.</p>
<p>OAuth defines four grant types: <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a>, <a class="reference internal" href="openid_connect.html#term-implicit"><em class="xref std std-term">implicit</em></a>,
<em class="xref std std-term">resource owner password credentials</em>, and <a class="reference internal" href="glossary.html#term-client-credentials"><em class="xref std std-term">client credentials</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="#oauth-4-1"><em>4.1. Authorization Code Grant</em></a></li>
<li><em class="xref std std-ref">oauth.4.2</em></li>
<li><a class="reference internal" href="#oauth-4-3"><em>4.3. Resource Owner Password Credentials Grant</em></a></li>
<li><a class="reference internal" href="#oauth-4-4"><em>4.4. Client Credentials Grant</em></a></li>
</ul>
</div>
<p>It also provides an extension mechanism for defining additional grant types.</p>
<p>( <span class="target" id="index-4"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a> , <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4">http://tools.ietf.org/html/rfc6749.html#section-4</a> )</p>
<div class="section" id="authorization-code-grant">
<span id="oauth-4-1"></span><h3><a class="toc-backref" href="#id54">4.1. Authorization Code Grant</a><a class="headerlink" href="#authorization-code-grant" title="Permalink to this headline">¶</a></h3>
<p>The authorization code grant type is used to obtain both access
tokens and refresh tokens and is optimized for confidential clients.
Since this is a redirection-based flow, the client must be capable of
interacting with the resource owner&#8217;s user-agent (typically a web
browser) and capable of receiving incoming requests (via redirection)
from the authorization server.</p>
<div class="highlight-python"><pre>+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier      +---------------+
|         -+----(A)-- &amp; Redirection URI ----&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
|          |                                 |               |
|         -+----(C)-- Authorization Code ---&lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 (A)  (C)                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&gt;---(D)-- Authorization Code ---------'      |
|  Client |          &amp; Redirection URI                  |
|         |                                             |
|         |&lt;---(E)----- Access Token -------------------'
+---------+       (w/ Optional Refresh Token)

Note: The lines illustrating steps (A), (B), and (C) are broken into
two parts as they pass through the user-agent.

                Figure 3: Authorization Code Flow</pre>
</div>
<p>The flow illustrated in Figure 3 includes the following steps:</p>
<ol class="upperalpha simple">
<li>The client initiates the flow by directing the resource owner&#8217;s
user-agent to the authorization endpoint.  The client includes
its client identifier, requested scope, local state, and a
redirection URI to which the authorization server will send the
user-agent back once access is granted (or denied).</li>
<li>The authorization server authenticates the resource owner (via
the user-agent) and establishes whether the resource owner
grants or denies the client&#8217;s access request.</li>
<li>Assuming the resource owner grants access, the authorization
server redirects the user-agent back to the client using the
redirection URI provided earlier (in the request or during
client registration).  The redirection URI includes an
authorization code and any local state provided by the client
earlier.</li>
<li>The client requests an access token from the authorization
server&#8217;s token endpoint by including the authorization code
received in the previous step.  When making the request, the
client authenticates with the authorization server.  The client
includes the redirection URI used to obtain the authorization
code for verification.</li>
<li>The authorization server authenticates the client, validates the
authorization code, and ensures that the redirection URI
received matches the URI used to redirect the client in
step (C).  If valid, the authorization server responds back with
an access token and, optionally, a refresh token.</li>
</ol>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1">http://tools.ietf.org/html/rfc6749.html#section-4.1</a> )</p>
<div class="section" id="authorization-request">
<span id="oauth-4-1-1"></span><h4><a class="toc-backref" href="#id55">4.1.1. Authorization Request</a><a class="headerlink" href="#authorization-request" title="Permalink to this headline">¶</a></h4>
<p>The client constructs the request URI by adding the following
parameters to the query component of the authorization endpoint URI
using the &#8220;application/x-www-form-urlencoded&#8221; format, per Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-20">response_type</dt>
<dd>REQUIRED.  Value MUST be set to &#8220;code&#8221;.</dd>
<dt id="term-21">client_id</dt>
<dd>REQUIRED.  The client identifier as described in Section 2.2.</dd>
<dt id="term-redirect-uri">redirect_uri</dt>
<dd>OPTIONAL.  As described in Section 3.1.2.</dd>
<dt id="term-scope">scope</dt>
<dd><p class="first"><strong>OPTIONAL</strong>.</p>
<p class="last">The scope of the access request as described by <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>.</p>
</dd>
<dt id="term-state">state</dt>
<dd>RECOMMENDED.  An opaque value used by the client to maintain
state between the request and callback.  The authorization
server includes this value when redirecting the user-agent back
to the client.  The parameter SHOULD be used for preventing
cross-site request forgery as described in Section 10.12.</dd>
</dl>
<p>The client directs the resource owner to the constructed URI using an
HTTP redirection response, or by other means available to it via the
user-agent.</p>
<p>For example, the client directs the user-agent to make the following
HTTP request using TLS (with extra line breaks for display purposes
only):</p>
<div class="highlight-python"><pre>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com</pre>
</div>
<p>The authorization server validates the request to ensure that all
required parameters are present and valid.  If the request is valid,
the authorization server authenticates the resource owner and obtains
an authorization decision (by asking the resource owner or by
establishing approval via other means).</p>
<p>When a decision is established, the authorization server directs the
user-agent to the provided client redirection URI using an HTTP
redirection response, or by other means available to it via the
user-agent.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1.1">http://tools.ietf.org/html/rfc6749.html#section-4.1.1</a> )</p>
</div>
<div class="section" id="authorization-response">
<span id="oauth-4-1-2"></span><h4><a class="toc-backref" href="#id56">4.1.2. Authorization Response</a><a class="headerlink" href="#authorization-response" title="Permalink to this headline">¶</a></h4>
<p>If the resource owner grants the access request, the authorization
server issues an authorization code and delivers it to the client by
adding the following parameters to the query component of the
redirection URI using the &#8220;application/x-www-form-urlencoded&#8221; format,
per Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-code">code</dt>
<dd>REQUIRED.  The authorization code generated by the
authorization server.  The authorization code MUST expire
shortly after it is issued to mitigate the risk of leaks.  A
maximum authorization code lifetime of 10 minutes is
RECOMMENDED.  The client MUST NOT use the authorization code
more than once.  If an authorization code is used more than
once, the authorization server MUST deny the request and SHOULD
revoke (when possible) all tokens previously issued based on
that authorization code.  The authorization code is bound to
the client identifier and redirection URI.</dd>
<dt id="term-26">state</dt>
<dd>REQUIRED if the &#8220;state&#8221; parameter was present in the client
authorization request.  The exact value received from the
client.</dd>
</dl>
<p>For example, the authorization server redirects the user-agent by
sending the following HTTP response:</p>
<div class="highlight-python"><pre>HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
          &amp;state=xyz</pre>
</div>
<p>The client MUST ignore unrecognized response parameters.  The
authorization code string size is left undefined by this
specification.  The client should avoid making assumptions about code
value sizes.  The authorization server SHOULD document the size of
any value it issues.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1.2">http://tools.ietf.org/html/rfc6749.html#section-4.1.2</a> )</p>
<div class="section" id="error-response">
<span id="oauth-4-1-2-1"></span><h5><a class="toc-backref" href="#id57">4.1.2.1. Error Response</a><a class="headerlink" href="#error-response" title="Permalink to this headline">¶</a></h5>
<p>If the request fails due to a missing, invalid, or mismatching
redirection URI, or if the client identifier is missing or invalid,
the authorization server SHOULD inform the resource owner of the
error and MUST NOT automatically redirect the user-agent to the
invalid redirection URI.</p>
<p>If the resource owner denies the access request or if the request
fails for reasons other than a missing or invalid redirection URI,
the authorization server informs the client by adding the following
parameters to the query component of the redirection URI using the
&#8220;application/x-www-form-urlencoded&#8221; format, per Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-error">error</dt>
<dd><p class="first">REQUIRED.  A single ASCII [USASCII] error code from the
following:</p>
<dl class="glossary docutils">
<dt id="term-invalid-request">invalid_request</dt>
<dd>The request is missing a required parameter, includes an
invalid parameter value, includes a parameter more than
once, or is otherwise malformed.</dd>
<dt id="term-unauthorized-client">unauthorized_client</dt>
<dd>The client is not authorized to request an authorization
code using this method.</dd>
<dt id="term-access-denied">access_denied</dt>
<dd>The resource owner or authorization server denied the
request.</dd>
<dt id="term-unsupported-response-type">unsupported_response_type</dt>
<dd>The authorization server does not support obtaining an
authorization code using this method.</dd>
<dt id="term-invalid-scope">invalid_scope</dt>
<dd>The requested scope is
<strong>invalid</strong>, <strong>unknown</strong>, or <strong>malformed</strong>.</dd>
<dt id="term-server-error">server_error</dt>
<dd>The authorization server encountered an unexpected
condition that prevented it from fulfilling the request.
(This error code is needed because a 500 Internal Server
Error HTTP status code cannot be returned to the client
via an HTTP redirect.)</dd>
<dt id="term-temporarily-unavailable">temporarily_unavailable</dt>
<dd>The authorization server is currently unable to handle
the request due to a temporary overloading or maintenance
of the server.  (This error code is needed because a 503
Service Unavailable HTTP status code cannot be returned
to the client via an HTTP redirect.)</dd>
</dl>
<p class="last">Values for the &#8220;error&#8221; parameter MUST NOT include characters
outside the set %x20-21 / %x23-5B / %x5D-7E.</p>
</dd>
<dt id="term-error-description">error_description</dt>
<dd>OPTIONAL.  Human-readable ASCII [USASCII] text providing
additional information, used to assist the client developer in
understanding the error that occurred.
Values for the &#8220;error_description&#8221; parameter MUST NOT include
characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt id="term-error-uri">error_uri</dt>
<dd>OPTIONAL.  A URI identifying a human-readable web page with
information about the error, used to provide the client
developer with additional information about the error.
Values for the &#8220;error_uri&#8221; parameter MUST conform to the
URI-reference syntax and thus MUST NOT include characters
outside the set %x21 / %x23-5B / %x5D-7E.</dd>
<dt id="term-37">state</dt>
<dd>REQUIRED if a &#8220;state&#8221; parameter was present in the client
authorization request.  The exact value received from the
client.</dd>
</dl>
<p>For example, the authorization server redirects the user-agent by
sending the following HTTP response:</p>
<div class="highlight-python"><pre>HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&amp;state=xyz</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1.2.1">http://tools.ietf.org/html/rfc6749.html#section-4.1.2.1</a> )</p>
</div>
</div>
<div class="section" id="access-token-request">
<span id="oauth-4-1-3"></span><h4><a class="toc-backref" href="#id58">4.1.3. Access Token Request</a><a class="headerlink" href="#access-token-request" title="Permalink to this headline">¶</a></h4>
<p>The client makes a request to the token endpoint
by sending the following parameters
using the &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221; format
per Appendix B with a character encoding of <strong>UTF-8</strong>
in the HTTP request entity-body:</p>
<dl class="glossary docutils">
<dt id="term-grant-type">grant_type</dt>
<dd>REQUIRED.  Value MUST be set to &#8220;authorization_code&#8221;.</dd>
<dt id="term-39">code</dt>
<dd>REQUIRED.  The authorization code received from the
authorization server.</dd>
<dt id="term-40">redirect_uri</dt>
<dd>REQUIRED, if the &#8220;redirect_uri&#8221; parameter was included in the
authorization request as described in Section 4.1.1, and their
values MUST be identical.</dd>
<dt id="term-41">client_id</dt>
<dd>REQUIRED, if the client is not authenticating with the
authorization server as described in Section 3.2.1.</dd>
</dl>
<p>If the <em class="xref std std-term">client type</em> is <a class="reference internal" href="#term-confidential"><em class="xref std std-term">confidential</em></a> or
the client was issued <a class="reference internal" href="glossary.html#term-client-credentials"><em class="xref std std-term">client credentials</em></a>
(or assigned other authentication requirements),
the client MUST authenticate with the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>
as described in <a class="reference internal" href="#oauth-3-2-1"><em>Section 3.2.1</em></a>.</p>
<p>For example, the client makes the following HTTP request using TLS
(with extra line breaks for display purposes only):</p>
<div class="highlight-python"><pre>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</pre>
</div>
<p>The authorization server MUST:</p>
<blockquote>
<div><ul class="simple">
<li>require <a class="reference internal" href="glossary.html#term-client-authentication"><em class="xref std std-term">client authentication</em></a> for confidential clients
or for any client that was issued client credentials
(or with other authentication requirements),</li>
<li>authenticate the client if <a class="reference internal" href="glossary.html#term-client-authentication"><em class="xref std std-term">client authentication</em></a> is included,</li>
<li>ensure that the <a class="reference internal" href="glossary.html#term-authorization-code"><em class="xref std std-term">authorization code</em></a> was issued to the authenticated
confidential client,
or if the client is public,
ensure that the code was issued to &#8220;<a class="reference internal" href="oauth_introspect.html#term-client-id"><em class="xref std std-term">client_id</em></a>&#8221; in the request,</li>
<li>verify that the authorization code is valid, and</li>
<li>ensure that the &#8220;<a class="reference internal" href="#term-44"><em class="xref std std-term">redirect_uri</em></a>&#8221; parameter is present
if the &#8220;<a class="reference internal" href="#term-44"><em class="xref std std-term">redirect_uri</em></a>&#8221; parameter was included
in the initial authorization request as described in <a class="reference internal" href="#oauth-4-1-1"><em>Section 4.1.1</em></a>,
and if included ensure that their values are identical.</li>
</ul>
</div></blockquote>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1.3">http://tools.ietf.org/html/rfc6749.html#section-4.1.3</a> )</p>
</div>
<div class="section" id="access-token-response">
<span id="oauth-4-1-4"></span><h4><a class="toc-backref" href="#id59">4.1.4. Access Token Response</a><a class="headerlink" href="#access-token-response" title="Permalink to this headline">¶</a></h4>
<p>If the access token request is valid and authorized,
the authorization server issues an access token and
<strong>optional</strong> <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> as described in <a class="reference internal" href="#oauth-5-1"><em>Section 5.1</em></a>.</p>
<p>If the request client authentication failed or is invalid,
the authorization server returns an error response as described in <a class="reference internal" href="#oauth-5-2"><em>Section 5.2</em></a>.</p>
<p>An example successful response:</p>
<div class="highlight-python"><pre>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.1.4">http://tools.ietf.org/html/rfc6749.html#section-4.1.4</a> )</p>
</div>
</div>
<div class="section" id="implicit-grant">
<span id="oauth-implicit-grant-type"></span><span id="oauth-implicit-grant"></span><span id="id3"></span><h3><a class="toc-backref" href="#id60">4.2.  Implicit Grant</a><a class="headerlink" href="#implicit-grant" title="Permalink to this headline">¶</a></h3>
<p>The <em class="xref std std-term">implicit grant type</em> is used to obtain <a class="reference internal" href="glossary.html#term-access-tokens"><em class="xref std std-term">access tokens</em></a>
(it does not support the issuance of <a class="reference internal" href="glossary.html#term-refresh-tokens"><em class="xref std std-term">refresh tokens</em></a>) and
is optimized for <em class="xref std std-term">public clients</em> known to operate a particular redirection URI.</p>
<p>These <a class="reference internal" href="#term-clients"><em class="xref std std-term">clients</em></a> are typically implemented in a <strong>browser</strong>
using a scripting language such as <em class="xref std std-term">JavaScript</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>** NO reflesh tokens ** for Implict</li>
</ul>
</div>
<p>Since this is a <strong>redirection-based</strong> flow,
the client must be capable of
interacting with the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>&#8216;s <a class="reference internal" href="glossary.html#term-user-agent"><em class="xref std std-term">user-agent</em></a>
(typically a web browser)
and capable of receiving incoming requests (via redirection)
from the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>.</p>
<p>Unlike the <a class="reference internal" href="#oauth-code"><em>authorization code grant type</em></a>,
in which the client makes separate <strong>requests for authorization</strong>
and for an access token,
the client receives the access token as the result of the <a class="reference internal" href="glossary.html#term-authorization-request"><em class="xref std std-term">authorization request</em></a>.</p>
<p>The implicit grant type does not include <a class="reference internal" href="glossary.html#term-client-authentication"><em class="xref std std-term">client authentication</em></a>, and
relies on the presence of the <a class="reference internal" href="#term-resource-owner"><em class="xref std std-term">resource owner</em></a>
and the registration of the <a class="reference internal" href="glossary.html#term-redirection-uri"><em class="xref std std-term">redirection URI</em></a>.</p>
<p>Because the access token is encoded into the redirection URI,
it may be exposed to the resource owner and other applications
residing on the same device.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>** NO client authentication **</li>
<li>resource owner MUST be the user agent operatior</li>
<li>redirection URI MUST be registered</li>
</ul>
</div>
<div class="highlight-python"><pre>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier     +---------------+
|         -+----(A)-- &amp; Redirection URI ---&gt;|               |
|  User-   |                                | Authorization |
|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
|          |                                |               |
|          |&lt;---(C)--- Redirection URI ----&lt;|               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  |&lt;---(E)------- Script ---------&lt;|               |
|          |                                +---------------+
+-|--------+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+---------+
|         |
|  Client |
|         |
+---------+</pre>
</div>
<div class="highlight-python"><pre>Note: The lines illustrating steps (A) and (B) are broken into two
parts as they pass through the user-agent.

                   Figure 4: Implicit Grant Flow</pre>
</div>
<p>The flow illustrated in Figure 4 includes the following steps:</p>
<blockquote>
<div><ol class="upperalpha">
<li><p class="first">The client initiates the flow by directing the resource owner&#8217;s
user-agent to the authorization endpoint.</p>
<p>The client includes its client identifier,
requested scope, local state, and a redirection URI
to which the authorization server will send the
user-agent back once access is granted (or denied).</p>
</li>
<li><p class="first">The authorization server authenticates the resource owner
(via the user-agent) and establishes whether the resource owner
grants or denies the client&#8217;s access request.</p>
</li>
<li><p class="first">Assuming the resource owner grants access,
the authorization server redirects the user-agent back to the client
using the redirection URI provided earlier.
The redirection URI includes the access token in the <em class="xref std std-term">URI fragment</em>.</p>
</li>
<li><p class="first">The user-agent follows the redirection instructions by making a
request to the web-hosted client resource (which does not
include the fragment per [RFC2616]).  The user-agent retains the
fragment information locally.</p>
</li>
<li><p class="first">The web-hosted client resource returns a web page (typically an
HTML document with an embedded script) capable of accessing the
full redirection URI including the fragment retained by the
user-agent, and extracting the access token (and other
parameters) contained in the fragment.</p>
</li>
<li><p class="first">The user-agent executes the script provided by the web-hosted
client resource locally, which extracts the access token.</p>
</li>
<li><p class="first">The user-agent passes the access token to the client.</p>
</li>
</ol>
</div></blockquote>
<p>See <a class="reference internal" href="#oauth-1-3-2"><em>Sections 1.3.2</em></a> and <a class="reference internal" href="#oauth-9"><em>9</em></a> for background
on using the implicit grant.
See <a class="reference internal" href="#oauth-10-3"><em>Sections 10.3</em></a> and <a class="reference internal" href="#oauth-10-16"><em>10.16</em></a>
for important security considerations when using the implicit grant.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.2">http://tools.ietf.org/html/rfc6749.html#section-4.2</a> )</p>
<div class="section" id="oauth-4-2-1">
<span id="id4"></span><h4><a class="toc-backref" href="#id61">4.2.1. Authorization Request</a><a class="headerlink" href="#oauth-4-2-1" title="Permalink to this headline">¶</a></h4>
<p>The client constructs the request URI by adding the following
parameters to the query component of the authorization endpoint URI
using the &#8220;application/x-www-form-urlencoded&#8221; format, per Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-42">response_type</dt>
<dd>REQUIRED.  Value MUST be set to &#8220;token&#8221;.</dd>
<dt id="term-43">client_id</dt>
<dd>REQUIRED.  The client identifier as described in Section 2.2.</dd>
<dt id="term-44">redirect_uri</dt>
<dd>OPTIONAL.  As described in Section 3.1.2.</dd>
<dt id="term-45">scope</dt>
<dd><p class="first"><strong>OPTIONAL</strong>.</p>
<p class="last">The scope of the access request as described by <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>.</p>
</dd>
<dt id="term-46">state</dt>
<dd>RECOMMENDED.  An opaque value used by the client to maintain
state between the request and callback.  The authorization
server includes this value when redirecting the user-agent back
to the client.  The parameter SHOULD be used for preventing
cross-site request forgery as described in Section 10.12.</dd>
</dl>
<p>The client directs the resource owner to the constructed URI using an
HTTP redirection response, or by other means available to it via the
user-agent.</p>
<p>For example, the client directs the user-agent to make the following
HTTP request using TLS (with extra line breaks for display purposes
only):</p>
<div class="highlight-python"><pre>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com</pre>
</div>
<p>The authorization server validates the request to ensure that all
required parameters are present and valid.  The authorization server
MUST verify that the redirection URI to which it will redirect the
access token matches a redirection URI registered by the client as
described in Section 3.1.2.</p>
<p>If the request is valid, the authorization server authenticates the
resource owner and obtains an authorization decision (by asking the
resource owner or by establishing approval via other means).</p>
<p>When a decision is established, the authorization server directs the
user-agent to the provided client redirection URI using an HTTP
redirection response, or by other means available to it via the
user-agent.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.2.1">http://tools.ietf.org/html/rfc6749.html#section-4.2.1</a> )</p>
</div>
<div class="section" id="oauth-4-2-2">
<span id="id5"></span><h4><a class="toc-backref" href="#id62">4.2.2. Access Token Response</a><a class="headerlink" href="#oauth-4-2-2" title="Permalink to this headline">¶</a></h4>
<p>If the resource owner grants the access request, the authorization
server issues an access token and delivers it to the client by adding
the following parameters to the fragment component of the redirection
URI using the &#8220;application/x-www-form-urlencoded&#8221; format, per
Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-access-token">access_token</dt>
<dd>REQUIRED.  The access token issued by the authorization server.</dd>
<dt id="term-token-type">token_type</dt>
<dd><p class="first">REQUIRED.</p>
<p>The type of the token issued as described in <a class="reference internal" href="#oauth-7-1"><em>Section 7.1</em></a>.</p>
<p class="last">Value is case insensitive.</p>
</dd>
<dt id="term-expires-in">expires_in</dt>
<dd><p class="first">RECOMMENDED.</p>
<p>The lifetime in <strong>seconds</strong> of the access token.</p>
<p>For example, the value &#8220;3600&#8221; denotes that the access token will
expire in one hour from the time the response was generated.</p>
<p class="last">If omitted, the authorization server SHOULD provide the
expiration time via other means or document the default value.</p>
</dd>
<dt id="term-50">scope</dt>
<dd><p class="first">OPTIONAL, if identical to the scope requested by the client;
otherwise, REQUIRED.</p>
<p class="last">The scope of the access token as described by <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>.</p>
</dd>
<dt id="term-51">state</dt>
<dd><p class="first">REQUIRED if the &#8220;state&#8221; parameter was present in the client
authorization request.</p>
<p class="last">The exact value received from the client.</p>
</dd>
</dl>
<p>The authorization server MUST NOT issue a refresh token.</p>
<p>For example,
the authorization server redirects the user-agent
by sending the following HTTP response
(with extra line breaks for display purposes only):</p>
<div class="highlight-python"><pre>HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</pre>
</div>
<p>Developers should note that some user-agents do not support the
inclusion of a <em class="xref std std-term">fragment component</em>
in the HTTP &#8220;<em class="xref std std-term">Location</em>&#8221; response header field.
Such clients will require using other methods for
redirecting the client than a 3xx redirection response
&#8211; for example,
returning an HTML page that includes a &#8216;continue&#8217; button
with an action linked to the redirection URI.</p>
<p>The client MUST ignore unrecognized response parameters.
The access token string size is left undefined by this specification.
The client should avoid making assumptions about value sizes.
The authorization server SHOULD document the size of any value it issues.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.2.2">http://tools.ietf.org/html/rfc6749.html#section-4.2.2</a>  )</p>
<div class="section" id="oauth-4-2-2-1">
<span id="id6"></span><h5><a class="toc-backref" href="#id63">4.2.2.1. Error Response</a><a class="headerlink" href="#oauth-4-2-2-1" title="Permalink to this headline">¶</a></h5>
<p>If the request fails due to a missing, invalid, or mismatching
redirection URI, or if the client identifier is missing or invalid,
the authorization server SHOULD inform the resource owner of the
error and MUST NOT automatically redirect the user-agent to the
invalid redirection URI.</p>
<p>If the resource owner denies the access request or if the request
fails for reasons other than a missing or invalid redirection URI,
the authorization server informs the client by adding the following
parameters to the fragment component of the redirection URI using the
&#8220;application/x-www-form-urlencoded&#8221; format, per Appendix B:</p>
<dl class="glossary docutils">
<dt id="term-52">error</dt>
<dd><p class="first">REQUIRED.  A single ASCII [USASCII] error code from the
following:</p>
<dl class="docutils">
<dt>invalid_request</dt>
<dd>The request is missing a required parameter, includes an
invalid parameter value, includes a parameter more than
once, or is otherwise malformed.</dd>
<dt>unauthorized_client</dt>
<dd>The client is not authorized to request an access token
using this method.</dd>
<dt>access_denied</dt>
<dd>The resource owner or authorization server denied the
request.</dd>
<dt>unsupported_response_type</dt>
<dd>The authorization server does not support obtaining an
access token using this method.</dd>
<dt>invalid_scope</dt>
<dd>The requested scope is invalid, unknown, or malformed.</dd>
<dt>server_error</dt>
<dd>The authorization server encountered an unexpected
condition that prevented it from fulfilling the request.
(This error code is needed because a 500 Internal Server
Error HTTP status code cannot be returned to the client
via an HTTP redirect.)</dd>
<dt>temporarily_unavailable</dt>
<dd>The authorization server is currently unable to handle
the request due to a temporary overloading or maintenance
of the server.  (This error code is needed because a 503
Service Unavailable HTTP status code cannot be returned
to the client via an HTTP redirect.)</dd>
</dl>
<p class="last">Values for the &#8220;error&#8221; parameter MUST NOT include characters
outside the set %x20-21 / %x23-5B / %x5D-7E.</p>
</dd>
<dt id="term-53">error_description</dt>
<dd>OPTIONAL.  Human-readable ASCII [USASCII] text providing
additional information, used to assist the client developer in
understanding the error that occurred.
Values for the &#8220;error_description&#8221; parameter MUST NOT include
characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt id="term-54">error_uri</dt>
<dd>OPTIONAL.  A URI identifying a human-readable web page with
information about the error, used to provide the client
developer with additional information about the error.
Values for the &#8220;error_uri&#8221; parameter MUST conform to the
URI-reference syntax and thus MUST NOT include characters
outside the set %x21 / %x23-5B / %x5D-7E.</dd>
<dt id="term-55">state</dt>
<dd>REQUIRED if a &#8220;state&#8221; parameter was present in the client
authorization request.  The exact value received from the
client.</dd>
</dl>
<p>For example, the authorization server redirects the user-agent by
sending the following HTTP response:</p>
<div class="highlight-python"><pre>HTTP/1.1 302 Found
Location: https://client.example.com/cb#error=access_denied&amp;state=xyz</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-4.2.2.1">http://tools.ietf.org/html/rfc6749.html#section-4.2.2.1</a> )</p>
</div>
</div>
</div>
<div class="section" id="resource-owner-password-credentials-grant">
<span id="oauth-4-3"></span><h3><a class="toc-backref" href="#id64">4.3. Resource Owner Password Credentials Grant</a><a class="headerlink" href="#resource-owner-password-credentials-grant" title="Permalink to this headline">¶</a></h3>
<p>The resource owner password credentials grant type is suitable in cases
where the resource owner has a trust relationship with the client,
such as the device operating system or a highly privileged application.</p>
<p>The authorization server should take special care
when enabling this grant type and only allow it
when other flows are not viable.</p>
<p>This grant type is suitable for clients capable of
obtaining the resource owner&#8217;s credentials
(username and password, typically using an interactive form).</p>
<p>It is also used to migrate existing clients
using direct authentication schemes
such as HTTP Basic or Digest authentication to OAuth
by converting the stored credentials to an access token.</p>
<div class="highlight-python"><pre>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     v
     |    Resource Owner
    (A) Password Credentials
     |
     v
+---------+                                  +---------------+
|         |&gt;--(B)---- Resource Owner -------&gt;|               |
|         |         Password Credentials     | Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(C)---- Access Token ---------&lt;|               |
|         |    (w/ Optional Refresh Token)   |               |
+---------+                                  +---------------+

       Figure 5: Resource Owner Password Credentials Flow</pre>
</div>
<p>The flow illustrated in Figure 5 includes the following steps:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>The resource owner provides the client with its username and
password.</li>
<li>The client requests an access token from the authorization
server&#8217;s token endpoint by including the credentials received
from the resource owner.  When making the request, the client
authenticates with the authorization server.</li>
<li>The authorization server authenticates the client and validates
the resource owner credentials, and if valid, issues an access
token.</li>
</ol>
</div></blockquote>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.3">http://tools.ietf.org/html/rfc6749#section-4.3</a> )</p>
</div>
<div class="section" id="authorization-request-and-response">
<span id="oauth-4-3-1"></span><h3><a class="toc-backref" href="#id65">4.3.1. Authorization Request and Response</a><a class="headerlink" href="#authorization-request-and-response" title="Permalink to this headline">¶</a></h3>
<p>The method through which the client obtains the resource owner credentials
is beyond the scope of this specification.
The client MUST discard the credentials once an access token has been obtained.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.3.1">http://tools.ietf.org/html/rfc6749#section-4.3.1</a> )</p>
<div class="section" id="oauth-4-3-2">
<span id="id7"></span><h4><a class="toc-backref" href="#id66">4.3.2. Access Token Request</a><a class="headerlink" href="#oauth-4-3-2" title="Permalink to this headline">¶</a></h4>
<p>The client makes a request to the token endpoint by adding the
following parameters using the &#8220;application/x-www-form-urlencoded&#8221;
format per Appendix B with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<dl class="glossary docutils">
<dt id="term-56">grant_type</dt>
<dd>REQUIRED.  Value MUST be set to &#8220;password&#8221;.</dd>
<dt id="term-username">username</dt>
<dd>REQUIRED.  The resource owner username.</dd>
<dt id="term-password">password</dt>
<dd>REQUIRED.  The resource owner password.</dd>
<dt id="term-59">scope</dt>
<dd>OPTIONAL.  The scope of the access request as described by
Section 3.3.</dd>
</dl>
<p>If the client type is confidential
or the client was issued client credentials
(or assigned other authentication requirements),
the client MUST authenticate with the authorization server as described
in <a class="reference internal" href="#oauth-3-2-1"><em>Section 3.2.1</em></a>.</p>
<p>For example,
the client makes the following HTTP request using
transport-layer security (with extra line breaks for display purposes only):</p>
<div class="highlight-python"><pre>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</pre>
</div>
<p>The authorization server MUST:</p>
<blockquote>
<div><ul class="simple">
<li>require client authentication for confidential clients or for any
client that was issued client credentials (or with other
authentication requirements),</li>
<li>authenticate the client if client authentication is included, and</li>
<li>validate the resource owner password credentials using its
existing password validation algorithm.</li>
</ul>
</div></blockquote>
<p>Since this access token request utilizes the resource owner&#8217;s password,
the authorization server MUST protect the endpoint against
brute force attacks (e.g., using rate-limitation or generating alerts).</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.3.2">http://tools.ietf.org/html/rfc6749#section-4.3.2</a> )</p>
</div>
<div class="section" id="oauth-4-3-3">
<span id="id8"></span><h4><a class="toc-backref" href="#id67">4.3.3. Access Token Response</a><a class="headerlink" href="#oauth-4-3-3" title="Permalink to this headline">¶</a></h4>
<p>If the access token request is valid and authorized,
the authorization server issues an access token
and optional refresh token as described in <a class="reference internal" href="#oauth-5-1"><em>Section 5.1.</em></a></p>
<p>If the request failed client authentication or is invalid,
the authorization server returns an error response as described in <a class="reference internal" href="#oauth-5-2"><em>Section 5.2</em></a>.</p>
<p>An example successful response:</p>
<div class="highlight-python"><pre>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.3.3">http://tools.ietf.org/html/rfc6749#section-4.3.3</a> )</p>
</div>
</div>
<div class="section" id="client-credentials-grant">
<span id="oauth-4-4"></span><h3><a class="toc-backref" href="#id68">4.4. Client Credentials Grant</a><a class="headerlink" href="#client-credentials-grant" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Token Endpoint に直接トークンをリクエストします</li>
<li>User主導のGrant取得フローはなく、Client Credentialが正しければトークンを発行します。</li>
<li>Refresh Tokenの概念はないので、古くなったら再度新しいトークンを要求します。</li>
</ul>
</div>
<p>The client can request an access token
using only its client credentials
(or other supported means of authentication)
when the client is requesting access to the protected resources
under its control,
or those of another resource owner that have been previously
arranged with the authorization server
(the method of which is beyond the scope of this specification).</p>
<p>The client credentials grant type MUST only be used by confidential clients.</p>
<div class="highlight-python"><pre>+---------+                                  +---------------+
|         |                                  |               |
|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(B)---- Access Token ---------&lt;|               |
|         |                                  |               |
+---------+                                  +---------------+

                Figure 6: Client Credentials Flow</pre>
</div>
<p>The flow illustrated in Figure 6 includes the following steps:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li>The client authenticates with the authorization server and
requests an access token from the token endpoint.</li>
<li>The authorization server authenticates the client, and if valid,
issues an access token.</li>
</ol>
</div></blockquote>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.4">http://tools.ietf.org/html/rfc6749#section-4.4</a> )</p>
<div class="section" id="oauth-4-4-1">
<span id="id9"></span><h4><a class="toc-backref" href="#id69">4.4.1. Authorization Request and Response</a><a class="headerlink" href="#oauth-4-4-1" title="Permalink to this headline">¶</a></h4>
<p>Since the client authentication is used as the authorization grant,
no additional authorization request is needed.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.4">http://tools.ietf.org/html/rfc6749#section-4.4</a> )</p>
</div>
<div class="section" id="oauth-4-4-2">
<span id="id10"></span><h4><a class="toc-backref" href="#id70">4.4.2. Access Token Request</a><a class="headerlink" href="#oauth-4-4-2" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Token Endpointに直接トークンリクエスト</p>
</div>
<p>The client makes a request to the token endpoint
by adding the following parameters
using the &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221; format
per Appendix B with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<dl class="glossary docutils">
<dt id="term-60">grant_type</dt>
<dd><p class="first">REQUIRED.</p>
<p class="last">Value MUST be set to &#8220;<strong>client_credentials</strong>&#8221;.</p>
</dd>
<dt id="term-61">scope</dt>
<dd><p class="first">OPTIONAL.</p>
<p class="last">The scope of the access request as described by <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>.</p>
</dd>
</dl>
<p>The client MUST authenticate with the authorization server as described
in Section 3.2.1.</p>
<p>For example, the client makes the following HTTP request using
transport-layer security (with extra line breaks for display purposes only):</p>
<div class="highlight-python"><pre>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials</pre>
</div>
<p>The authorization server MUST authenticate the client.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>上記の例はクライアントクレデンシャルで基本認証している</li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.4.2">http://tools.ietf.org/html/rfc6749#section-4.4.2</a> )</p>
</div>
<div class="section" id="oauth-4-4-3">
<span id="id11"></span><h4><a class="toc-backref" href="#id71">4.4.3. Access Token Response</a><a class="headerlink" href="#oauth-4-4-3" title="Permalink to this headline">¶</a></h4>
<p>If the access token request is valid and authorized,
the authorization server issues an access token
as described in <a class="reference internal" href="#oauth-5-1"><em>Section 5.1</em></a>.</p>
<p>A refresh token SHOULD NOT be included.</p>
<p>If the request failed client authentication or is invalid,
the authorization server returns an error response as described in <a class="reference internal" href="#oauth-5-2"><em>Section 5.2</em></a>.</p>
<p>An example successful response:</p>
<div class="highlight-python"><pre>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "example_parameter":"example_value"
}</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>このフローではリフレッシュトークンは使えません。</li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-4.4.3">http://tools.ietf.org/html/rfc6749#section-4.4.3</a> )</p>
</div>
</div>
</div>
<div class="section" id="issuing-an-access-token">
<span id="oauth-token-response"></span><span id="oauth-5"></span><h2><a class="toc-backref" href="#id72">5.  Issuing an Access Token</a><a class="headerlink" href="#issuing-an-access-token" title="Permalink to this headline">¶</a></h2>
<p>If the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> request is valid and authorized,
the authorization server issues an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> and optional <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a>
as described in <em class="xref std std-ref">Section 5.1</em> .</p>
<p>If the request failed client authentication or is invalid,
the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> returns
an error response as described in <em class="xref std std-ref">Section 5.2</em>.</p>
<p>(v.30, <a class="reference external" href="http://tools.ietf.org/html/draft-ietf-oauth-v2-30#section-5">http://tools.ietf.org/html/draft-ietf-oauth-v2-30#section-5</a>)</p>
<div class="section" id="successful-response">
<span id="oauth-5-1"></span><h3><a class="toc-backref" href="#id73">5.1. Successful Response</a><a class="headerlink" href="#successful-response" title="Permalink to this headline">¶</a></h3>
<p>The authorization server issues an access token and optional refresh token,
and constructs the response by adding the following parameters
to the entity-body of the HTTP response with a 200 (OK) status code:</p>
<dl class="glossary docutils">
<dt id="term-62">access_token</dt>
<dd>REQUIRED.  The access token issued by the authorization server.</dd>
<dt id="term-63">token_type</dt>
<dd>REQUIRED.  The type of the token issued as described in
Section 7.1.  Value is case insensitive.</dd>
<dt id="term-64">expires_in</dt>
<dd>RECOMMENDED.  The lifetime in seconds of the access token.  For
example, the value &#8220;3600&#8221; denotes that the access token will
expire in one hour from the time the response was generated.
If omitted, the authorization server SHOULD provide the
expiration time via other means or document the default value.</dd>
<dt id="term-refresh-token">refresh_token</dt>
<dd>OPTIONAL.  The refresh token, which can be used to obtain new
access tokens using the same authorization grant as described
in Section 6.</dd>
<dt id="term-66">scope</dt>
<dd>OPTIONAL, if identical to the scope requested by the client;
otherwise, REQUIRED.  The scope of the access token as
described by Section 3.3.</dd>
</dl>
<p>The parameters are included in the entity-body of the HTTP response
using the &#8220;<strong>application/json</strong>&#8221; media type as defined by <a class="reference internal" href="oauth_meta.html#term-rfc4627"><em class="xref std std-term">[RFC4627]</em></a>.
The parameters are serialized into a JavaScript Object Notation (JSON)
structure by adding each parameter at the highest structure level.
Parameter names and string values are included as JSON strings.
Numerical values are included as JSON numbers.  The order of
parameters does not matter and can vary.</p>
<p>The authorization server MUST include the HTTP &#8220;Cache-Control&#8221;
response header field [RFC2616] with a value of &#8220;no-store&#8221; in any
response containing tokens, credentials, or other sensitive
information, as well as the &#8220;Pragma&#8221; response header field [RFC2616]
with a value of &#8220;no-cache&#8221;.</p>
<p>For example:</p>
<div class="highlight-python"><pre>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}</pre>
</div>
<p>The client MUST ignore unrecognized value names in the response.  The
sizes of tokens and other values received from the authorization
server are left undefined.  The client should avoid making
assumptions about value sizes.  The authorization server SHOULD
document the size of any value it issues.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-5.1">http://tools.ietf.org/html/rfc6749.html#section-5.1</a> )</p>
</div>
<div class="section" id="oauth-5-2">
<span id="id12"></span><h3><a class="toc-backref" href="#id74">5.2. Error Response</a><a class="headerlink" href="#oauth-5-2" title="Permalink to this headline">¶</a></h3>
<p>The authorization server responds with an HTTP 400 (Bad Request)
status code (unless specified otherwise)
and includes the following parameters with the response:</p>
<blockquote>
<div><dl class="docutils">
<dt>error</dt>
<dd><p class="first">REQUIRED.</p>
<p>A single ASCII [USASCII] error code from the following:</p>
<dl class="docutils">
<dt>invalid_request</dt>
<dd>The request is missing a required parameter, includes an
unsupported parameter value (other than grant type),
repeats a parameter, includes multiple credentials,
utilizes more than one mechanism for authenticating the
client, or is otherwise malformed.</dd>
<dt>invalid_client</dt>
<dd>Client authentication failed (e.g., unknown client, no
client authentication included, or unsupported
authentication method).  The authorization server MAY
return an HTTP 401 (Unauthorized) status code to indicate
which HTTP authentication schemes are supported.  If the
client attempted to authenticate via the &#8220;Authorization&#8221;
request header field, the authorization server MUST
respond with an HTTP 401 (Unauthorized) status code and
include the &#8220;WWW-Authenticate&#8221; response header field
matching the authentication scheme used by the client.</dd>
<dt>invalid_grant</dt>
<dd>The provided authorization grant (e.g., authorization
code, resource owner credentials) or refresh token is
invalid, expired, revoked, does not match the redirection
URI used in the authorization request, or was issued to
another client.</dd>
<dt>unauthorized_client</dt>
<dd>The authenticated client is not authorized to use this
authorization grant type.</dd>
<dt>unsupported_grant_type</dt>
<dd>The authorization grant type is not supported by the
authorization server.</dd>
<dt>invalid_scope</dt>
<dd>The requested scope is invalid, unknown, malformed, or
exceeds the scope granted by the resource owner.</dd>
</dl>
<p class="last">Values for the &#8220;error&#8221; parameter MUST NOT include characters
outside the set %x20-21 / %x23-5B / %x5D-7E.</p>
</dd>
<dt>error_description</dt>
<dd>OPTIONAL.  Human-readable ASCII [USASCII] text providing
additional information, used to assist the client developer in
understanding the error that occurred.
Values for the &#8220;error_description&#8221; parameter MUST NOT include
characters outside the set %x20-21 / %x23-5B / %x5D-7E.</dd>
<dt>error_uri</dt>
<dd>OPTIONAL.  A URI identifying a human-readable web page with
information about the error, used to provide the client
developer with additional information about the error.
Values for the &#8220;error_uri&#8221; parameter MUST conform to the
URI-reference syntax and thus MUST NOT include characters
outside the set %x21 / %x23-5B / %x5D-7E.</dd>
</dl>
</div></blockquote>
<p>The parameters are included in the <strong>entity-body</strong> of the HTTP response
using the &#8220;<strong>application/json</strong>&#8221; media type as defined by <a class="reference internal" href="oauth_meta.html#term-rfc4627"><em class="xref std std-term">[RFC4627]</em></a>.</p>
<p>The parameters are serialized into a JSON structure by adding each
parameter at the highest structure level.
Parameter names and string values are included as JSON strings.
Numerical values are included as JSON numbers.
The order of parameters does not matter and can vary.</p>
<p>For example:</p>
<div class="highlight-python"><pre>HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "error":"invalid_request"
}</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-5.2">http://tools.ietf.org/html/rfc6749.html#section-5.2</a> )</p>
</div>
</div>
<div class="section" id="refreshing-an-access-token">
<span id="oauth-refreshing-an-access-token"></span><span id="oauth-6"></span><h2><a class="toc-backref" href="#id75">6. Refreshing an Access Token</a><a class="headerlink" href="#refreshing-an-access-token" title="Permalink to this headline">¶</a></h2>
<p>If the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> issued a <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> to the client,
the client makes a refresh request to the <a class="reference internal" href="uma_core.html#term-token-endpoint"><em class="xref std std-term">token endpoint</em></a>
by adding the following parameters using the &#8220;<strong>application/x-www-form-urlencoded</strong>&#8221; format
per Appendix B
with a character encoding of UTF-8 in the HTTP request entity-body:</p>
<dl class="glossary docutils">
<dt id="term-67">grant_type</dt>
<dd>REQUIRED.  Value MUST be set to &#8220;refresh_token&#8221;.</dd>
<dt id="term-68">refresh_token</dt>
<dd>REQUIRED.  The refresh token issued to the client.</dd>
<dt id="term-69">scope</dt>
<dd><p class="first">OPTIONAL.</p>
<p>The <a class="reference internal" href="oauth_introspect.html#term-scope"><em class="xref std std-term">scope</em></a> of the access request as described by <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>.</p>
<p class="last">The requested scope MUST NOT include any scope not originally granted by the resource owner,
and if omitted is treated as equal to the scope originally granted by the resource owner.</p>
</dd>
</dl>
<p>Because refresh tokens are typically long-lasting credentials used to
request additional access tokens,
the refresh token is bound to the client to which it was issued.</p>
<p>If the client type is confidential or the client was issued client credentials
(or assigned other authentication requirements),
the client MUST authenticate with the authorization server
as described in <a class="reference internal" href="#oauth-3-2-1"><em>Section 3.2.1</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Refreshing tokens require the <strong>Client Authentication</strong>.</li>
</ul>
</div>
<p>For example, the client makes the following HTTP request using
transport-layer security (with extra line breaks for display purposes
only):</p>
<div class="highlight-python"><pre>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Above sample uess the Basic Authentication</li>
</ul>
</div>
<p>The authorization server MUST:</p>
<ul class="simple">
<li>require <a class="reference internal" href="#oauth-client-authentication"><em>client authentication</em></a>
for <em class="xref std std-term">confidential clients</em> or
for any client that was issued client credentials
(or with other authentication requirements),</li>
<li>authenticate the client if <a class="reference internal" href="#oauth-client-authentication"><em>client authentication</em></a> is included and
ensure that the <a class="reference internal" href="glossary.html#term-refresh-token"><em class="xref std std-term">refresh token</em></a> was issued to the authenticated client, and</li>
<li>validate the refresh token.</li>
</ul>
<p>If valid and authorized,
the authorization server issues an <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> as described in <a class="reference internal" href="#oauth-5-1"><em>Section 5.1</em></a>.
If the request failed verification or is invalid,
the authorization server returns an error response as described in <a class="reference internal" href="#oauth-5-2"><em>Section 5.2</em></a>.</p>
<p>The <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MAY issue a new refresh token,
in which case the client MUST discard the old refresh token
and replace it with the new refresh token.
The authorization server MAY revoke the old refresh token
after issuing a new refresh token to the client.
If a new refresh token is issued,
the refresh token <a class="reference internal" href="oauth_introspect.html#term-scope"><em class="xref std std-term">scope</em></a> MUST be identical to
that of the refresh token included by the client in the request.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>scope of refresh tokens = scope in authorization request</li>
</ul>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-6">http://tools.ietf.org/html/rfc6749.html#section-6</a> )</p>
</div>
<div class="section" id="accessing-protected-resources">
<span id="oauth-7"></span><h2><a class="toc-backref" href="#id76">7. Accessing Protected Resources</a><a class="headerlink" href="#accessing-protected-resources" title="Permalink to this headline">¶</a></h2>
<p>The client accesses <a class="reference internal" href="glossary.html#term-protected-resources"><em class="xref std std-term">protected resources</em></a>
by presenting the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> to the <a class="reference internal" href="#term-resource-server"><em class="xref std std-term">resource server</em></a>.</p>
<p>The resource server MUST <strong>validate</strong> the access token
and ensure that it has <strong>not expired</strong>
and that its <a class="reference internal" href="oauth_introspect.html#term-scope"><em class="xref std std-term">scope</em></a> covers the requested resource.</p>
<p>The methods used by the resource server to validate the access token
(as well as any error responses) are beyond the scope of this specification
but generally involve an interaction or coordination
between the resource server and the authorization server.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><a class="reference internal" href="uma_core.html"><em>User-Managed Access (UMA) Profile of OAuth 2.0</em></a></li>
</ul>
</div>
<p>The method in which the client utilizes the access token to
authenticate with the resource server
depends on the <strong>type of access token</strong> issued by the authorization server.</p>
<p>Typically,
it involves using the HTTP &#8220;<strong>Authorization</strong>&#8221; request header field <a class="reference internal" href="#term-rfc2617"><em class="xref std std-term">[RFC2617]</em></a>
with an authentication scheme defined by the specification of the access
token type used, such as <a class="reference internal" href="oauth_introspect.html#term-rfc6750"><em class="xref std std-term">[RFC6750]</em></a>.</p>
<p>( <span class="target" id="index-5"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a>,  <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-7">http://tools.ietf.org/html/rfc6749.html#section-7</a> )</p>
<div class="section" id="access-token-types">
<span id="oauth-7-1"></span><h3><a class="toc-backref" href="#id77">7.1. Access Token Types</a><a class="headerlink" href="#access-token-types" title="Permalink to this headline">¶</a></h3>
<p>The <em class="xref std std-term">access token type</em> provides the client
with the information required to successfully utilize the access token
to make a protected resource request
(along with type-specific attributes).</p>
<p>The client MUST NOT use an access token if it does not understand the token type.</p>
<p>For example,
the &#8220;bearer&#8221; token type defined in <a class="reference internal" href="oauth_introspect.html#term-rfc6750"><em class="xref std std-term">[RFC6750]</em></a> is utilized
by simply including the <a class="reference internal" href="glossary.html#term-access-token"><em class="xref std std-term">access token</em></a> string in the request:</p>
<div class="highlight-python"><pre>GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer mF_9.B5f-4.1JqM</pre>
</div>
<p>while the &#8220;mac&#8221; token type defined in <a class="reference internal" href="#term-oauth-http-mac"><em class="xref std std-term">[OAuth-HTTP-MAC]</em></a> is utilized by
issuing a Message Authentication Code (MAC) key together with the access token
that is used to sign certain components of the HTTP requests:</p>
<div class="highlight-python"><pre>GET /resource/1 HTTP/1.1
Host: example.com
Authorization: MAC id="h480djs93hd8",
                   nonce="274312:dj83hs9s",
                   mac="kDZvddkndxvhGRXZhvuDjEWhGeE="</pre>
</div>
<p>The above examples are provided for illustration purposes only.</p>
<p>Developers are advised to consult the <a class="reference internal" href="oauth_introspect.html#term-rfc6750"><em class="xref std std-term">[RFC6750]</em></a> and <a class="reference internal" href="#term-oauth-http-mac"><em class="xref std std-term">[OAuth-HTTP-MAC]</em></a>
specifications before use.</p>
<p>Each access token type definition specifies the additional attributes
(if any) sent to the client together with the &#8220;<a class="reference internal" href="#term-62"><em class="xref std std-term">access_token</em></a>&#8221; response parameter.
It also defines the HTTP authentication method
used to include the access token when making a protected resource request.</p>
<p>( <span class="target" id="index-6"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a> , <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-7.1">http://tools.ietf.org/html/rfc6749#section-7.1</a> )</p>
</div>
<div class="section" id="oauth-7-2">
<span id="id13"></span><h3><a class="toc-backref" href="#id78">7.2. Error Response</a><a class="headerlink" href="#oauth-7-2" title="Permalink to this headline">¶</a></h3>
<p>If a resource access request fails, the resource server SHOULD inform
the client of the error.  While the specifics of such error responses
are beyond the scope of this specification, this document establishes
a common registry in <em class="xref std std-ref">Section 11.4</em>
for error values to be shared among OAuth token authentication schemes.</p>
<p>New authentication schemes designed primarily for OAuth token
authentication SHOULD define a mechanism for providing an error
status code to the client, in which the error values allowed are
registered in the error registry established by this specification.</p>
<p>Such schemes MAY limit the set of valid error codes to a subset of
the registered values.  If the error code is returned using a named
parameter, the parameter name SHOULD be &#8220;error&#8221;.</p>
<p>Other schemes capable of being used for OAuth token authentication,
but not primarily designed for that purpose, MAY bind their error
values to the registry in the same manner.</p>
<p>New authentication schemes MAY choose to also specify the use of the
&#8220;error_description&#8221; and &#8220;error_uri&#8221; parameters to return error
information in a manner parallel to their usage in this specification.</p>
<p>( <span class="target" id="index-7"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc6749.html"><strong>RFC 6749</strong></a> , <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-7.2">http://tools.ietf.org/html/rfc6749.html#section-7.2</a> )</p>
</div>
</div>
<div class="section" id="extensibility">
<span id="oauth-8"></span><h2><a class="toc-backref" href="#id79">8. Extensibility</a><a class="headerlink" href="#extensibility" title="Permalink to this headline">¶</a></h2>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8">https://tools.ietf.org/html/rfc6749.html#section-8</a> )</p>
<div class="section" id="defining-access-token-types">
<span id="oauth-8-1"></span><h3><a class="toc-backref" href="#id80">8.1.  Defining Access Token Types</a><a class="headerlink" href="#defining-access-token-types" title="Permalink to this headline">¶</a></h3>
<p>Access token types can be defined in one of two ways: registered in
the Access Token Types registry (following the procedures in
Section 11.1), or by using a unique absolute URI as its name.</p>
<p>Types utilizing a URI name SHOULD be limited to vendor-specific
implementations that are not commonly applicable, and are specific to
the implementation details of the resource server where they are
used.</p>
<p>All other types MUST be registered.  Type names MUST conform to the
type-name ABNF.  If the type definition includes a new HTTP
authentication scheme, the type name SHOULD be identical to the HTTP
authentication scheme name (as defined by [RFC2617]).  The token type
&#8220;example&#8221; is reserved for use in examples.</p>
<dl class="docutils">
<dt>::</dt>
<dd>type-name  = 1*name-char
name-char  = &#8220;-&#8221; / &#8221;.&#8221; / &#8220;_&#8221; / DIGIT / ALPHA</dd>
</dl>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8.1">https://tools.ietf.org/html/rfc6749.html#section-8.1</a> )</p>
</div>
<div class="section" id="defining-new-endpoint-parameters">
<span id="oauth-8-2"></span><h3><a class="toc-backref" href="#id81">8.2.  Defining New Endpoint Parameters</a><a class="headerlink" href="#defining-new-endpoint-parameters" title="Permalink to this headline">¶</a></h3>
<p>New request or response parameters for use with the authorization
endpoint or the token endpoint are defined and registered in the
OAuth Parameters registry following the procedure in Section 11.2.</p>
<p>Parameter names MUST conform to the param-name ABNF, and parameter
values syntax MUST be well-defined (e.g., using ABNF, or a reference
to the syntax of an existing parameter).</p>
<blockquote>
<div>param-name  = 1*name-char
name-char   = &#8220;-&#8221; / &#8221;.&#8221; / &#8220;_&#8221; / DIGIT / ALPHA</div></blockquote>
<p>Unregistered vendor-specific parameter extensions that are not
commonly applicable and that are specific to the implementation
details of the authorization server where they are used SHOULD
utilize a vendor-specific prefix that is not likely to conflict with
other registered values (e.g., begin with &#8216;<a href="#id111"><span class="problematic" id="id112">companyname_</span></a>&#8216;).</p>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8.2">https://tools.ietf.org/html/rfc6749.html#section-8.2</a> )</p>
</div>
<div class="section" id="defining-new-authorization-grant-types">
<span id="oauth-8-3"></span><h3><a class="toc-backref" href="#id82">8.3.  Defining New Authorization Grant Types</a><a class="headerlink" href="#defining-new-authorization-grant-types" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>New authorization grant types can be defined by assigning them a
unique absolute URI for use with the &#8220;grant_type&#8221; parameter.  If the
extension grant type requires additional token endpoint parameters,
they MUST be registered in the OAuth Parameters registry as described
by Section 11.2.</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8.3">https://tools.ietf.org/html/rfc6749.html#section-8.3</a> )</p>
</div>
<div class="section" id="defining-new-authorization-endpoint-response-types">
<span id="oauth-8-4"></span><h3><a class="toc-backref" href="#id83">8.4.  Defining New Authorization Endpoint Response Types</a><a class="headerlink" href="#defining-new-authorization-endpoint-response-types" title="Permalink to this headline">¶</a></h3>
<p>New response types for use with the authorization endpoint are
defined and registered in the Authorization Endpoint Response Types
registry following the procedure in Section 11.3.  Response type
names MUST conform to the response-type ABNF.</p>
<dl class="docutils">
<dt>::</dt>
<dd>response-type  = response-name <a href="#id14"><span class="problematic" id="id15">*</span></a>( SP response-name )
response-name  = 1*response-char
response-char  = &#8220;_&#8221; / DIGIT / ALPHA</dd>
</dl>
<p>If a response type contains one or more space characters (%x20), it
is compared as a space-delimited list of values in which the order of
values does not matter.  Only one order of values can be registered,
which covers all other arrangements of the same set of values.</p>
<p>For example, the response type &#8220;token code&#8221; is left undefined by this
specification.  However, an extension can define and register the
&#8220;token code&#8221; response type.  Once registered, the same combination
cannot be registered as &#8220;code token&#8221;, but both values can be used to
denote the same response type.</p>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8.4">https://tools.ietf.org/html/rfc6749.html#section-8.4</a> )</p>
</div>
<div class="section" id="defining-additional-error-codes">
<span id="oauth-8-5"></span><h3><a class="toc-backref" href="#id84">8.5.  Defining Additional Error Codes</a><a class="headerlink" href="#defining-additional-error-codes" title="Permalink to this headline">¶</a></h3>
<p>In cases where protocol extensions (i.e., access token types,
extension parameters, or extension grant types) require additional
error codes to be used with the authorization code grant error
response (Section 4.1.2.1), the implicit grant error response
(Section 4.2.2.1), the token error response (Section 5.2), or the
resource access error response (Section 7.2), such error codes MAY be
defined.</p>
<p>Extension error codes MUST be registered (following the procedures in
Section 11.4) if the extension they are used in conjunction with is a
registered access token type, a registered endpoint parameter, or an
extension grant type.  Error codes used with unregistered extensions
MAY be registered.</p>
<p>Error codes MUST conform to the error ABNF and SHOULD be prefixed by
an identifying name when possible.  For example, an error identifying
an invalid value set to the extension parameter &#8220;example&#8221; SHOULD be
named &#8220;example_invalid&#8221;.</p>
<dl class="docutils">
<dt>::</dt>
<dd>error      = 1*error-char
error-char = %x20-21 / %x23-5B / %x5D-7E</dd>
</dl>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-8.5">https://tools.ietf.org/html/rfc6749.html#section-8.5</a> )</p>
</div>
</div>
<div class="section" id="native-applications">
<span id="oauth-9"></span><h2><a class="toc-backref" href="#id85">9. Native Applications</a><a class="headerlink" href="#native-applications" title="Permalink to this headline">¶</a></h2>
<p>Native applications are clients installed and executed
on the device used by the resource owner
(i.e., desktop application, native mobile application).</p>
<p>Native applications require special consideration
related to security,
platform capabilities,
and overall end-user experience.</p>
<p>The authorization endpoint requires interaction
between the client and the resource owner&#8217;s user-agent.
Native applications can invoke an external user-agent
or embed a user-agent within the application.</p>
<p>For example:</p>
<blockquote>
<div><ul>
<li><p class="first">External user-agent</p>
<ul class="simple">
<li>the native application can capture the response</li>
</ul>
<p>from the authorization server
using a redirection URI with a <strong>scheme</strong>
registered with the operating system
to invoke the client as the handler,
manual copy-and-paste of the credentials,
running a local web server,
installing a user-agent extension,
or by providing a redirection URI identifying a server-hosted
resource under the client&#8217;s control,
which in turn makes the response available to the native application.</p>
</li>
<li><p class="first">Embedded user-agent</p>
<ul class="simple">
<li>the native application obtains the response</li>
</ul>
<p>by directly communicating with the embedded user-agent
by monitoring state changes emitted during the resource load,
or accessing the user-agent&#8217;s cookies storage.</p>
</li>
</ul>
</div></blockquote>
<p>When choosing between an external or embedded user-agent,
developers should consider the following:</p>
<blockquote>
<div><ul>
<li><p class="first">An external user-agent may improve completion rate,
as the resource owner may already have an active session
with the authorization server,
removing the need to re-authenticate.</p>
<p>It provides a familiar end-user experience and functionality.
The resource owner may also rely on user-agent features
or extensions to assist with authentication
(e.g., password manager, 2-factor device reader).</p>
</li>
<li><p class="first">An embedded user-agent may offer improved usability,
as it removes the need to switch context and open new windows.</p>
</li>
<li><p class="first">An embedded user-agent poses a security challenge
because resource owners are authenticating in an unidentified window
without access to the visual protections
found in most external user-agents.</p>
<p>An embedded user-agent educates end-users to trust unidentified
requests for authentication
(making phishing attacks easier to execute).</p>
</li>
</ul>
</div></blockquote>
<p>When choosing between the implicit grant type
and the authorization code grant type, the following should be considered:</p>
<blockquote>
<div><ul class="simple">
<li>Native applications that use the authorization code grant type
SHOULD do so without using client credentials,
due to the native application&#8217;s inability
to keep client credentials confidential.</li>
<li>When using the implicit grant type flow,
a refresh token is not returned,
which requires repeating the authorization process
once the access token expires.</li>
</ul>
</div></blockquote>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-9">http://tools.ietf.org/html/rfc6749.html#section-9</a> )</p>
</div>
<div class="section" id="security-considerations">
<span id="oauth-10"></span><h2><a class="toc-backref" href="#id86">10. Security Considerations</a><a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>As a flexible and extensible framework, OAuth&#8217;s security
considerations depend on many factors.  The following sections
provide implementers with security guidelines focused on the three
client profiles described in Section 2.1: web application,
user-agent-based application, and native application.</p>
<p>A comprehensive OAuth security model and analysis, as well as
background for the protocol design, is provided by
[OAuth-THREATMODEL].</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10">https://tools.ietf.org/html/rfc6749.html#section-10</a> )</p>
<div class="section" id="oauth-10-1">
<span id="id16"></span><h3><a class="toc-backref" href="#id87">10.1.  Client Authentication</a><a class="headerlink" href="#oauth-10-1" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The authorization server establishes client credentials with web
application clients for the purpose of client authentication.  The
authorization server is encouraged to consider stronger client
authentication means than a client password.  Web application clients
MUST ensure confidentiality of client passwords and other client
credentials.</p>
<p>The authorization server MUST NOT issue client passwords or other
client credentials to native application or user-agent-based
application clients for the purpose of client authentication.  The
authorization server MAY issue a client password or other credentials
for a specific installation of a native application client on a
specific device.</p>
<p>When client authentication is not possible, the authorization server
SHOULD employ other means to validate the client&#8217;s identity &#8211; for
example, by requiring the registration of the client redirection URI
or enlisting the resource owner to confirm identity.  A valid
redirection URI is not sufficient to verify the client&#8217;s identity
when asking for resource owner authorization but can be used to
prevent delivering credentials to a counterfeit client after
obtaining resource owner authorization.</p>
<p>The authorization server must consider the security implications of
interacting with unauthenticated clients and take measures to limit
the potential exposure of other credentials (e.g., refresh tokens)
issued to such clients.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.1">https://tools.ietf.org/html/rfc6749.html#section-10.1</a> )</p>
</div>
<div class="section" id="client-impersonation">
<span id="oauth-10-2"></span><h3><a class="toc-backref" href="#id88">10.2.  Client Impersonation</a><a class="headerlink" href="#client-impersonation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A malicious client can impersonate another client and obtain access
to protected resources if the impersonated client fails to, or is
unable to, keep its client credentials confidential.</p>
<p>The authorization server MUST authenticate the client whenever
possible.  If the authorization server cannot authenticate the client
due to the client&#8217;s nature, the authorization server MUST require the
registration of any redirection URI used for receiving authorization
responses and SHOULD utilize other means to protect resource owners
from such potentially malicious clients.  For example, the
authorization server can engage the resource owner to assist in
identifying the client and its origin.</p>
<p>The authorization server SHOULD enforce explicit resource owner
authentication and provide the resource owner with information about
the client and the requested authorization scope and lifetime.  It is
up to the resource owner to review the information in the context of
the current client and to authorize or deny the request.</p>
<p>The authorization server SHOULD NOT process repeated authorization
requests automatically (without active resource owner interaction)
without authenticating the client or relying on other measures to
ensure that the repeated request comes from the original client and
not an impersonator.</p>
</div></blockquote>
<p>(<a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.2">https://tools.ietf.org/html/rfc6749.html#section-10.2</a> )</p>
</div>
<div class="section" id="access-tokens">
<span id="oauth-10-3"></span><h3><a class="toc-backref" href="#id89">10.3. Access Tokens</a><a class="headerlink" href="#access-tokens" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>アクセストークンはクレデンシャル</li>
</ul>
</div>
<p>Access token credentials
(as well as any confidential access token attributes)
MUST be kept confidential in transit and storage,
and only shared among the <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a>,
the <a class="reference internal" href="#term-resource-servers"><em class="xref std std-term">resource servers</em></a> the access token is valid for,
and the client to whom the access token is issued.
Access token credentials MUST only be transmitted
using TLS as described in Section 1.6
with server authentication as defined by <a class="reference internal" href="#term-rfc2818"><em class="xref std std-term">[RFC2818]</em></a>.</p>
<p>When using the <em class="xref std std-ref">implicit grant type</em>,
the access token is transmitted in the <em class="xref std std-term">URI fragment</em>,
which can expose it to unauthorized parties.</p>
<p>The <a class="reference internal" href="#term-authorization-server"><em class="xref std std-term">authorization server</em></a> MUST ensure that
access tokens cannot be generated, modified,
or guessed to produce valid access tokens by unauthorized parties.</p>
<p>The client SHOULD request access tokens with the minimal scope necessary.
The authorization server SHOULD take the client identity into account
when choosing how to honor the requested scope
and MAY issue an access token with less rights than requested.</p>
<p>This specification does not provide any methods
for the resource server to ensure that an access token
presented to it by a given client was issued to that client
by the authorization server.</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#section-10.3">http://tools.ietf.org/html/rfc6749.html#section-10.3</a> )</p>
</div>
<div class="section" id="refresh-tokens">
<span id="oauth-10-4"></span><h3><a class="toc-backref" href="#id90">10.4.  Refresh Tokens</a><a class="headerlink" href="#refresh-tokens" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Authorization servers MAY issue refresh tokens to web application
clients and native application clients.</p>
<p>Refresh tokens MUST be kept confidential in transit and storage, and
shared only among the authorization server and the client to whom the
refresh tokens were issued.  The authorization server MUST maintain
the binding between a refresh token and the client to whom it was
issued.  Refresh tokens MUST only be transmitted using TLS as
described in Section 1.6 with server authentication as defined by
[RFC2818].</p>
<p>The authorization server MUST verify the binding between the refresh
token and client identity whenever the client identity can be
authenticated.  When client authentication is not possible, the
authorization server SHOULD deploy other means to detect refresh
token abuse.</p>
<p>For example, the authorization server could employ refresh token
rotation in which a new refresh token is issued with every access
token refresh response.  The previous refresh token is invalidated
but retained by the authorization server.  If a refresh token is
compromised and subsequently used by both the attacker and the
legitimate client, one of them will present an invalidated refresh
token, which will inform the authorization server of the breach.</p>
<p>The authorization server MUST ensure that refresh tokens cannot be
generated, modified, or guessed to produce valid refresh tokens by
unauthorized parties.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.4">https://tools.ietf.org/html/rfc6749.html#section-10.4</a> )</p>
</div>
<div class="section" id="authorization-codes">
<span id="oauth-10-5"></span><h3><a class="toc-backref" href="#id91">10.5.  Authorization Codes</a><a class="headerlink" href="#authorization-codes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The transmission of authorization codes SHOULD be made over a secure
channel, and the client SHOULD require the use of TLS with its
redirection URI if the URI identifies a network resource.  Since
authorization codes are transmitted via user-agent redirections, they
could potentially be disclosed through user-agent history and HTTP
referrer headers.</p>
<p>Authorization codes operate as plaintext bearer credentials, used to
verify that the resource owner who granted authorization at the
authorization server is the same resource owner returning to the
client to complete the process.  Therefore, if the client relies on
the authorization code for its own resource owner authentication, the
client redirection endpoint MUST require the use of TLS.</p>
<p>Authorization codes MUST be short lived and single-use.  If the
authorization server observes multiple attempts to exchange an
authorization code for an access token, the authorization server
SHOULD attempt to revoke all access tokens already granted based on
the compromised authorization code.</p>
<p>If the client can be authenticated, the authorization servers MUST
authenticate the client and ensure that the authorization code was
issued to the same client.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.5">https://tools.ietf.org/html/rfc6749.html#section-10.5</a> )</p>
</div>
<div class="section" id="authorization-code-redirection-uri-manipulation">
<span id="oauth-10-6"></span><h3><a class="toc-backref" href="#id92">10.6.  Authorization Code Redirection URI Manipulation</a><a class="headerlink" href="#authorization-code-redirection-uri-manipulation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When requesting authorization using the authorization code grant
type, the client can specify a redirection URI via the &#8220;redirect_uri&#8221;
parameter.  If an attacker can manipulate the value of the
redirection URI, it can cause the authorization server to redirect
the resource owner user-agent to a URI under the control of the
attacker with the authorization code.</p>
<p>An attacker can create an account at a legitimate client and initiate
the authorization flow.  When the attacker&#8217;s user-agent is sent to
the authorization server to grant access, the attacker grabs the
authorization URI provided by the legitimate client and replaces the
client&#8217;s redirection URI with a URI under the control of the
attacker.  The attacker then tricks the victim into following the
manipulated link to authorize access to the legitimate client.</p>
<p>Once at the authorization server, the victim is prompted with a
normal, valid request on behalf of a legitimate and trusted client,
and authorizes the request.  The victim is then redirected to an
endpoint under the control of the attacker with the authorization
code.  The attacker completes the authorization flow by sending the
authorization code to the client using the original redirection URI
provided by the client.  The client exchanges the authorization code
with an access token and links it to the attacker&#8217;s client account,
which can now gain access to the protected resources authorized by
the victim (via the client).</p>
<p>In order to prevent such an attack, the authorization server MUST
ensure that the redirection URI used to obtain the authorization code
is identical to the redirection URI provided when exchanging the
authorization code for an access token.  The authorization server
MUST require public clients and SHOULD require confidential clients
to register their redirection URIs.  If a redirection URI is provided
in the request, the authorization server MUST validate it against the
registered value.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.6">https://tools.ietf.org/html/rfc6749.html#section-10.6</a> )</p>
</div>
<div class="section" id="oauth-10-7">
<span id="id17"></span><h3><a class="toc-backref" href="#id93">10.7.  Resource Owner Password Credentials</a><a class="headerlink" href="#oauth-10-7" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The resource owner password credentials grant type is often used for
legacy or migration reasons.  It reduces the overall risk of storing
usernames and passwords by the client but does not eliminate the need
to expose highly privileged credentials to the client.</p>
<p>This grant type carries a higher risk than other grant types because
it maintains the password anti-pattern this protocol seeks to avoid.
The client could abuse the password, or the password could
unintentionally be disclosed to an attacker (e.g., via log files or
other records kept by the client).</p>
<p>Additionally, because the resource owner does not have control over
the authorization process (the resource owner&#8217;s involvement ends when
it hands over its credentials to the client), the client can obtain
access tokens with a broader scope than desired by the resource
owner.  The authorization server should consider the scope and
lifetime of access tokens issued via this grant type.</p>
<p>The authorization server and client SHOULD minimize use of this grant
type and utilize other grant types whenever possible.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.7">https://tools.ietf.org/html/rfc6749.html#section-10.7</a> )</p>
</div>
<div class="section" id="request-confidentiality">
<span id="oauth-10-8"></span><h3><a class="toc-backref" href="#id94">10.8.  Request Confidentiality</a><a class="headerlink" href="#request-confidentiality" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Access tokens, refresh tokens, resource owner passwords, and client
credentials MUST NOT be transmitted in the clear.  Authorization
codes SHOULD NOT be transmitted in the clear.</p>
<p>The &#8220;state&#8221; and &#8220;scope&#8221; parameters SHOULD NOT include sensitive
client or resource owner information in plain text, as they can be
transmitted over insecure channels or stored insecurely.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.8">https://tools.ietf.org/html/rfc6749.html#section-10.8</a> )</p>
</div>
<div class="section" id="ensuring-endpoint-authenticity">
<span id="oauth-10-9"></span><h3><a class="toc-backref" href="#id95">10.9.  Ensuring Endpoint Authenticity</a><a class="headerlink" href="#ensuring-endpoint-authenticity" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>In order to prevent man-in-the-middle attacks, the authorization
server MUST require the use of TLS with server authentication as
defined by [RFC2818] for any request sent to the authorization and
token endpoints.  The client MUST validate the authorization server&#8217;s
TLS certificate as defined by [RFC6125] and in accordance with its
requirements for server identity authentication.</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.9">https://tools.ietf.org/html/rfc6749.html#section-10.9</a> )</p>
</div>
<div class="section" id="credentials-guessing-attacks">
<span id="oauth-10-10"></span><h3><a class="toc-backref" href="#id96">10.10.  Credentials-Guessing Attacks</a><a class="headerlink" href="#credentials-guessing-attacks" title="Permalink to this headline">¶</a></h3>
<p>The authorization server MUST prevent attackers
from guessing access tokens, authorization codes, refresh tokens,
resource owner passwords, and client credentials.</p>
<p>The probability of an attacker guessing generated tokens
(and other credentials not intended for handling by end-users)
MUST be less than or equal to 2^(-128) and SHOULD be less than
or equal to 2^(-160).</p>
<p>The authorization server MUST utilize other means
to protect credentials intended for end-user usage.</p>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.10">https://tools.ietf.org/html/rfc6749.html#section-10.10</a> )</p>
</div>
<div class="section" id="phishing-attacks">
<span id="oauth-10-11"></span><h3><a class="toc-backref" href="#id97">10.11.  Phishing Attacks</a><a class="headerlink" href="#phishing-attacks" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Wide deployment of this and similar protocols may cause end-users to
become inured to the practice of being redirected to websites where
they are asked to enter their passwords.  If end-users are not
careful to verify the authenticity of these websites before entering
their credentials, it will be possible for attackers to exploit this
practice to steal resource owners&#8217; passwords.</p>
<p>Service providers should attempt to educate end-users about the risks
phishing attacks pose and should provide mechanisms that make it easy
for end-users to confirm the authenticity of their sites.  Client
developers should consider the security implications of how they
interact with the user-agent (e.g., external, embedded), and the
ability of the end-user to verify the authenticity of the
authorization server.</p>
<p>To reduce the risk of phishing attacks, the authorization servers
MUST require the use of TLS on every endpoint used for end-user
interaction.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.11">https://tools.ietf.org/html/rfc6749.html#section-10.11</a> )</p>
</div>
<div class="section" id="cross-site-request-forgery">
<span id="oauth-10-12"></span><h3><a class="toc-backref" href="#id98">10.12.  Cross-Site Request Forgery</a><a class="headerlink" href="#cross-site-request-forgery" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Cross-site request forgery (CSRF) is an exploit in which an attacker
causes the user-agent of a victim end-user to follow a malicious URI
(e.g., provided to the user-agent as a misleading link, image, or
redirection) to a trusting server (usually established via the
presence of a valid session cookie).</p>
<p>A CSRF attack against the client&#8217;s redirection URI allows an attacker
to inject its own authorization code or access token, which can
result in the client using an access token associated with the
attacker&#8217;s protected resources rather than the victim&#8217;s (e.g., save
the victim&#8217;s bank account information to a protected resource
controlled by the attacker).</p>
<p>The client MUST implement CSRF protection for its redirection URI.
This is typically accomplished by requiring any request sent to the
redirection URI endpoint to include a value that binds the request to
the user-agent&#8217;s authenticated state (e.g., a hash of the session
cookie used to authenticate the user-agent).  The client SHOULD
utilize the &#8220;state&#8221; request parameter to deliver this value to the
authorization server when making an authorization request.</p>
<p>Once authorization has been obtained from the end-user, the
authorization server redirects the end-user&#8217;s user-agent back to the
client with the required binding value contained in the &#8220;state&#8221;
parameter.  The binding value enables the client to verify the
validity of the request by matching the binding value to the
user-agent&#8217;s authenticated state.  The binding value used for CSRF
protection MUST contain a non-guessable value (as described in
Section 10.10), and the user-agent&#8217;s authenticated state (e.g.,
session cookie, HTML5 local storage) MUST be kept in a location
accessible only to the client and the user-agent (i.e., protected by
same-origin policy).</p>
<p>A CSRF attack against the authorization server&#8217;s authorization
endpoint can result in an attacker obtaining end-user authorization
for a malicious client without involving or alerting the end-user.</p>
<p>The authorization server MUST implement CSRF protection for its
authorization endpoint and ensure that a malicious client cannot
obtain authorization without the awareness and explicit consent of
the resource owner.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.12">https://tools.ietf.org/html/rfc6749.html#section-10.12</a> )</p>
</div>
<div class="section" id="clickjacking">
<span id="oauth-10-13"></span><h3><a class="toc-backref" href="#id99">10.13.  Clickjacking</a><a class="headerlink" href="#clickjacking" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In a clickjacking attack, an attacker registers a legitimate client
and then constructs a malicious site in which it loads the
authorization server&#8217;s authorization endpoint web page in a
transparent iframe overlaid on top of a set of dummy buttons, which
are carefully constructed to be placed directly under important
buttons on the authorization page.  When an end-user clicks a
misleading visible button, the end-user is actually clicking an
invisible button on the authorization page (such as an &#8220;Authorize&#8221;
button).  This allows an attacker to trick a resource owner into
granting its client access without the end-user&#8217;s knowledge.</p>
<p>To prevent this form of attack, native applications SHOULD use
external browsers instead of embedding browsers within the
application when requesting end-user authorization.  For most newer
browsers, avoidance of iframes can be enforced by the authorization
server using the (non-standard) &#8220;x-frame-options&#8221; header.  This
header can have two values, &#8220;deny&#8221; and &#8220;sameorigin&#8221;, which will block
any framing, or framing by sites with a different origin,
respectively.  For older browsers, JavaScript frame-busting
techniques can be used but may not be effective in all browsers.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.13">https://tools.ietf.org/html/rfc6749.html#section-10.13</a> )</p>
</div>
<div class="section" id="code-injection-and-input-validation">
<span id="oauth-10-14"></span><h3><a class="toc-backref" href="#id100">10.14.  Code Injection and Input Validation</a><a class="headerlink" href="#code-injection-and-input-validation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A code injection attack occurs when an input or otherwise external
variable is used by an application unsanitized and causes
modification to the application logic.  This may allow an attacker to
gain access to the application device or its data, cause denial of
service, or introduce a wide range of malicious side-effects.</p>
<p>The authorization server and client MUST sanitize (and validate when
possible) any value received &#8211; in particular, the value of the
&#8220;state&#8221; and &#8220;redirect_uri&#8221; parameters.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.14">https://tools.ietf.org/html/rfc6749.html#section-10.14</a> )</p>
</div>
<div class="section" id="open-redirectors">
<span id="oauth-10-15"></span><h3><a class="toc-backref" href="#id101">10.15.  Open Redirectors</a><a class="headerlink" href="#open-redirectors" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The authorization server, authorization endpoint, and client
redirection endpoint can be improperly configured and operate as open
redirectors.  An open redirector is an endpoint using a parameter to
automatically redirect a user-agent to the location specified by the
parameter value without any validation.</p>
<p>Open redirectors can be used in phishing attacks, or by an attacker
to get end-users to visit malicious sites by using the URI authority
component of a familiar and trusted destination.  In addition, if the
authorization server allows the client to register only part of the
redirection URI, an attacker can use an open redirector operated by
the client to construct a redirection URI that will pass the
authorization server validation but will send the authorization code
or access token to an endpoint under the control of the attacker.</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.15">https://tools.ietf.org/html/rfc6749.html#section-10.15</a> )</p>
</div>
<div class="section" id="misuse-of-access-token-to-impersonate-resource-owner-in-implicit-flow">
<span id="oauth-10-16"></span><h3><a class="toc-backref" href="#id102">10.16.  Misuse of Access Token to Impersonate Resource Owner in Implicit Flow</a><a class="headerlink" href="#misuse-of-access-token-to-impersonate-resource-owner-in-implicit-flow" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For public clients using implicit flows, this specification does not
provide any method for the client to determine what client an access
token was issued to.</p>
<p>A resource owner may willingly delegate access to a resource by
granting an access token to an attacker&#8217;s malicious client.  This may
be due to phishing or some other pretext.  An attacker may also steal
a token via some other mechanism.  An attacker may then attempt to
impersonate the resource owner by providing the access token to a
legitimate public client.</p>
<p>In the implicit flow (response_type=token), the attacker can easily
switch the token in the response from the authorization server,
replacing the real access token with the one previously issued to the
attacker.</p>
<p>Servers communicating with native applications that rely on being
passed an access token in the back channel to identify the user of
the client may be similarly compromised by an attacker creating a
compromised application that can inject arbitrary stolen access
tokens.</p>
<p>Any public client that makes the assumption that only the resource
owner can present it with a valid access token for the resource is
vulnerable to this type of attack.</p>
<p>This type of attack may expose information about the resource owner
at the legitimate client to the attacker (malicious client).  This
will also allow the attacker to perform operations at the legitimate
client with the same permissions as the resource owner who originally
granted the access token or authorization code.</p>
<p>Authenticating resource owners to clients is out of scope for this
specification.  Any specification that uses the authorization process
as a form of delegated end-user authentication to the client (e.g.,
third-party sign-in service) MUST NOT use the implicit flow without
additional security mechanisms that would enable the client to
determine if the access token was issued for its use (e.g., audience-
restricting the access token).</p>
</div></blockquote>
<p>( <a class="reference external" href="https://tools.ietf.org/html/rfc6749.html#section-10.16">https://tools.ietf.org/html/rfc6749.html#section-10.16</a> )</p>
</div>
</div>
<div class="section" id="iana-considerations">
<span id="oauth-11"></span><h2><a class="toc-backref" href="#id103">11.  IANA Considerations</a><a class="headerlink" href="#iana-considerations" title="Permalink to this headline">¶</a></h2>
<p>(v.22)</p>
</div>
<div class="section" id="references">
<span id="oauth-12"></span><h2><a class="toc-backref" href="#id104">12. References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-12">http://tools.ietf.org/html/rfc6749#section-12</a> )</p>
<div class="section" id="normative-references">
<span id="oauth-12-1"></span><h3><a class="toc-backref" href="#id105">12.1. Normative References</a><a class="headerlink" href="#normative-references" title="Permalink to this headline">¶</a></h3>
<dl class="glossary docutils">
<dt id="term-rfc2119">[RFC2119]</dt>
<dd>Bradner, S., &#8220;Key words for use in RFCs to Indicate
Requirement Levels&#8221;, BCP 14, RFC 2119, March 1997.</dd>
<dt id="term-rfc2246">[RFC2246]</dt>
<dd>Dierks, T. and C. Allen, &#8220;The TLS Protocol Version 1.0&#8221;,
RFC 2246, January 1999.</dd>
<dt id="term-rfc2616">[RFC2616]</dt>
<dd>Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
Masinter, L., Leach, P., and T. Berners-Lee, &#8220;Hypertext
Transfer Protocol &#8211; HTTP/1.1&#8221;, RFC 2616, June 1999.</dd>
<dt id="term-rfc2617">[RFC2617]</dt>
<dd>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
Leach, P., Luotonen, A., and L. Stewart, &#8220;HTTP
Authentication: Basic and Digest Access Authentication&#8221;,
RFC 2617, June 1999.</dd>
<dt id="term-rfc2818">[RFC2818]</dt>
<dd>Rescorla, E., &#8220;HTTP Over TLS&#8221;, RFC 2818, May 2000.</dd>
<dt id="term-rfc3629">[RFC3629]</dt>
<dd>Yergeau, F., &#8220;UTF-8, a transformation format of
ISO 10646&#8221;, STD 63, RFC 3629, November 2003.</dd>
<dt id="term-rfc3986">[RFC3986]</dt>
<dd>Berners-Lee, T., Fielding, R., and L. Masinter, &#8220;Uniform
Resource Identifier (URI): Generic Syntax&#8221;, STD 66,
RFC 3986, January 2005.</dd>
<dt id="term-rfc4627">[RFC4627]</dt>
<dd>Crockford, D., &#8220;The application/json Media Type for
JavaScript Object Notation (JSON)&#8221;, RFC 4627, July 2006.</dd>
<dt id="term-rfc4949">[RFC4949]</dt>
<dd>Shirey, R., &#8220;Internet Security Glossary, Version 2&#8221;,
RFC 4949, August 2007.</dd>
<dt id="term-rfc5226">[RFC5226]</dt>
<dd>Narten, T. and H. Alvestrand, &#8220;Guidelines for Writing an
IANA Considerations Section in RFCs&#8221;, BCP 26, RFC 5226,
May 2008.</dd>
<dt id="term-rfc5234">[RFC5234]</dt>
<dd>Crocker, D. and P. Overell, &#8220;Augmented BNF for Syntax
Specifications: ABNF&#8221;, STD 68, RFC 5234, January 2008.</dd>
<dt id="term-rfc5246">[RFC5246]</dt>
<dd>Dierks, T. and E. Rescorla, &#8220;The Transport Layer Security
(TLS) Protocol Version 1.2&#8221;, RFC 5246, August 2008.</dd>
<dt id="term-rfc6125">[RFC6125]</dt>
<dd>Saint-Andre, P. and J. Hodges, &#8220;Representation and
Verification of Domain-Based Application Service Identity
within Internet Public Key Infrastructure Using X.509
(PKIX) Certificates in the Context of Transport Layer
Security (TLS)&#8221;, RFC 6125, March 2011.</dd>
<dt id="term-usascii">[USASCII]</dt>
<dd>American National Standards Institute, &#8220;Coded Character
Set &#8211; 7-bit American Standard Code for Information
Interchange&#8221;, ANSI X3.4, 1986.</dd>
<dt id="term-w3c-rec-html401-19991224">[W3C.REC-html401-19991224]</dt>
<dd>Raggett, D., Le Hors, A., and I. Jacobs, &#8220;HTML 4.01
Specification&#8221;, World Wide Web Consortium
Recommendation REC-html401-19991224, December 1999,
&lt;<a class="reference external" href="http://www.w3.org/TR/1999/REC-html401-19991224">http://www.w3.org/TR/1999/REC-html401-19991224</a>&gt;.</dd>
<dt id="term-w3c-rec-xml-20081126">[W3C.REC-xml-20081126]</dt>
<dd><p class="first">Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,
and F. Yergeau, &#8220;Extensible Markup Language (XML) 1.0
(Fifth Edition)&#8221;, World Wide Web Consortium</p>
<blockquote>
<div>Recommendation REC-xml-20081126, November 2008,</div></blockquote>
<p class="last">&lt;<a class="reference external" href="http://www.w3.org/TR/2008/REC-xml-20081126">http://www.w3.org/TR/2008/REC-xml-20081126</a>&gt;.</p>
</dd>
</dl>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-12.1">http://tools.ietf.org/html/rfc6749#section-12.1</a> )</p>
</div>
<div class="section" id="informative-references">
<span id="oauth-12-2"></span><h3><a class="toc-backref" href="#id106">12.2. Informative References</a><a class="headerlink" href="#informative-references" title="Permalink to this headline">¶</a></h3>
<dl class="glossary docutils">
<dt id="term-oauth-http-mac">[OAuth-HTTP-MAC]</dt>
<dd>Hammer-Lahav, E., Ed., &#8220;HTTP Authentication: MAC Access
Authentication&#8221;, Work in Progress, February 2012.</dd>
<dt id="term-oauth-saml2">[OAuth-SAML2]</dt>
<dd>Campbell, B. and C. Mortimore, &#8220;SAML 2.0 Bearer Assertion
Profiles for OAuth 2.0&#8221;, Work in Progress, September 2012.</dd>
<dt id="term-oauth-threatmodel">[OAuth-THREATMODEL]</dt>
<dd>Lodderstedt, T., Ed., McGloin, M., and P. Hunt, &#8220;OAuth 2.0
Threat Model and Security Considerations&#8221;, Work
in Progress, October 2012.</dd>
<dt id="term-oauth-wrap">[OAuth-WRAP]</dt>
<dd>Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, &#8220;OAuth
Web Resource Authorization Profiles&#8221;, Work in Progress,
January 2010.</dd>
<dt id="term-rfc5849">[RFC5849]</dt>
<dd>Hammer-Lahav, E., &#8220;The OAuth 1.0 Protocol&#8221;, RFC 5849,
April 2010.</dd>
<dt id="term-rfc6750">[RFC6750]</dt>
<dd>Jones, M. and D. Hardt, &#8220;The OAuth 2.0 Authorization
Framework: Bearer Token Usage&#8221;, RFC 6750, October 2012.</dd>
</dl>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749#section-12.2">http://tools.ietf.org/html/rfc6749#section-12.2</a> )</p>
</div>
</div>
<div class="section" id="oauth-13">
<span id="id18"></span><h2><a class="toc-backref" href="#id107">13.  References</a><a class="headerlink" href="#oauth-13" title="Permalink to this headline">¶</a></h2>
<p>(v.22)</p>
</div>
<div class="section" id="appendix-a-augmented-backus-naur-form-abnf-syntax">
<span id="oauth-apendix-a"></span><h2><a class="toc-backref" href="#id108">Appendix A. Augmented Backus-Naur Form (ABNF) Syntax</a><a class="headerlink" href="#appendix-a-augmented-backus-naur-form-abnf-syntax" title="Permalink to this headline">¶</a></h2>
<p>This section provides Augmented Backus-Naur Form (ABNF) syntax
descriptions for the elements defined in this specification using the
notation of <a class="reference internal" href="#term-rfc5234"><em class="xref std std-term">[RFC5234]</em></a>.  The ABNF below is defined in terms of Unicode
code points <a class="reference internal" href="#term-w3c-rec-xml-20081126"><em class="xref std std-term">[W3C.REC-xml-20081126]</em></a>; these characters are typically
encoded in UTF-8.  Elements are presented in the order first defined.</p>
<p>Some of the definitions that follow use the &#8220;URI-reference&#8221;
definition from <a class="reference internal" href="#term-rfc3986"><em class="xref std std-term">[RFC3986]</em></a>.</p>
<p>Some of the definitions that follow use these common definitions:</p>
<div class="highlight-python"><pre>VSCHAR     = %x20-7E
NQCHAR     = %x21 / %x23-5B / %x5D-7E
NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                    %xE000-FFFD / %x10000-10FFFF</pre>
</div>
<p>(The UNICODECHARNOCRLF definition is based upon the Char definition
in Section 2.2 of <a class="reference internal" href="#term-w3c-rec-xml-20081126"><em class="xref std std-term">[W3C.REC-xml-20081126]</em></a>, but omitting the Carriage
Return and Linefeed characters.)</p>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#appendix-A">http://tools.ietf.org/html/rfc6749.html#appendix-A</a> )</p>
<div class="section" id="a-1-client-id-syntax">
<span id="oauth-apendix-a-1"></span><h3><a class="toc-backref" href="#id109">A.1. &#8220;client_id&#8221; Syntax</a><a class="headerlink" href="#a-1-client-id-syntax" title="Permalink to this headline">¶</a></h3>
<p>The &#8220;client_id&#8221; element is defined in <a class="reference internal" href="#oauth-2-3-1"><em>Section 2.3.1</em></a>:</p>
<div class="highlight-python"><pre>client-id     = *VSCHAR</pre>
</div>
<p>( <a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#appendix-A.1">http://tools.ietf.org/html/rfc6749.html#appendix-A.1</a> )</p>
</div>
<div class="section" id="a-4-scope-syntax">
<span id="oauth-apendix-a-4"></span><h3><a class="toc-backref" href="#id110">A.4. &#8220;scope&#8221; Syntax</a><a class="headerlink" href="#a-4-scope-syntax" title="Permalink to this headline">¶</a></h3>
<p>The &#8220;scope&#8221; element is defined in <a class="reference internal" href="#oauth-3-3"><em>Section 3.3</em></a>:</p>
<div class="highlight-python"><pre>scope       = scope-token *( SP scope-token )
scope-token = 1*NQCHAR</pre>
</div>
<p>(<a class="reference external" href="http://tools.ietf.org/html/rfc6749.html#appendix-A.4">http://tools.ietf.org/html/rfc6749.html#appendix-A.4</a>)</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Digital Identity</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="oauth_bearer.html">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2011, HDKNR.COM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>