

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>kombu.transport.pyamqp &mdash; Kombu Docs 1 documentation</title>
    
    <link rel="stylesheet" href="../static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/theme_extras.js"></script>
    <link rel="top" title="Kombu Docs 1 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
    <link rel="next" title="kombu.transport.pika" href="kombu.transport.pika.html" />
    <link rel="prev" title="&lt;no title&gt;" href="kombu.transport.librabbitmq.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Kombu Docs 1 documentation</span></a></h1>
        <h2 class="heading"><span>kombu.transport.pyamqp</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a href="/">Home</a>:
        «&#160;&#160;<a href="kombu.transport.librabbitmq.html">&lt;no title&gt;</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="kombu.transport.pika.html">kombu.transport.pika</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <span class="target" id="module-kombu.transport.pyamqp"></span><div class="section" id="kombu-transport-pyamqp">
<h1>kombu.transport.pyamqp<a class="headerlink" href="#kombu-transport-pyamqp" title="Permalink to this headline">¶</a></h1>
<p>pure python amqp transport.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">copyright:</th><td class="field-body"><ol class="first loweralpha simple" start="3">
<li>2009 - 2012 by Ask Solem.</li>
</ol>
</td>
</tr>
<tr class="field-even field"><th class="field-name">license:</th><td class="field-body"><p class="first last">BSD, see LICENSE for more details.</p>
</td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#transport" id="id1">Transport</a></li>
<li><a class="reference internal" href="#connection" id="id2">Connection</a></li>
<li><a class="reference internal" href="#channel" id="id3">Channel</a></li>
<li><a class="reference internal" href="#message" id="id4">Message</a></li>
</ul>
</div>
<div class="section" id="transport">
<h2><a class="toc-backref" href="#id1">Transport</a><a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kombu.transport.pyamqp.Transport">
<em class="property">class </em><tt class="descclassname">kombu.transport.pyamqp.</tt><tt class="descname">Transport</tt><big>(</big><em>client</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="kombu.transport.pyamqp.Transport.Connection">
<em class="property">class </em><tt class="descname">Connection</tt><big>(</big><em>host='localhost'</em>, <em>userid='guest'</em>, <em>password='guest'</em>, <em>login_method='AMQPLAIN'</em>, <em>login_response=None</em>, <em>virtual_host='/'</em>, <em>locale='en_US'</em>, <em>client_properties=None</em>, <em>ssl=False</em>, <em>connect_timeout=None</em>, <em>channel_max=None</em>, <em>frame_max=None</em>, <em>heartbeat=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Transport.Connection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="kombu.transport.pyamqp.Transport.Connection.Channel">
<em class="property">class </em><tt class="descname">Channel</tt><big>(</big><em>connection</em>, <em>channel_id=None</em>, <em>auto_decode=True</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Transport.Connection.Channel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="kombu.transport.pyamqp.Transport.Connection.Channel.Message">
<em class="property">class </em><tt class="descname">Message</tt><big>(</big><em>channel</em>, <em>msg</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Transport.Connection.Channel.Message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.Connection.Channel.message_to_python">
<tt class="descclassname">Transport.Connection.Channel.</tt><tt class="descname">message_to_python</tt><big>(</big><em>raw_message</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Transport.Connection.Channel.message_to_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert encoded message body back to a Python value.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.Connection.Channel.prepare_message">
<tt class="descclassname">Transport.Connection.Channel.</tt><tt class="descname">prepare_message</tt><big>(</big><em>message_data</em>, <em>priority=None</em>, <em>content_type=None</em>, <em>content_encoding=None</em>, <em>headers=None</em>, <em>properties=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Transport.Connection.Channel.prepare_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulate data into a AMQP message.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.channel_errors">
<tt class="descclassname">Transport.</tt><tt class="descname">channel_errors</tt><em class="property"> = (&lt;class 'kombu.exceptions.StdChannelError'&gt;, &lt;class 'amqp.exceptions.ChannelError'&gt;)</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.channel_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.close_connection">
<tt class="descclassname">Transport.</tt><tt class="descname">close_connection</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.close_connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.close_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the AMQP broker connection.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.connection_errors">
<tt class="descclassname">Transport.</tt><tt class="descname">connection_errors</tt><em class="property"> = (&lt;class 'amqp.exceptions.ConnectionError'&gt;, &lt;class 'socket.error'&gt;, &lt;type 'exceptions.IOError'&gt;, &lt;type 'exceptions.OSError'&gt;, &lt;type 'exceptions.AttributeError'&gt;)</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.connection_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.create_channel">
<tt class="descclassname">Transport.</tt><tt class="descname">create_channel</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.create_channel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.create_channel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.default_connection_params">
<tt class="descclassname">Transport.</tt><tt class="descname">default_connection_params</tt><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.default_connection_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.default_connection_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.default_port">
<tt class="descclassname">Transport.</tt><tt class="descname">default_port</tt><em class="property"> = 5672</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.default_port" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.drain_events">
<tt class="descclassname">Transport.</tt><tt class="descname">drain_events</tt><big>(</big><em>connection</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.drain_events"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.drain_events" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.driver_name">
<tt class="descclassname">Transport.</tt><tt class="descname">driver_name</tt><em class="property"> = 'py-amqp'</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.driver_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.driver_type">
<tt class="descclassname">Transport.</tt><tt class="descname">driver_type</tt><em class="property"> = 'amqp'</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.driver_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.establish_connection">
<tt class="descclassname">Transport.</tt><tt class="descname">establish_connection</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.establish_connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.establish_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Establish connection to the AMQP broker.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.eventmap">
<tt class="descclassname">Transport.</tt><tt class="descname">eventmap</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.eventmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.eventmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.get_manager">
<tt class="descclassname">Transport.</tt><tt class="descname">get_manager</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.get_manager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.get_manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.heartbeat_check">
<tt class="descclassname">Transport.</tt><tt class="descname">heartbeat_check</tt><big>(</big><em>connection</em>, <em>rate=2</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.heartbeat_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.heartbeat_check" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.is_alive">
<tt class="descclassname">Transport.</tt><tt class="descname">is_alive</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.is_alive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.is_alive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.nb_keep_draining">
<tt class="descclassname">Transport.</tt><tt class="descname">nb_keep_draining</tt><em class="property"> = True</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.nb_keep_draining" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.on_poll_init">
<tt class="descclassname">Transport.</tt><tt class="descname">on_poll_init</tt><big>(</big><em>poller</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.on_poll_init"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.on_poll_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.on_poll_start">
<tt class="descclassname">Transport.</tt><tt class="descname">on_poll_start</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.on_poll_start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.on_poll_start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Transport.supports_heartbeats">
<tt class="descclassname">Transport.</tt><tt class="descname">supports_heartbeats</tt><em class="property"> = True</em><a class="headerlink" href="#kombu.transport.pyamqp.Transport.supports_heartbeats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Transport.verify_connection">
<tt class="descclassname">Transport.</tt><tt class="descname">verify_connection</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Transport.verify_connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Transport.verify_connection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="connection">
<h2><a class="toc-backref" href="#id2">Connection</a><a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kombu.transport.pyamqp.Connection">
<em class="property">class </em><tt class="descclassname">kombu.transport.pyamqp.</tt><tt class="descname">Connection</tt><big>(</big><em>host='localhost'</em>, <em>userid='guest'</em>, <em>password='guest'</em>, <em>login_method='AMQPLAIN'</em>, <em>login_response=None</em>, <em>virtual_host='/'</em>, <em>locale='en_US'</em>, <em>client_properties=None</em>, <em>ssl=False</em>, <em>connect_timeout=None</em>, <em>channel_max=None</em>, <em>frame_max=None</em>, <em>heartbeat=0</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Connection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="kombu.transport.pyamqp.Connection.Channel">
<em class="property">class </em><tt class="descname">Channel</tt><big>(</big><em>connection</em>, <em>channel_id=None</em>, <em>auto_decode=True</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Consumer">
<tt class="descname">Consumer</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Consumer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message">
<em class="property">class </em><tt class="descname">Message</tt><big>(</big><em>channel</em>, <em>msg</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message" title="Permalink to this definition">¶</a></dt>
<dd><dl class="exception">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError">
<em class="property">exception </em><tt class="descname">MessageStateError</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError" title="Permalink to this definition">¶</a></dt>
<dd><p>The message has already been acknowledged.</p>
<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError.args">
<tt class="descname">args</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError.message">
<tt class="descname">message</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.MessageStateError.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.ack">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">ack</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledge this message as being processed.,
This will remove the message from the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Raises MessageStateError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">If the message has already been
acknowledged/requeued/rejected.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.ack_log_error">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">ack_log_error</tt><big>(</big><em>logger</em>, <em>errors</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.ack_log_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.acknowledged">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">acknowledged</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.acknowledged" title="Permalink to this definition">¶</a></dt>
<dd><p>Set to true if the message has been acknowledged.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.body">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">body</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.body" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.channel">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">channel</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.channel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.content_encoding">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">content_encoding</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.content_encoding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.content_type">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">content_type</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.content_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.decode">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize the message body, returning the original
python structure sent by the publisher.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.delivery_info">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">delivery_info</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.delivery_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.delivery_tag">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">delivery_tag</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.delivery_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.headers">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">headers</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.headers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.payload">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">payload</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>The decoded message body.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.properties">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">properties</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.properties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.reject">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">reject</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.reject" title="Permalink to this definition">¶</a></dt>
<dd><p>Reject this message.</p>
<p>The message will be discarded by the server.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Raises MessageStateError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">If the message has already been
acknowledged/requeued/rejected.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.reject_log_error">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">reject_log_error</tt><big>(</big><em>logger</em>, <em>errors</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.reject_log_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Message.requeue">
<tt class="descclassname">Connection.Channel.Message.</tt><tt class="descname">requeue</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Message.requeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Reject this message and put it back on the queue.</p>
<p>You must not use this method as a means of selecting messages
to process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Raises MessageStateError:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">If the message has already been
acknowledged/requeued/rejected.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.Producer">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">Producer</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.Producer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.after_reply_message_received">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">after_reply_message_received</tt><big>(</big><em>queue</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.after_reply_message_received" title="Permalink to this definition">¶</a></dt>
<dd><p>reply queue semantics: can be used to delete the queue
after transient reply message received.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_ack">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_ack</tt><big>(</big><em>delivery_tag</em>, <em>multiple=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledge one or more messages</p>
<p>This method acknowledges one or more messages delivered via
the Deliver or Get-Ok methods.  The client can ask to confirm
a single message or a set of messages up to and including a
specific message.</p>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">delivery_tag: longlong</p>
<blockquote>
<div><p>server-assigned delivery tag</p>
<p>The server-assigned and channel-specific delivery tag</p>
<p>RULE:</p>
<blockquote>
<div>The delivery tag is valid only within the channel
from which the message was received.  I.e. a client
MUST NOT receive a message on one channel and then
acknowledge it on another.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST NOT use a zero value for delivery
tags.  Zero is reserved for client use, meaning &#8220;all
messages so far received&#8221;.</div></blockquote>
</div></blockquote>
<p>multiple: boolean</p>
<blockquote class="last">
<div><p>acknowledge multiple messages</p>
<p>If set to True, the delivery tag is treated as &#8220;up to
and including&#8221;, so that the client can acknowledge
multiple messages with a single method.  If set to
False, the delivery tag refers to a single message.
If the multiple field is True, and the delivery tag
is zero, tells the server to acknowledge all
outstanding mesages.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST validate that a non-zero delivery-
tag refers to an delivered message, and raise a
channel exception if this is not the case.</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_cancel">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_cancel</tt><big>(</big><em>consumer_tag</em>, <em>nowait=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>End a queue consumer</p>
<p>This method cancels a consumer. This does not affect already
delivered messages, but it does mean the server will not send
any more messages for that consumer.  The client may receive
an abitrary number of messages in between sending the cancel
method and receiving the cancel-ok reply.</p>
<p>RULE:</p>
<blockquote>
<div>If the queue no longer exists when the client sends a
cancel command, or the consumer has been cancelled for
other reasons, this command has no effect.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">consumer_tag: shortstr</p>
<blockquote>
<div><p>consumer tag</p>
<p>Identifier for the consumer, valid within the current
connection.</p>
<p>RULE:</p>
<blockquote>
<div>The consumer tag is valid only within the channel
from which the consumer was created. I.e. a client
MUST NOT create a consumer in one channel and then
use it in another.</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote class="last">
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_consume">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_consume</tt><big>(</big><em>queue=''</em>, <em>consumer_tag=''</em>, <em>no_local=False</em>, <em>no_ack=False</em>, <em>exclusive=False</em>, <em>nowait=False</em>, <em>callback=None</em>, <em>arguments=None</em>, <em>on_cancel=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a queue consumer</p>
<p>This method asks the server to start a &#8220;consumer&#8221;, which is a
transient request for messages from a specific queue.
Consumers last as long as the channel they were created on, or
until the client cancels them.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD support at least 16 consumers per queue,
unless the queue was declared as private, and ideally,
impose no limit except as defined by available resources.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to consume from.  If
the queue name is null, refers to the current queue
for the channel, which is the last declared queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the client did not previously declare a queue,
and the queue name in this method is empty, the
server MUST raise a connection exception with
reply code 530 (not allowed).</div></blockquote>
</div></blockquote>
<p>consumer_tag: shortstr</p>
<blockquote>
<div><p>Specifies the identifier for the consumer. The
consumer tag is local to a connection, so two clients
can use the same consumer tags. If this field is empty
the server will generate a unique tag.</p>
<p>RULE:</p>
<blockquote>
<div>The tag MUST NOT refer to an existing consumer. If
the client attempts to create two consumers with
the same non-empty tag the server MUST raise a
connection exception with reply code 530 (not
allowed).</div></blockquote>
</div></blockquote>
<p>no_local: boolean</p>
<blockquote>
<div><p>do not deliver own messages</p>
<p>If the no-local field is set the server will not send
messages to the client that published them.</p>
</div></blockquote>
<p>no_ack: boolean</p>
<blockquote>
<div><p>no acknowledgement needed</p>
<p>If this field is set the server does not expect
acknowledgments for messages.  That is, when a message
is delivered to the client the server automatically and
silently acknowledges it on behalf of the client.  This
functionality increases performance but at the cost of
reliability.  Messages can get lost if a client dies
before it can deliver them to the application.</p>
</div></blockquote>
<p>exclusive: boolean</p>
<blockquote>
<div><p>request exclusive access</p>
<p>Request exclusive consumer access, meaning only this
consumer can access the queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the server cannot grant exclusive access to the
queue when asked, - because there are other
consumers active - it MUST raise a channel
exception with return code 403 (access refused).</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote>
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
<p>callback: Python callable</p>
<blockquote class="last">
<div><p>function/method called with each delivered message</p>
<p>For each message delivered by the broker, the
callable will be called with a Message object
as the single argument.  If no callable is specified,
messages are quietly discarded, no_ack should probably
be set to True in that case.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_get">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_get</tt><big>(</big><em>queue=''</em>, <em>no_ack=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct access to a queue</p>
<p>This method provides a direct access to the messages in a
queue using a synchronous dialogue that is designed for
specific types of application where synchronous functionality
is more important than performance.</p>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to consume from.  If
the queue name is null, refers to the current queue
for the channel, which is the last declared queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the client did not previously declare a queue,
and the queue name in this method is empty, the
server MUST raise a connection exception with
reply code 530 (not allowed).</div></blockquote>
</div></blockquote>
<p>no_ack: boolean</p>
<blockquote class="last">
<div><p>no acknowledgement needed</p>
<p>If this field is set the server does not expect
acknowledgments for messages.  That is, when a message
is delivered to the client the server automatically and
silently acknowledges it on behalf of the client.  This
functionality increases performance but at the cost of
reliability.  Messages can get lost if a client dies
before it can deliver them to the application.</p>
</div></blockquote>
</dd>
</dl>
<p>Non-blocking, returns a message object, or None.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_publish">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_publish</tt><big>(</big><em>msg</em>, <em>exchange=''</em>, <em>routing_key=''</em>, <em>mandatory=False</em>, <em>immediate=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_publish" title="Permalink to this definition">¶</a></dt>
<dd><p>Publish a message</p>
<p>This method publishes a message to a specific exchange. The
message will be routed to queues as defined by the exchange
configuration and distributed to any active consumers when the
transaction, if any, is committed.</p>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">exchange: shortstr</p>
<blockquote>
<div><p>Specifies the name of the exchange to publish to.  The
exchange name can be empty, meaning the default
exchange.  If the exchange name is specified, and that
exchange does not exist, the server will raise a
channel exception.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST accept a blank exchange name to
mean the default exchange.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The exchange MAY refuse basic content in which
case it MUST raise a channel exception with reply
code 540 (not implemented).</div></blockquote>
</div></blockquote>
<p>routing_key: shortstr</p>
<blockquote>
<div><p>Message routing key</p>
<p>Specifies the routing key for the message.  The
routing key is used for routing messages depending on
the exchange configuration.</p>
</div></blockquote>
<p>mandatory: boolean</p>
<blockquote>
<div><p>indicate mandatory routing</p>
<p>This flag tells the server how to react if the message
cannot be routed to a queue.  If this flag is True, the
server will return an unroutable message with a Return
method.  If this flag is False, the server silently
drops the message.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD implement the mandatory flag.</div></blockquote>
</div></blockquote>
<p>immediate: boolean</p>
<blockquote class="last">
<div><p>request immediate delivery</p>
<p>This flag tells the server how to react if the message
cannot be routed to a queue consumer immediately.  If
this flag is set, the server will return an
undeliverable message with a Return method. If this
flag is zero, the server will queue the message, but
with no guarantee that it will ever be consumed.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD implement the immediate flag.</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_qos">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_qos</tt><big>(</big><em>prefetch_size</em>, <em>prefetch_count</em>, <em>a_global</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_qos" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify quality of service</p>
<p>This method requests a specific quality of service.  The QoS
can be specified for the current channel or for all channels
on the connection.  The particular properties and semantics of
a qos method always depend on the content class semantics.
Though the qos method could in principle apply to both peers,
it is currently meaningful only for the server.</p>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">prefetch_size: long</p>
<blockquote>
<div><p>prefetch window in octets</p>
<p>The client can request that messages be sent in
advance so that when the client finishes processing a
message, the following message is already held
locally, rather than needing to be sent down the
channel.  Prefetching gives a performance improvement.
This field specifies the prefetch window size in
octets.  The server will send a message in advance if
it is equal to or smaller in size than the available
prefetch size (and also falls into other prefetch
limits). May be set to zero, meaning &#8220;no specific
limit&#8221;, although other prefetch limits may still
apply. The prefetch-size is ignored if the no-ack
option is set.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST ignore this setting when the
client is not processing any messages - i.e. the
prefetch size does not limit the transfer of
single messages to a client, only the sending in
advance of more messages while the client still
has one or more unacknowledged messages.</div></blockquote>
</div></blockquote>
<p>prefetch_count: short</p>
<blockquote>
<div><p>prefetch window in messages</p>
<p>Specifies a prefetch window in terms of whole
messages.  This field may be used in combination with
the prefetch-size field; a message will only be sent
in advance if both prefetch windows (and those at the
channel and connection level) allow it. The prefetch-
count is ignored if the no-ack option is set.</p>
<p>RULE:</p>
<blockquote>
<div>The server MAY send less data in advance than
allowed by the client&#8217;s specified prefetch windows
but it MUST NOT send more.</div></blockquote>
</div></blockquote>
<p>a_global: boolean</p>
<blockquote class="last">
<div><p>apply to entire connection</p>
<p>By default the QoS settings apply to the current
channel only.  If this field is set, they are applied
to the entire connection.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_recover">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_recover</tt><big>(</big><em>requeue=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_recover" title="Permalink to this definition">¶</a></dt>
<dd><p>Redeliver unacknowledged messages</p>
<p>This method asks the broker to redeliver all unacknowledged
messages on a specified channel. Zero or more messages may be
redelivered.  This method is only allowed on non-transacted
channels.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST set the redelivered flag on all messages
that are resent.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST raise a channel exception if this is
called on a transacted channel.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">requeue: boolean</p>
<blockquote class="last">
<div><p>requeue the message</p>
<p>If this field is False, the message will be redelivered
to the original recipient.  If this field is True, the
server will attempt to requeue the message,
potentially then delivering it to an alternative
subscriber.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_recover_async">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_recover_async</tt><big>(</big><em>requeue=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_recover_async" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.basic_reject">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">basic_reject</tt><big>(</big><em>delivery_tag</em>, <em>requeue</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.basic_reject" title="Permalink to this definition">¶</a></dt>
<dd><p>Reject an incoming message</p>
<p>This method allows a client to reject a message.  It can be
used to interrupt and cancel large incoming messages, or
return untreatable messages to their original queue.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD be capable of accepting and process the
Reject method while sending message content with a Deliver
or Get-Ok method.  I.e. the server should read and process
incoming methods while sending output frames.  To cancel a
partially-send content, the server sends a content body
frame of size 1 (i.e. with no data except the frame-end
octet).</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD interpret this method as meaning that
the client is unable to process the message at this time.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>A client MUST NOT use this method as a means of selecting
messages to process.  A rejected message MAY be discarded
or dead-lettered, not necessarily passed to another
client.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">delivery_tag: longlong</p>
<blockquote>
<div><p>server-assigned delivery tag</p>
<p>The server-assigned and channel-specific delivery tag</p>
<p>RULE:</p>
<blockquote>
<div>The delivery tag is valid only within the channel
from which the message was received.  I.e. a client
MUST NOT receive a message on one channel and then
acknowledge it on another.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST NOT use a zero value for delivery
tags.  Zero is reserved for client use, meaning &#8220;all
messages so far received&#8221;.</div></blockquote>
</div></blockquote>
<p>requeue: boolean</p>
<blockquote class="last">
<div><p>requeue the message</p>
<p>If this field is False, the message will be discarded.
If this field is True, the server will attempt to
requeue the message.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST NOT deliver the message to the
same client within the context of the current
channel.  The recommended strategy is to attempt
to deliver the message to an alternative consumer,
and if that is not possible, to move the message
to a dead-letter queue.  The server MAY use more
sophisticated tracking to hold the message on the
queue and redeliver it to the same client at a
later stage.</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.close">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">close</tt><big>(</big><em>reply_code=0</em>, <em>reply_text=''</em>, <em>method_sig=(0</em>, <em>0)</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a channel close</p>
<p>This method indicates that the sender wants to close the
channel. This may be due to internal conditions (e.g. a forced
shut-down) or due to an error handling a specific method, i.e.
an exception.  When a close is due to an exception, the sender
provides the class and method id of the method which caused
the exception.</p>
<p>RULE:</p>
<blockquote>
<div>After sending this method any received method except
Channel.Close-OK MUST be discarded.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The peer sending this method MAY use a counter or timeout
to detect failure of the other peer to respond correctly
with Channel.Close-OK..</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">reply_code: short</p>
<blockquote>
<div>The reply code. The AMQ reply codes are defined in AMQ
RFC 011.</div></blockquote>
<p>reply_text: shortstr</p>
<blockquote>
<div>The localised reply text.  This text can be logged as an
aid to resolving issues.</div></blockquote>
<p>class_id: short</p>
<blockquote>
<div><p>failing method class</p>
<p>When the close is provoked by a method exception, this
is the class of the method.</p>
</div></blockquote>
<p>method_id: short</p>
<blockquote class="last">
<div><p>failing method ID</p>
<p>When the close is provoked by a method exception, this
is the ID of the method.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.confirm_select">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">confirm_select</tt><big>(</big><em>nowait=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.confirm_select" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables publisher confirms for this channel (an RabbitMQ
extension).</p>
<p>Can now be used if the channel is in transactional mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nowait</strong> &#8211; If set, the server will not respond to the method.
The client should not wait for a reply method. If the
server could not complete the method it will raise a channel
or connection exception.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.dispatch_method">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">dispatch_method</tt><big>(</big><em>method_sig</em>, <em>args</em>, <em>content</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.dispatch_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.exchange_declare">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">exchange_declare</tt><big>(</big><em>exchange</em>, <em>type</em>, <em>passive=False</em>, <em>durable=False</em>, <em>auto_delete=True</em>, <em>nowait=False</em>, <em>arguments=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.exchange_declare" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare exchange, create if needed</p>
<p>This method creates an exchange if it does not already exist,
and if the exchange exists, verifies that it is of the correct
and expected class.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD support a minimum of 16 exchanges per
virtual host and ideally, impose no limit except as
defined by available resources.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">exchange: shortstr</p>
<blockquote>
<div><p>RULE:</p>
<blockquote>
<div>Exchange names starting with &#8220;amq.&#8221; are reserved
for predeclared and standardised exchanges.  If
the client attempts to create an exchange starting
with &#8220;amq.&#8221;, the server MUST raise a channel
exception with reply code 403 (access refused).</div></blockquote>
</div></blockquote>
<p>type: shortstr</p>
<blockquote>
<div><p>exchange type</p>
<p>Each exchange belongs to one of a set of exchange
types implemented by the server.  The exchange types
define the functionality of the exchange - i.e. how
messages are routed through it.  It is not valid or
meaningful to attempt to change the type of an
existing exchange.</p>
<p>RULE:</p>
<blockquote>
<div>If the exchange already exists with a different
type, the server MUST raise a connection exception
with a reply code 507 (not allowed).</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>If the server does not support the requested
exchange type it MUST raise a connection exception
with a reply code 503 (command invalid).</div></blockquote>
</div></blockquote>
<p>passive: boolean</p>
<blockquote>
<div><p>do not create exchange</p>
<p>If set, the server will not create the exchange.  The
client can use this to check whether an exchange
exists without modifying the server state.</p>
<p>RULE:</p>
<blockquote>
<div>If set, and the exchange does not already exist,
the server MUST raise a channel exception with
reply code 404 (not found).</div></blockquote>
</div></blockquote>
<p>durable: boolean</p>
<blockquote>
<div><p>request a durable exchange</p>
<p>If set when creating a new exchange, the exchange will
be marked as durable.  Durable exchanges remain active
when a server restarts. Non-durable exchanges
(transient exchanges) are purged if/when a server
restarts.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST support both durable and transient
exchanges.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST ignore the durable field if the
exchange already exists.</div></blockquote>
</div></blockquote>
<p>auto_delete: boolean</p>
<blockquote>
<div><p>auto-delete when unused</p>
<p>If set, the exchange is deleted when all queues have
finished using it.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD allow for a reasonable delay
between the point when it determines that an
exchange is not being used (or no longer used),
and the point when it deletes the exchange.  At
the least it must allow a client to create an
exchange and then bind a queue to it, with a small
but non-zero delay between these two actions.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST ignore the auto-delete field if
the exchange already exists.</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote>
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
<p>arguments: table</p>
<blockquote class="last">
<div><p>arguments for declaration</p>
<p>A set of arguments for the declaration. The syntax and
semantics of these arguments depends on the server
implementation.  This field is ignored if passive is
True.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.exchange_delete">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">exchange_delete</tt><big>(</big><em>exchange</em>, <em>if_unused=False</em>, <em>nowait=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.exchange_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an exchange</p>
<p>This method deletes an exchange.  When an exchange is deleted
all queue bindings on the exchange are cancelled.</p>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">exchange: shortstr</p>
<blockquote>
<div><p>RULE:</p>
<blockquote>
<div>The exchange MUST exist. Attempting to delete a
non-existing exchange causes a channel exception.</div></blockquote>
</div></blockquote>
<p>if_unused: boolean</p>
<blockquote>
<div><p>delete only if unused</p>
<p>If set, the server will only delete the exchange if it
has no queue bindings. If the exchange has queue
bindings the server does not delete it but raises a
channel exception instead.</p>
<p>RULE:</p>
<blockquote>
<div>If set, the server SHOULD delete the exchange but
only if it has no queue bindings.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>If set, the server SHOULD raise a channel
exception if the exchange is in use.</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote class="last">
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.flow">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">flow</tt><big>(</big><em>active</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable/disable flow from peer</p>
<p>This method asks the peer to pause or restart the flow of
content data. This is a simple flow-control mechanism that a
peer can use to avoid oveflowing its queues or otherwise
finding itself receiving more messages than it can process.
Note that this method is not intended for window control.  The
peer that receives a request to stop sending content should
finish sending the current content, if any, and then wait
until it receives a Flow restart method.</p>
<p>RULE:</p>
<blockquote>
<div>When a new channel is opened, it is active.  Some
applications assume that channels are inactive until
started.  To emulate this behaviour a client MAY open the
channel, then pause it.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>When sending content data in multiple frames, a peer
SHOULD monitor the channel for incoming methods and
respond to a Channel.Flow as rapidly as possible.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>A peer MAY use the Channel.Flow method to throttle
incoming content data for internal reasons, for example,
when exchangeing data over a slower connection.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The peer that requests a Channel.Flow method MAY
disconnect and/or ban a peer that does not respect the
request.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">active: boolean</p>
<blockquote class="last">
<div><p>start/stop content frames</p>
<p>If True, the peer starts sending content frames.  If
False, the peer stops sending content frames.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.get_bindings">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">get_bindings</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.get_bindings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.message_to_python">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">message_to_python</tt><big>(</big><em>raw_message</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.message_to_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert encoded message body back to a Python value.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.Channel.no_ack_consumers">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">no_ack_consumers</tt><em class="property"> = None</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.no_ack_consumers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.prepare_message">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">prepare_message</tt><big>(</big><em>message_data</em>, <em>priority=None</em>, <em>content_type=None</em>, <em>content_encoding=None</em>, <em>headers=None</em>, <em>properties=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.prepare_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulate data into a AMQP message.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.queue_bind">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">queue_bind</tt><big>(</big><em>queue</em>, <em>exchange=''</em>, <em>routing_key=''</em>, <em>nowait=False</em>, <em>arguments=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.queue_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind queue to an exchange</p>
<p>This method binds a queue to an exchange.  Until a queue is
bound it will not receive any messages.  In a classic
messaging model, store-and-forward queues are bound to a dest
exchange and subscription queues are bound to a dest_wild
exchange.</p>
<p>RULE:</p>
<blockquote>
<div>A server MUST allow ignore duplicate bindings - that is,
two or more bind methods for a specific queue, with
identical arguments - without treating these as an error.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>If a bind fails, the server MUST raise a connection
exception.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST NOT allow a durable queue to bind to a
transient exchange. If the client attempts this the server
MUST raise a channel exception.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>Bindings for durable queues are automatically durable and
the server SHOULD restore such bindings after a server
restart.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD support at least 4 bindings per queue,
and ideally, impose no limit except as defined by
available resources.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to bind.  If the queue
name is empty, refers to the current queue for the
channel, which is the last declared queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the client did not previously declare a queue,
and the queue name in this method is empty, the
server MUST raise a connection exception with
reply code 530 (not allowed).</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>If the queue does not exist the server MUST raise
a channel exception with reply code 404 (not
found).</div></blockquote>
</div></blockquote>
<p>exchange: shortstr</p>
<blockquote>
<div><p>The name of the exchange to bind to.</p>
<p>RULE:</p>
<blockquote>
<div>If the exchange does not exist the server MUST
raise a channel exception with reply code 404 (not
found).</div></blockquote>
</div></blockquote>
<p>routing_key: shortstr</p>
<blockquote>
<div><p>message routing key</p>
<p>Specifies the routing key for the binding.  The
routing key is used for routing messages depending on
the exchange configuration. Not all exchanges use a
routing key - refer to the specific exchange
documentation.  If the routing key is empty and the
queue name is empty, the routing key will be the
current queue for the channel, which is the last
declared queue.</p>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote>
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
<p>arguments: table</p>
<blockquote class="last">
<div><p>arguments for binding</p>
<p>A set of arguments for the binding.  The syntax and
semantics of these arguments depends on the exchange
class.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.queue_declare">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">queue_declare</tt><big>(</big><em>queue=''</em>, <em>passive=False</em>, <em>durable=False</em>, <em>exclusive=False</em>, <em>auto_delete=True</em>, <em>nowait=False</em>, <em>arguments=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.queue_declare" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare queue, create if needed</p>
<p>This method creates or checks a queue.  When creating a new
queue the client can specify various properties that control
the durability of the queue and its contents, and the level of
sharing for the queue.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST create a default binding for a newly-
created queue to the default exchange, which is an
exchange of type &#8216;direct&#8217;.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD support a minimum of 256 queues per
virtual host and ideally, impose no limit except as
defined by available resources.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>RULE:</p>
<blockquote>
<div>The queue name MAY be empty, in which case the
server MUST create a new queue with a unique
generated name and return this to the client in
the Declare-Ok method.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>Queue names starting with &#8220;amq.&#8221; are reserved for
predeclared and standardised server queues.  If
the queue name starts with &#8220;amq.&#8221; and the passive
option is False, the server MUST raise a connection
exception with reply code 403 (access refused).</div></blockquote>
</div></blockquote>
<p>passive: boolean</p>
<blockquote>
<div><p>do not create queue</p>
<p>If set, the server will not create the queue.  The
client can use this to check whether a queue exists
without modifying the server state.</p>
<p>RULE:</p>
<blockquote>
<div>If set, and the queue does not already exist, the
server MUST respond with a reply code 404 (not
found) and raise a channel exception.</div></blockquote>
</div></blockquote>
<p>durable: boolean</p>
<blockquote>
<div><p>request a durable queue</p>
<p>If set when creating a new queue, the queue will be
marked as durable.  Durable queues remain active when
a server restarts. Non-durable queues (transient
queues) are purged if/when a server restarts.  Note
that durable queues do not necessarily hold persistent
messages, although it does not make sense to send
persistent messages to a transient queue.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST recreate the durable queue after a
restart.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST support both durable and transient
queues.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST ignore the durable field if the
queue already exists.</div></blockquote>
</div></blockquote>
<p>exclusive: boolean</p>
<blockquote>
<div><p>request an exclusive queue</p>
<p>Exclusive queues may only be consumed from by the
current connection. Setting the &#8216;exclusive&#8217; flag
always implies &#8216;auto-delete&#8217;.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST support both exclusive (private)
and non-exclusive (shared) queues.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST raise a channel exception if
&#8216;exclusive&#8217; is specified and the queue already
exists and is owned by a different connection.</div></blockquote>
</div></blockquote>
<p>auto_delete: boolean</p>
<blockquote>
<div><p>auto-delete queue when unused</p>
<p>If set, the queue is deleted when all consumers have
finished using it. Last consumer can be cancelled
either explicitly or because its channel is closed. If
there was no consumer ever on the queue, it won&#8217;t be
deleted.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD allow for a reasonable delay
between the point when it determines that a queue
is not being used (or no longer used), and the
point when it deletes the queue.  At the least it
must allow a client to create a queue and then
create a consumer to read from it, with a small
but non-zero delay between these two actions.  The
server should equally allow for clients that may
be disconnected prematurely, and wish to re-
consume from the same queue without losing
messages.  We would recommend a configurable
timeout, with a suitable default value being one
minute.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST ignore the auto-delete field if
the queue already exists.</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote>
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
<p>arguments: table</p>
<blockquote class="last">
<div><p>arguments for declaration</p>
<p>A set of arguments for the declaration. The syntax and
semantics of these arguments depends on the server
implementation.  This field is ignored if passive is
True.</p>
</div></blockquote>
</dd>
<dt>Returns a tuple containing 3 items:</dt>
<dd>the name of the queue (essential for automatically-named queues)
message count
consumer count</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.queue_delete">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">queue_delete</tt><big>(</big><em>queue=''</em>, <em>if_unused=False</em>, <em>if_empty=False</em>, <em>nowait=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.queue_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a queue</p>
<p>This method deletes a queue.  When a queue is deleted any
pending messages are sent to a dead-letter queue if this is
defined in the server configuration, and all consumers on the
queue are cancelled.</p>
<p>RULE:</p>
<blockquote>
<div>The server SHOULD use a dead-letter queue to hold messages
that were pending on a deleted queue, and MAY provide
facilities for a system administrator to move these
messages back to an active queue.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to delete. If the
queue name is empty, refers to the current queue for
the channel, which is the last declared queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the client did not previously declare a queue,
and the queue name in this method is empty, the
server MUST raise a connection exception with
reply code 530 (not allowed).</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The queue must exist. Attempting to delete a non-
existing queue causes a channel exception.</div></blockquote>
</div></blockquote>
<p>if_unused: boolean</p>
<blockquote>
<div><p>delete only if unused</p>
<p>If set, the server will only delete the queue if it
has no consumers. If the queue has consumers the
server does does not delete it but raises a channel
exception instead.</p>
<p>RULE:</p>
<blockquote>
<div>The server MUST respect the if-unused flag when
deleting a queue.</div></blockquote>
</div></blockquote>
<p>if_empty: boolean</p>
<blockquote>
<div><p>delete only if empty</p>
<p>If set, the server will only delete the queue if it
has no messages. If the queue is not empty the server
raises a channel exception.</p>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote class="last">
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.queue_purge">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">queue_purge</tt><big>(</big><em>queue=''</em>, <em>nowait=False</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Purge a queue</p>
<p>This method removes all messages from a queue.  It does not
cancel consumers.  Purged messages are deleted without any
formal &#8220;undo&#8221; mechanism.</p>
<p>RULE:</p>
<blockquote>
<div>A call to purge MUST result in an empty queue.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>On transacted channels the server MUST not purge messages
that have already been sent to a client but not yet
acknowledged.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MAY implement a purge queue or log that allows
system administrators to recover accidentally-purged
messages.  The server SHOULD NOT keep purged messages in
the same storage spaces as the live messages since the
volumes of purged messages may get very large.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to purge.  If the
queue name is empty, refers to the current queue for
the channel, which is the last declared queue.</p>
<p>RULE:</p>
<blockquote>
<div>If the client did not previously declare a queue,
and the queue name in this method is empty, the
server MUST raise a connection exception with
reply code 530 (not allowed).</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The queue must exist. Attempting to purge a non-
existing queue causes a channel exception.</div></blockquote>
</div></blockquote>
<p>nowait: boolean</p>
<blockquote class="last">
<div><p>do not send a reply method</p>
<p>If set, the server will not respond to the method. The
client should not wait for a reply method.  If the
server could not complete the method it will raise a
channel or connection exception.</p>
</div></blockquote>
</dd>
</dl>
<p>if nowait is False, returns a message_count</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.queue_unbind">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">queue_unbind</tt><big>(</big><em>queue</em>, <em>exchange</em>, <em>routing_key=''</em>, <em>nowait=False</em>, <em>arguments=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.queue_unbind" title="Permalink to this definition">¶</a></dt>
<dd><p>Unbind a queue from an exchange</p>
<p>This method unbinds a queue from an exchange.</p>
<p>RULE:</p>
<blockquote>
<div>If a unbind fails, the server MUST raise a connection exception.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">queue: shortstr</p>
<blockquote>
<div><p>Specifies the name of the queue to unbind.</p>
<p>RULE:</p>
<blockquote>
<div>The client MUST either specify a queue name or have
previously declared a queue on the same channel</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The client MUST NOT attempt to unbind a queue that
does not exist.</div></blockquote>
</div></blockquote>
<p>exchange: shortstr</p>
<blockquote>
<div><p>The name of the exchange to unbind from.</p>
<p>RULE:</p>
<blockquote>
<div>The client MUST NOT attempt to unbind a queue from an
exchange that does not exist.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The server MUST accept a blank exchange name to mean
the default exchange.</div></blockquote>
</div></blockquote>
<p>routing_key: shortstr</p>
<blockquote>
<div><p>routing key of binding</p>
<p>Specifies the routing key of the binding to unbind.</p>
</div></blockquote>
<p>arguments: table</p>
<blockquote class="last">
<div><p>arguments of binding</p>
<p>Specifies the arguments of the binding to unbind.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.tx_commit">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">tx_commit</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.tx_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the current transaction</p>
<p>This method commits all messages published and acknowledged in
the current transaction.  A new transaction starts immediately
after a commit.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.tx_rollback">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">tx_rollback</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.tx_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Abandon the current transaction</p>
<p>This method abandons all messages published and acknowledged
in the current transaction.  A new transaction starts
immediately after a rollback.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.tx_select">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">tx_select</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.tx_select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select standard transaction mode</p>
<p>This method sets the channel to use standard transactions.
The client must use this method at least once on a channel
before using the Commit or Rollback methods.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.Channel.wait">
<tt class="descclassname">Connection.Channel.</tt><tt class="descname">wait</tt><big>(</big><em>allowed_methods=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.Channel.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for a method that matches our allowed_methods parameter (the
default value of None means match any method), and dispatch to it.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.channel">
<tt class="descclassname">Connection.</tt><tt class="descname">channel</tt><big>(</big><em>channel_id=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch a Channel object identified by the numeric channel_id, or
create that object if it doesn&#8217;t already exist.</p>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.channel_errors">
<tt class="descclassname">Connection.</tt><tt class="descname">channel_errors</tt><em class="property"> = (&lt;class 'amqp.exceptions.ChannelError'&gt;,)</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.channel_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.close">
<tt class="descclassname">Connection.</tt><tt class="descname">close</tt><big>(</big><em>reply_code=0</em>, <em>reply_text=''</em>, <em>method_sig=(0</em>, <em>0)</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a connection close</p>
<p>This method indicates that the sender wants to close the
connection. This may be due to internal conditions (e.g. a
forced shut-down) or due to an error handling a specific
method, i.e. an exception.  When a close is due to an
exception, the sender provides the class and method id of the
method which caused the exception.</p>
<p>RULE:</p>
<blockquote>
<div>After sending this method any received method except the
Close-OK method MUST be discarded.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>The peer sending this method MAY use a counter or timeout
to detect failure of the other peer to respond correctly
with the Close-OK method.</div></blockquote>
<p>RULE:</p>
<blockquote>
<div>When a server receives the Close method from a client it
MUST delete all server-side resources associated with the
client&#8217;s context.  A client CANNOT reconnect to a context
after sending or receiving a Close method.</div></blockquote>
<dl class="docutils">
<dt>PARAMETERS:</dt>
<dd><p class="first">reply_code: short</p>
<blockquote>
<div>The reply code. The AMQ reply codes are defined in AMQ
RFC 011.</div></blockquote>
<p>reply_text: shortstr</p>
<blockquote>
<div>The localised reply text.  This text can be logged as an
aid to resolving issues.</div></blockquote>
<p>class_id: short</p>
<blockquote>
<div><p>failing method class</p>
<p>When the close is provoked by a method exception, this
is the class of the method.</p>
</div></blockquote>
<p>method_id: short</p>
<blockquote class="last">
<div><p>failing method ID</p>
<p>When the close is provoked by a method exception, this
is the ID of the method.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.connection_errors">
<tt class="descclassname">Connection.</tt><tt class="descname">connection_errors</tt><em class="property"> = (&lt;class 'amqp.exceptions.ConnectionError'&gt;, &lt;class 'socket.error'&gt;, &lt;type 'exceptions.IOError'&gt;, &lt;type 'exceptions.OSError'&gt;, &lt;type 'exceptions.AttributeError'&gt;)</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.connection_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.dispatch_method">
<tt class="descclassname">Connection.</tt><tt class="descname">dispatch_method</tt><big>(</big><em>method_sig</em>, <em>args</em>, <em>content</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.dispatch_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.drain_events">
<tt class="descclassname">Connection.</tt><tt class="descname">drain_events</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.drain_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for an event on a channel.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.heartbeat_tick">
<tt class="descclassname">Connection.</tt><tt class="descname">heartbeat_tick</tt><big>(</big><em>rate=2</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.heartbeat_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that hartbeats are sent and received.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rate</strong> &#8211; Rate is how often the tick is called
compared to the actual heartbeat value.  E.g. if
the heartbeat is set to 3 seconds, and the tick
is called every 3 / 2 seconds, then the rate is 2.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.is_alive">
<tt class="descclassname">Connection.</tt><tt class="descname">is_alive</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.is_alive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.missed_heartbeats">
<tt class="descclassname">Connection.</tt><tt class="descname">missed_heartbeats</tt><em class="property"> = 0</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.missed_heartbeats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.prev_recv">
<tt class="descclassname">Connection.</tt><tt class="descname">prev_recv</tt><em class="property"> = None</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.prev_recv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.prev_sent">
<tt class="descclassname">Connection.</tt><tt class="descname">prev_sent</tt><em class="property"> = None</em><a class="headerlink" href="#kombu.transport.pyamqp.Connection.prev_sent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.read_timeout">
<tt class="descclassname">Connection.</tt><tt class="descname">read_timeout</tt><big>(</big><em>timeout=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.read_timeout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.send_heartbeat">
<tt class="descclassname">Connection.</tt><tt class="descname">send_heartbeat</tt><big>(</big><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.send_heartbeat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.server_capabilities">
<tt class="descclassname">Connection.</tt><tt class="descname">server_capabilities</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.server_capabilities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="kombu.transport.pyamqp.Connection.sock">
<tt class="descclassname">Connection.</tt><tt class="descname">sock</tt><a class="headerlink" href="#kombu.transport.pyamqp.Connection.sock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Connection.wait">
<tt class="descclassname">Connection.</tt><tt class="descname">wait</tt><big>(</big><em>allowed_methods=None</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Connection.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for a method that matches our allowed_methods parameter (the
default value of None means match any method), and dispatch to it.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="channel">
<h2><a class="toc-backref" href="#id3">Channel</a><a class="headerlink" href="#channel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kombu.transport.pyamqp.Channel">
<em class="property">class </em><tt class="descclassname">kombu.transport.pyamqp.</tt><tt class="descname">Channel</tt><big>(</big><em>connection</em>, <em>channel_id=None</em>, <em>auto_decode=True</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Channel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Channel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="class">
<dt id="kombu.transport.pyamqp.Channel.Message">
<em class="property">class </em><tt class="descname">Message</tt><big>(</big><em>channel</em>, <em>msg</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#kombu.transport.pyamqp.Channel.Message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Channel.message_to_python">
<tt class="descclassname">Channel.</tt><tt class="descname">message_to_python</tt><big>(</big><em>raw_message</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Channel.message_to_python"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Channel.message_to_python" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert encoded message body back to a Python value.</p>
</dd></dl>

<dl class="method">
<dt id="kombu.transport.pyamqp.Channel.prepare_message">
<tt class="descclassname">Channel.</tt><tt class="descname">prepare_message</tt><big>(</big><em>message_data</em>, <em>priority=None</em>, <em>content_type=None</em>, <em>content_encoding=None</em>, <em>headers=None</em>, <em>properties=None</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Channel.prepare_message"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Channel.prepare_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulate data into a AMQP message.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="message">
<h2><a class="toc-backref" href="#id4">Message</a><a class="headerlink" href="#message" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="kombu.transport.pyamqp.Message">
<em class="property">class </em><tt class="descclassname">kombu.transport.pyamqp.</tt><tt class="descname">Message</tt><big>(</big><em>channel</em>, <em>msg</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/kombu/transport/pyamqp.html#Message"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#kombu.transport.pyamqp.Message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a href="/">Home</a>:
        «&#160;&#160;<a href="kombu.transport.librabbitmq.html">&lt;no title&gt;</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="kombu.transport.pika.html">kombu.transport.pika</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, HDKNR.COM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/3c28de26aac2.
    </div>
  </body>
</html>