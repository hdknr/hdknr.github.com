

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Routing Tasks &mdash; Celery 1 documentation</title>
    
    <link rel="stylesheet" href="../static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="Celery 1 documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="index.html" />
    <link rel="next" title="Monitoring and Management Guide" href="monitoring.html" />
    <link rel="prev" title="HTTP Callback Tasks (Webhooks)" href="remote-tasks.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Celery 1 documentation</span></a></h1>
        <h2 class="heading"><span>Routing Tasks</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a href="/">Home</a>:
        «&#160;&#160;<a href="remote-tasks.html">HTTP Callback Tasks (Webhooks)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="monitoring.html">Monitoring and Management Guide</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="routing-tasks">
<span id="guide-routing"></span><h1>Routing Tasks<a class="headerlink" href="#routing-tasks" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternate routing concepts like topic and fanout may not be
available for all transports, please consult the <a class="reference external" href="http://kombu.readthedocs.org/en/latest/introduction.html#transport-comparison">transport comparison table</a>.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#basics" id="id5">Basics</a><ul>
<li><a class="reference internal" href="#automatic-routing" id="id6">Automatic routing</a><ul>
<li><a class="reference internal" href="#changing-the-name-of-the-default-queue" id="id7">Changing the name of the default queue</a></li>
<li><a class="reference internal" href="#how-the-queues-are-defined" id="id8">How the queues are defined</a></li>
</ul>
</li>
<li><a class="reference internal" href="#manual-routing" id="id9">Manual routing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#amqp-primer" id="id10">AMQP Primer</a><ul>
<li><a class="reference internal" href="#messages" id="id11">Messages</a></li>
<li><a class="reference internal" href="#producers-consumers-and-brokers" id="id12">Producers, consumers and brokers</a></li>
<li><a class="reference internal" href="#exchanges-queues-and-routing-keys" id="id13">Exchanges, queues and routing keys.</a></li>
<li><a class="reference internal" href="#exchange-types" id="id14">Exchange types</a><ul>
<li><a class="reference internal" href="#direct-exchanges" id="id15">Direct exchanges</a></li>
<li><a class="reference internal" href="#topic-exchanges" id="id16">Topic exchanges</a></li>
</ul>
</li>
<li><a class="reference internal" href="#related-api-commands" id="id17">Related API commands</a></li>
<li><a class="reference internal" href="#hands-on-with-the-api" id="id18">Hands-on with the API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2" id="id19">Routing Tasks</a><ul>
<li><a class="reference internal" href="#defining-queues" id="id20">Defining queues</a></li>
<li><a class="reference internal" href="#specifying-task-destination" id="id21">Specifying task destination</a></li>
<li><a class="reference internal" href="#routers" id="id22">Routers</a></li>
<li><a class="reference internal" href="#broadcast" id="id23">Broadcast</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="basics">
<span id="routing-basics"></span><h2><a class="toc-backref" href="#id5">Basics</a><a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="automatic-routing">
<span id="routing-automatic"></span><h3><a class="toc-backref" href="#id6">Automatic routing</a><a class="headerlink" href="#automatic-routing" title="Permalink to this headline">¶</a></h3>
<p>The simplest way to do routing is to use the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_CREATE_MISSING_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_CREATE_MISSING_QUEUES</span></tt></a> setting (on by default).</p>
<p>With this setting on, a named queue that is not already defined in
<a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> will be created automatically.  This makes it easy to
perform simple routing tasks.</p>
<p>Say you have two servers, <cite>x</cite>, and <cite>y</cite> that handles regular tasks,
and one server <cite>z</cite>, that only handles feed related tasks.  You can use this
configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;feed.tasks.import_feed&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;queue&#39;</span><span class="p">:</span> <span class="s">&#39;feeds&#39;</span><span class="p">}}</span>
</pre></div>
</div>
<p>With this route enabled import feed tasks will be routed to the
<cite>&#8220;feeds&#8221;</cite> queue, while all other tasks will be routed to the default queue
(named <cite>&#8220;celery&#8221;</cite> for historical reasons).</p>
<p>Now you can start server <cite>z</cite> to only process the feeds queue like this:</p>
<div class="highlight-bash"><div class="highlight"><pre>user@z:/<span class="nv">$ </span>celery worker -Q feeds
</pre></div>
</div>
<p>You can specify as many queues as you want, so you can make this server
process the default queue as well:</p>
<div class="highlight-bash"><div class="highlight"><pre>user@z:/<span class="nv">$ </span>celery worker -Q feeds,celery
</pre></div>
</div>
<div class="section" id="changing-the-name-of-the-default-queue">
<span id="routing-changing-default-queue"></span><h4><a class="toc-backref" href="#id7">Changing the name of the default queue</a><a class="headerlink" href="#changing-the-name-of-the-default-queue" title="Permalink to this headline">¶</a></h4>
<p>You can change the name of the default queue by using the following
configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu</span> <span class="kn">import</span> <span class="n">Exchange</span><span class="p">,</span> <span class="n">Queue</span>

<span class="n">CELERY_DEFAULT_QUEUE</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">),</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-the-queues-are-defined">
<span id="routing-autoqueue-details"></span><h4><a class="toc-backref" href="#id8">How the queues are defined</a><a class="headerlink" href="#how-the-queues-are-defined" title="Permalink to this headline">¶</a></h4>
<p>The point with this feature is to hide the complex AMQP protocol for users
with only basic needs. However &#8211; you may still be interested in how these queues
are declared.</p>
<p>A queue named <cite>&#8220;video&#8221;</cite> will be created with the following settings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;exchange&#39;</span><span class="p">:</span> <span class="s">&#39;video&#39;</span><span class="p">,</span>
 <span class="s">&#39;exchange_type&#39;</span><span class="p">:</span> <span class="s">&#39;direct&#39;</span><span class="p">,</span>
 <span class="s">&#39;routing_key&#39;</span><span class="p">:</span> <span class="s">&#39;video&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>The non-AMQP backends like <cite>ghettoq</cite> does not support exchanges, so they
require the exchange to have the same name as the queue. Using this design
ensures it will work for them as well.</p>
</div>
</div>
<div class="section" id="manual-routing">
<span id="routing-manual"></span><h3><a class="toc-backref" href="#id9">Manual routing</a><a class="headerlink" href="#manual-routing" title="Permalink to this headline">¶</a></h3>
<p>Say you have two servers, <cite>x</cite>, and <cite>y</cite> that handles regular tasks,
and one server <cite>z</cite>, that only handles feed related tasks, you can use this
configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="n">CELERY_DEFAULT_QUEUE</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span>    <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;task.#&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;feed_tasks&#39;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;feed.#&#39;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">CELERY_DEFAULT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#39;tasks&#39;</span>
<span class="n">CELERY_DEFAULT_EXCHANGE_TYPE</span> <span class="o">=</span> <span class="s">&#39;topic&#39;</span>
<span class="n">CELERY_DEFAULT_ROUTING_KEY</span> <span class="o">=</span> <span class="s">&#39;task.default&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> is a list of <tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt>
instances.
If you don&#8217;t set the exchange or exchange type values for a key, these
will be taken from the <a class="reference internal" href="../configuration.html#std:setting-CELERY_DEFAULT_EXCHANGE"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_DEFAULT_EXCHANGE</span></tt></a> and
<a class="reference internal" href="../configuration.html#std:setting-CELERY_DEFAULT_EXCHANGE_TYPE"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_DEFAULT_EXCHANGE_TYPE</span></tt></a> settings.</p>
<p>To route a task to the <cite>feed_tasks</cite> queue, you can add an entry in the
<a class="reference internal" href="../configuration.html#std:setting-CELERY_ROUTES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_ROUTES</span></tt></a> setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;feeds.tasks.import_feed&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">&#39;queue&#39;</span><span class="p">:</span> <span class="s">&#39;feed_tasks&#39;</span><span class="p">,</span>
            <span class="s">&#39;routing_key&#39;</span><span class="p">:</span> <span class="s">&#39;feed.import&#39;</span><span class="p">,</span>
        <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also override this using the <cite>routing_key</cite> argument to
<tt class="xref py py-meth docutils literal"><span class="pre">Task.apply_async()</span></tt>, or <tt class="xref py py-func docutils literal"><span class="pre">send_task()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">feeds.tasks</span> <span class="kn">import</span> <span class="n">import_feed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">import_feed</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;http://cnn.com/rss&#39;</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="n">queue</span><span class="o">=</span><span class="s">&#39;feed_tasks&#39;</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;feed.import&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To make server <cite>z</cite> consume from the feed queue exclusively you can
start it with the <tt class="docutils literal"><span class="pre">-Q</span></tt> option:</p>
<div class="highlight-bash"><div class="highlight"><pre>user@z:/<span class="nv">$ </span>celery worker -Q feed_tasks --hostname<span class="o">=</span>z.example.com
</pre></div>
</div>
<p>Servers <cite>x</cite> and <cite>y</cite> must be configured to consume from the default queue:</p>
<div class="highlight-bash"><div class="highlight"><pre>user@x:/<span class="nv">$ </span>celery worker -Q default --hostname<span class="o">=</span>x.example.com
user@y:/<span class="nv">$ </span>celery worker -Q default --hostname<span class="o">=</span>y.example.com
</pre></div>
</div>
<p>If you want, you can even have your feed processing worker handle regular
tasks as well, maybe in times when there&#8217;s a lot of work to do:</p>
<div class="highlight-python"><pre>user@z:/$ celery worker -Q feed_tasks,default --hostname=z.example.com</pre>
</div>
<p>If you have another queue but on another exchange you want to add,
just specify a custom exchange and exchange type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu</span> <span class="kn">import</span> <span class="n">Exchange</span><span class="p">,</span> <span class="n">Queue</span>

<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;feed_tasks&#39;</span><span class="p">,</span>    <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;feed.#&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;regular_tasks&#39;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;task.#&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;image_tasks&#39;</span><span class="p">,</span>   <span class="n">exchange</span><span class="o">=</span><span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;mediatasks&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">),</span>
                           <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;image.compress&#39;</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If you&#8217;re confused about these terms, you should read up on AMQP.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">In addition to the <a class="reference internal" href="#amqp-primer"><em>AMQP Primer</em></a> below, there&#8217;s
<a class="reference external" href="http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/">Rabbits and Warrens</a>, an excellent blog post describing queues and
exchanges. There&#8217;s also AMQP in 10 minutes*: <a class="reference external" href="http://bit.ly/95XFO1">Flexible Routing Model</a>,
and <a class="reference external" href="http://bit.ly/EEWca">Standard Exchange Types</a>. For users of RabbitMQ the <a class="reference external" href="http://www.rabbitmq.com/faq.html">RabbitMQ FAQ</a>
could be useful as a source of information.</p>
</div>
</div>
</div>
<div class="section" id="amqp-primer">
<span id="id1"></span><h2><a class="toc-backref" href="#id10">AMQP Primer</a><a class="headerlink" href="#amqp-primer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="messages">
<h3><a class="toc-backref" href="#id11">Messages</a><a class="headerlink" href="#messages" title="Permalink to this headline">¶</a></h3>
<p>A message consists of headers and a body.  Celery uses headers to store
the content type of the message and its content encoding.  The
content type is usually the serialization format used to serialize the
message. The body contains the name of the task to execute, the
task id (UUID), the arguments to apply it with and some additional
metadata &#8211; like the number of retries or an ETA.</p>
<p>This is an example task message represented as a Python dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;task&#39;</span><span class="p">:</span> <span class="s">&#39;myapp.tasks.add&#39;</span><span class="p">,</span>
 <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="s">&#39;54086c5e-6193-4575-8308-dbab76798756&#39;</span><span class="p">,</span>
 <span class="s">&#39;args&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
 <span class="s">&#39;kwargs&#39;</span><span class="p">:</span> <span class="p">{}}</span>
</pre></div>
</div>
</div>
<div class="section" id="producers-consumers-and-brokers">
<span id="amqp-producers-consumers-brokers"></span><h3><a class="toc-backref" href="#id12">Producers, consumers and brokers</a><a class="headerlink" href="#producers-consumers-and-brokers" title="Permalink to this headline">¶</a></h3>
<p>The client sending messages is typically called a <em>publisher</em>, or
a <em>producer</em>, while the entity receiving messages is called
a <em>consumer</em>.</p>
<p>The <em>broker</em> is the message server, routing messages from producers
to consumers.</p>
<p>You are likely to see these terms used a lot in AMQP related material.</p>
</div>
<div class="section" id="exchanges-queues-and-routing-keys">
<span id="amqp-exchanges-queues-keys"></span><h3><a class="toc-backref" href="#id13">Exchanges, queues and routing keys.</a><a class="headerlink" href="#exchanges-queues-and-routing-keys" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Messages are sent to exchanges.</li>
<li>An exchange routes messages to one or more queues.  Several exchange types
exists, providing different ways to do routing, or implementing
different messaging scenarios.</li>
<li>The message waits in the queue until someone consumes it.</li>
<li>The message is deleted from the queue when it has been acknowledged.</li>
</ol>
<p>The steps required to send and receive messages are:</p>
<ol class="arabic simple">
<li>Create an exchange</li>
<li>Create a queue</li>
<li>Bind the queue to the exchange.</li>
</ol>
<p>Celery automatically creates the entities necessary for the queues in
<a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> to work (except if the queue&#8217;s <cite>auto_declare</cite>
setting is set to <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt>).</p>
<p>Here&#8217;s an example queue configuration with three queues;
One for video, one for images and one default queue for everything else:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu</span> <span class="kn">import</span> <span class="n">Exchange</span><span class="p">,</span> <span class="n">Queue</span>

<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">),</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;videos&#39;</span><span class="p">,</span>  <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;media&#39;</span><span class="p">),</span>   <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;media.video&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;images&#39;</span><span class="p">,</span>  <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;media&#39;</span><span class="p">),</span>   <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;media.image&#39;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">CELERY_DEFAULT_QUEUE</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
<span class="n">CELERY_DEFAULT_EXCHANGE_TYPE</span> <span class="o">=</span> <span class="s">&#39;direct&#39;</span>
<span class="n">CELERY_DEFAULT_ROUTING_KEY</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="exchange-types">
<span id="amqp-exchange-types"></span><h3><a class="toc-backref" href="#id14">Exchange types</a><a class="headerlink" href="#exchange-types" title="Permalink to this headline">¶</a></h3>
<p>The exchange type defines how the messages are routed through the exchange.
The exchange types defined in the standard are <cite>direct</cite>, <cite>topic</cite>,
<cite>fanout</cite> and <cite>headers</cite>.  Also non-standard exchange types are available
as plug-ins to RabbitMQ, like the <a class="reference external" href="http://github.com/squaremo/rabbitmq-lvc-plugin">last-value-cache plug-in</a> by Michael
Bridgen.</p>
<div class="section" id="direct-exchanges">
<span id="amqp-exchange-type-direct"></span><h4><a class="toc-backref" href="#id15">Direct exchanges</a><a class="headerlink" href="#direct-exchanges" title="Permalink to this headline">¶</a></h4>
<p>Direct exchanges match by exact routing keys, so a queue bound by
the routing key <cite>video</cite> only receives messages with that routing key.</p>
</div>
<div class="section" id="topic-exchanges">
<span id="amqp-exchange-type-topic"></span><h4><a class="toc-backref" href="#id16">Topic exchanges</a><a class="headerlink" href="#topic-exchanges" title="Permalink to this headline">¶</a></h4>
<p>Topic exchanges matches routing keys using dot-separated words, and the
wildcard characters: <tt class="docutils literal"><span class="pre">*</span></tt> (matches a single word), and <tt class="docutils literal"><span class="pre">#</span></tt> (matches
zero or more words).</p>
<p>With routing keys like <tt class="docutils literal"><span class="pre">usa.news</span></tt>, <tt class="docutils literal"><span class="pre">usa.weather</span></tt>, <tt class="docutils literal"><span class="pre">norway.news</span></tt> and
<tt class="docutils literal"><span class="pre">norway.weather</span></tt>, bindings could be <tt class="docutils literal"><span class="pre">*.news</span></tt> (all news), <tt class="docutils literal"><span class="pre">usa.#</span></tt> (all
items in the USA) or <tt class="docutils literal"><span class="pre">usa.weather</span></tt> (all USA weather items).</p>
</div>
</div>
<div class="section" id="related-api-commands">
<span id="amqp-api"></span><h3><a class="toc-backref" href="#id17">Related API commands</a><a class="headerlink" href="#related-api-commands" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt>
<tt class="descname">exchange.declare(exchange_name, type, passive,</tt></dt>
<dt>
<tt class="descname">durable, auto_delete, internal)</tt></dt>
<dd><p>Declares an exchange by name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>passive</strong> &#8211; Passive means the exchange won&#8217;t be created, but you
can use this to check if the exchange already exists.</li>
<li><strong>durable</strong> &#8211; Durable exchanges are persistent.  That is - they survive
a broker restart.</li>
<li><strong>auto_delete</strong> &#8211; This means the queue will be deleted by the broker
when there are no more queues using it.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="queue.declare">
<tt class="descclassname">queue.</tt><tt class="descname">declare</tt><big>(</big><em>queue_name</em>, <em>passive</em>, <em>durable</em>, <em>exclusive</em>, <em>auto_delete</em><big>)</big><a class="headerlink" href="#queue.declare" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a queue by name.</p>
<p>Exclusive queues can only be consumed from by the current connection.
Exclusive also implies <cite>auto_delete</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="queue.bind">
<tt class="descclassname">queue.</tt><tt class="descname">bind</tt><big>(</big><em>queue_name</em>, <em>exchange_name</em>, <em>routing_key</em><big>)</big><a class="headerlink" href="#queue.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Binds a queue to an exchange with a routing key.
Unbound queues will not receive messages, so this is necessary.</p>
</dd></dl>

<dl class="method">
<dt id="queue.delete">
<tt class="descclassname">queue.</tt><tt class="descname">delete</tt><big>(</big><em>name</em>, <em>if_unused=False</em>, <em>if_empty=False</em><big>)</big><a class="headerlink" href="#queue.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a queue and its binding.</p>
</dd></dl>

<dl class="method">
<dt id="exchange.delete">
<tt class="descclassname">exchange.</tt><tt class="descname">delete</tt><big>(</big><em>name</em>, <em>if_unused=False</em><big>)</big><a class="headerlink" href="#exchange.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes an exchange.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Declaring does not necessarily mean &#8220;create&#8221;.  When you declare you
<em>assert</em> that the entity exists and that it&#8217;s operable.  There is no
rule as to whom should initially create the exchange/queue/binding,
whether consumer or producer.  Usually the first one to need it will
be the one to create it.</p>
</div>
</div>
<div class="section" id="hands-on-with-the-api">
<span id="amqp-api-hands-on"></span><h3><a class="toc-backref" href="#id18">Hands-on with the API</a><a class="headerlink" href="#hands-on-with-the-api" title="Permalink to this headline">¶</a></h3>
<p>Celery comes with a tool called <strong class="program">celery amqp</strong>
that is used for command-line access to the AMQP API, enabling access to
administration tasks like creating/deleting queues and exchanges, purging
queues or sending messages.  It can also be used for non-AMQP brokers,
but different implementation may not implement all commands.</p>
<p>You can write commands directly in the arguments to <strong class="program">celery amqp</strong>,
or just start with no arguments to start it in shell-mode:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery amqp
-&gt; connecting to amqp://guest@localhost:5672/.
-&gt; connected.
1&gt;
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">1&gt;</span></tt> is the prompt.  The number 1, is the number of commands you
have executed so far.  Type <tt class="docutils literal"><span class="pre">help</span></tt> for a list of commands available.
It also supports auto-completion, so you can start typing a command and then
hit the <cite>tab</cite> key to show a list of possible matches.</p>
<p>Let&#8217;s create a queue you can send messages to:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>celery amqp
1&gt; exchange.declare testexchange direct
ok.
2&gt; queue.declare testqueue
ok. queue:testqueue messages:0 consumers:0.
3&gt; queue.bind testqueue testexchange testkey
ok.
</pre></div>
</div>
<p>This created the direct exchange <tt class="docutils literal"><span class="pre">testexchange</span></tt>, and a queue
named <tt class="docutils literal"><span class="pre">testqueue</span></tt>.  The queue is bound to the exchange using
the routing key <tt class="docutils literal"><span class="pre">testkey</span></tt>.</p>
<p>From now on all messages sent to the exchange <tt class="docutils literal"><span class="pre">testexchange</span></tt> with routing
key <tt class="docutils literal"><span class="pre">testkey</span></tt> will be moved to this queue.  You can send a message by
using the <tt class="docutils literal"><span class="pre">basic.publish</span></tt> command:</p>
<div class="highlight-python"><pre>4&gt; basic.publish 'This is a message!' testexchange testkey
ok.</pre>
</div>
<p>Now that the message is sent you can retrieve it again.  You can use the
<tt class="docutils literal"><span class="pre">basic.get`</span></tt> command here, which polls for new messages on the queue
(which is alright for maintainence tasks, for services you&#8217;d want to use
<tt class="docutils literal"><span class="pre">basic.consume</span></tt> instead)</p>
<p>Pop a message off the queue:</p>
<div class="highlight-python"><pre>5&gt; basic.get testqueue
{'body': 'This is a message!',
 'delivery_info': {'delivery_tag': 1,
                   'exchange': u'testexchange',
                   'message_count': 0,
                   'redelivered': False,
                   'routing_key': u'testkey'},
 'properties': {}}</pre>
</div>
<p>AMQP uses acknowledgment to signify that a message has been received
and processed successfully.  If the message has not been acknowledged
and consumer channel is closed, the message will be delivered to
another consumer.</p>
<p>Note the delivery tag listed in the structure above; Within a connection
channel, every received message has a unique delivery tag,
This tag is used to acknowledge the message.  Also note that
delivery tags are not unique across connections, so in another client
the delivery tag <cite>1</cite> might point to a different message than in this channel.</p>
<p>You can acknowledge the message you received using <tt class="docutils literal"><span class="pre">basic.ack</span></tt>:</p>
<div class="highlight-python"><pre>6&gt; basic.ack 1
ok.</pre>
</div>
<p>To clean up after our test session you should delete the entities you created:</p>
<div class="highlight-python"><pre>7&gt; queue.delete testqueue
ok. 0 messages deleted.
8&gt; exchange.delete testexchange
ok.</pre>
</div>
</div>
</div>
<div class="section" id="id2">
<span id="id3"></span><h2><a class="toc-backref" href="#id19">Routing Tasks</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="defining-queues">
<span id="routing-defining-queues"></span><h3><a class="toc-backref" href="#id20">Defining queues</a><a class="headerlink" href="#defining-queues" title="Permalink to this headline">¶</a></h3>
<p>In Celery available queues are defined by the <a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a> setting.</p>
<p>Here&#8217;s an example queue configuration with three queues;
One for video, one for images and one default queue for everything else:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">default_exchange</span> <span class="o">=</span> <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">media_exchange</span> <span class="o">=</span> <span class="n">Exchange</span><span class="p">(</span><span class="s">&#39;media&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>

<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">default_exchange</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">),</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;videos&#39;</span><span class="p">,</span> <span class="n">media_exchange</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;media.video&#39;</span><span class="p">)</span>
    <span class="n">Queue</span><span class="p">(</span><span class="s">&#39;images&#39;</span><span class="p">,</span> <span class="n">media_exchange</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&#39;media.image&#39;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">CELERY_DEFAULT_QUEUE</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
<span class="n">CELERY_DEFAULT_EXCHANGE</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
<span class="n">CELERY_DEFAULT_ROUTING_KEY</span> <span class="o">=</span> <span class="s">&#39;default&#39;</span>
</pre></div>
</div>
<p>Here, the <a class="reference internal" href="../configuration.html#std:setting-CELERY_DEFAULT_QUEUE"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_DEFAULT_QUEUE</span></tt></a> will be used to route tasks that
doesn&#8217;t have an explicit route.</p>
<p>The default exchange, exchange type and routing key will be used as the
default routing values for tasks, and as the default values for entries
in <a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a>.</p>
</div>
<div class="section" id="specifying-task-destination">
<span id="routing-task-destination"></span><h3><a class="toc-backref" href="#id21">Specifying task destination</a><a class="headerlink" href="#specifying-task-destination" title="Permalink to this headline">¶</a></h3>
<p>The destination for a task is decided by the following (in order):</p>
<ol class="arabic simple">
<li>The <a class="reference internal" href="#routers"><em>Routers</em></a> defined in <a class="reference internal" href="../configuration.html#std:setting-CELERY_ROUTES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_ROUTES</span></tt></a>.</li>
<li>The routing arguments to <tt class="xref py py-func docutils literal"><span class="pre">Task.apply_async()</span></tt>.</li>
<li>Routing related attributes defined on the <tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt>
itself.</li>
</ol>
<p>It is considered best practice to not hard-code these settings, but rather
leave that as configuration options by using <a class="reference internal" href="#routers"><em>Routers</em></a>;
This is the most flexible approach, but sensible defaults can still be set
as task attributes.</p>
</div>
<div class="section" id="routers">
<span id="id4"></span><h3><a class="toc-backref" href="#id22">Routers</a><a class="headerlink" href="#routers" title="Permalink to this headline">¶</a></h3>
<p>A router is a class that decides the routing options for a task.</p>
<p>All you need to define a new router is to create a class with a
<tt class="docutils literal"><span class="pre">route_for_task</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyRouter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">route_for_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">task</span> <span class="o">==</span> <span class="s">&#39;myapp.tasks.compress_video&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;exchange&#39;</span><span class="p">:</span> <span class="s">&#39;video&#39;</span><span class="p">,</span>
                    <span class="s">&#39;exchange_type&#39;</span><span class="p">:</span> <span class="s">&#39;topic&#39;</span><span class="p">,</span>
                    <span class="s">&#39;routing_key&#39;</span><span class="p">:</span> <span class="s">&#39;video.compress&#39;</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">None</span>
</pre></div>
</div>
<p>If you return the <tt class="docutils literal"><span class="pre">queue</span></tt> key, it will expand with the defined settings of
that queue in <a class="reference internal" href="../configuration.html#std:setting-CELERY_QUEUES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_QUEUES</span></tt></a>:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span class="p">{</span><span class="s1">&#39;queue&#39;</span><span class="o">:</span> <span class="s1">&#39;video&#39;</span><span class="p">,</span> <span class="s1">&#39;routing_key&#39;</span><span class="o">:</span> <span class="s1">&#39;video.compress&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>becomes &#8211;&gt;</p>
<div class="highlight-javascript"><div class="highlight"><pre><span class="p">{</span><span class="s1">&#39;queue&#39;</span><span class="o">:</span> <span class="s1">&#39;video&#39;</span><span class="p">,</span>
 <span class="s1">&#39;exchange&#39;</span><span class="o">:</span> <span class="s1">&#39;video&#39;</span><span class="p">,</span>
 <span class="s1">&#39;exchange_type&#39;</span><span class="o">:</span> <span class="s1">&#39;topic&#39;</span><span class="p">,</span>
 <span class="s1">&#39;routing_key&#39;</span><span class="o">:</span> <span class="s1">&#39;video.compress&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>You install router classes by adding them to the <a class="reference internal" href="../configuration.html#std:setting-CELERY_ROUTES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_ROUTES</span></tt></a>
setting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyRouter</span><span class="p">(),</span> <span class="p">)</span>
</pre></div>
</div>
<p>Router classes can also be added by name:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;myapp.routers.MyRouter&#39;</span><span class="p">,</span> <span class="p">)</span>
</pre></div>
</div>
<p>For simple task name -&gt; route mappings like the router example above,
you can simply drop a dict into <a class="reference internal" href="../configuration.html#std:setting-CELERY_ROUTES"><tt class="xref std std-setting docutils literal"><span class="pre">CELERY_ROUTES</span></tt></a> to get the
same behavior:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">({</span><span class="s">&#39;myapp.tasks.compress_video&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s">&#39;queue&#39;</span><span class="p">:</span> <span class="s">&#39;video&#39;</span><span class="p">,</span>
                        <span class="s">&#39;routing_key&#39;</span><span class="p">:</span> <span class="s">&#39;video.compress&#39;</span>
                 <span class="p">}},</span> <span class="p">)</span>
</pre></div>
</div>
<p>The routers will then be traversed in order, it will stop at the first router
returning a true value, and use that as the final route for the task.</p>
</div>
<div class="section" id="broadcast">
<h3><a class="toc-backref" href="#id23">Broadcast</a><a class="headerlink" href="#broadcast" title="Permalink to this headline">¶</a></h3>
<p>Celery can also support broadcast routing.
Here is an example exchange <tt class="docutils literal"><span class="pre">broadcast_tasks</span></tt> that delivers
copies of tasks to all workers connected to it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">kombu.common</span> <span class="kn">import</span> <span class="n">Broadcast</span>

<span class="n">CELERY_QUEUES</span> <span class="o">=</span> <span class="p">(</span><span class="n">Broadcast</span><span class="p">(</span><span class="s">&#39;broadcast_tasks&#39;</span><span class="p">),</span> <span class="p">)</span>

<span class="n">CELERY_ROUTES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;tasks.reload_cache&#39;</span><span class="p">:</span> <span class="s">&#39;broadcast_tasks&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>Now the <tt class="docutils literal"><span class="pre">tasks.reload_tasks</span></tt> task will be sent to every
worker consuming from this queue.</p>
<div class="admonition-broadcast-results admonition">
<p class="first admonition-title">Broadcast &amp; Results</p>
<p>Note that Celery result does not define what happens if two
tasks have the same task_id.  If the same task is distributed to more
than one worker, then the state history may not be preserved.</p>
<p class="last">It is a good idea to set the <tt class="docutils literal"><span class="pre">task.ignore_result</span></tt> attribute in
this case.</p>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a href="/">Home</a>:
        «&#160;&#160;<a href="remote-tasks.html">HTTP Callback Tasks (Webhooks)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="monitoring.html">Monitoring and Management Guide</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, HDKNR.COM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre/3c28de26aac2.
    </div>
  </body>
</html>