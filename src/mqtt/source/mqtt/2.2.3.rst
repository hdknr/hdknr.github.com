2.2.3 Remaining Length
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Position: starts at byte 2.
 
The Remaining Length is the number of bytes remaining within the current packet, including data in the variable header and the payload. The Remaining Length does not include the bytes used to encode the Remaining Length.
 
The Remaining Length is encoded using a variable length encoding scheme which uses a single byte for values up to 127. Larger values are handled as follows. The least significant seven bits of each byte encode the data, and the most significant bit is used to indicate that there are following bytes in the representation. Thus each byte encodes 128 values and a "continuation bit". The maximum number of bytes in the Remaining Length field is four.
 
.. note::  Non normative comment

    For example, the number 64 decimal is encoded as a single byte, decimal value 64, hexadecimal 0x40. The number 321 decimal (= 65 + 2*128) is encoded as two bytes, least significant first. The first byte is 65+128 = 193. Note that the top bit is set to indicate at least one following byte. The second byte is 2.
 
.. note:: Non normative comment
    This allows applications to send Control Packets of size up to 268,435,455 (256 MB). The representation of this number on the wire is: 0xFF, 0xFF, 0xFF, 0x7F.

    Table 2.4 shows the Remaining Length values represented by increasing numbers of bytes.


.. image:: mqtt/tab.2.4.png


.. note:: Non normative comment
    The algorithm for encoding a non negative integer (X) into the variable length encoding scheme is as follows:

    ::

            do
                  encodedByte = X MOD 128
                  X = X DIV 128
                 // if there are more data to encode, set the top bit of this byte
                 if ( X > 0 )
                     encodedByte = encodedByte OR 128
                 endif
                     'output' encodedByte
            while ( X > 0 )
     
    Where MOD is the modulo operator (% in C), DIV is integer division (/ in C), and OR is bit-wise or (| in C).

.. note:: Non normative comment
    The algorithm for decoding the Remaining Length field is as follows:
     
    ::

           multiplier = 1
           value = 0
           do
                encodedByte = 'next byte from stream'
                value += (encodedByte AND 127) * multiplier
                multiplier * = 128
                if (multiplier > 128*128*128)
                   throw Error(Malformed Remaining Length)
           while ((encodedByte AND 128) != 0)
    

    where AND is the bit-wise and operator (& in C).
     
    When this algorithm terminates, value contains the Remaining Length value.

     
