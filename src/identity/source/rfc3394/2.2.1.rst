2.2.1 Key Wrap
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The inputs to the key wrapping process are 
the KEK and the plaintext to be wrapped.  

The plaintext consists of n 64-bit blocks, 
containing the key data being wrapped.  

The key wrapping process is described below.


Inputs:      Plaintext, n 64-bit values {P1, P2, ..., Pn}, and
             Key, K (the KEK).
Outputs:     Ciphertext, (n+1) 64-bit values {C0, C1, ..., Cn}.

1) Initialize variables.

    Set A0 to an initial value (see :ref:`2.2.3 <rfc3394.2.2.3>`)

::

    For i = 1 to n
         R[0][i] = P[i]

2) Calculate intermediate values.

::

    For t = 1 to s, where s = 6n
        A[t] = MSB(64, AES(K, A[t-1] | R[t-1][1])) ^ t
        For i = 1 to n-1
            R[t][i] = R[t-1][i+1]
        R[t][n] = LSB(64, AES(K, A[t-1] | R[t-1][1]))

3) Output the results.

::

    Set C[0] = A[t]
    For i = 1 to n
        C[i] = R[t][i]

An alternative description of the key wrap algorithm involves
indexing rather than shifting.  

This approach allows one to calculate the wrapped key in place, 
avoiding the rotation in the previous description.  

This produces identical results and is more easily
implemented in software.


Inputs:  Plaintext, n 64-bit values {P1, P2, ..., Pn}, and
         Key, K (the KEK).
Outputs: Ciphertext, (n+1) 64-bit values {C0, C1, ..., Cn}.

1) Initialize variables.

::

    Set A = IV, an initial value (see 2.2.3)
    For i = 1 to n
        R[i] = P[i]

2) Calculate intermediate values.

::

    For j = 0 to 5
        For i=1 to n
            B = AES(K, A | R[i])
            A = MSB(64, B) ^ t where t = (n*j)+i
            R[i] = LSB(64, B)

3) Output the results.

::

    Set C[0] = A
    For i = 1 to n
        C[i] = R[i]
