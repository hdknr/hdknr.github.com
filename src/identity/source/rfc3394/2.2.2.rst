2.2.2 Key Unwrap
^^^^^^^^^^^^^^^^^^^^

The inputs to the unwrap process are 
the KEK and (n+1) 64-bit blocks of ciphertext 
consisting of previously wrapped key.  

It returns **n blocks** of plaintext 
consisting of the **n 64-bit blocks** of the decrypted key data.

Inputs:  Ciphertext, (n+1) 64-bit values {C0, C1, ..., Cn}, and
        Key, K (the KEK).
Outputs: Plaintext, n 64-bit values {P1, P2, ..., Pn}.

1) Initialize variables.

::

    Set A[s] = C[0] where s = 6n
    For i = 1 to n
        R[s][i] = C[i]

2) Calculate the intermediate values.

::

    For t = s to 1
        A[t-1] = MSB(64, AES-1(K, ((A[t] ^ t) | R[t][n]))
        R[t-1][1] = LSB(64, AES-1(K, ((A[t]^t) | R[t][n]))
        For i = 2 to n
            R[t-1][i] = R[t][i-1]

3) Output the results.

::

    If A[0] is an appropriate initial value (see 2.2.3),

    Then
        For i = 1 to n
            P[i] = R[0][i]
    Else
        Return an error

The unwrap algorithm can also be specified 
as an index based operation, 
allowing the calculations to be carried out in place.

Again, 
this produces the same results as the register shifting approach.

Inputs:  Ciphertext, (n+1) 64-bit values {C0, C1, ..., Cn}, and
         Key, K (the KEK).

Outputs: Plaintext, n 64-bit values {P0, P1, K, Pn}.

1) Initialize variables.

::

    Set A = C[0]
    For i = 1 to n
        R[i] = C[i]

2) Compute intermediate values.

::

    For j = 5 to 0
        For i = n to 1
            B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i
            A = MSB(64, B)
            R[i] = LSB(64, B)

3) Output results.

::

    If A is an appropriate initial value (see 2.2.3),
    Then
        For i = 1 to n
            P[i] = R[i]
    Else
        Return an error

