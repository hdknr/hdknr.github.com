2. Use Cases
============================

This section is non-normative

.. note:: Editorial note

    ACTION-13
            Add missing use cases.

    ACTION-15
            Insert in "right place" a description of high-level example

    ACTION-27
            Add additional primary use cases.
            Should these use cases be migrated to the Introduction section, and include non-normative examples of how the API can be used to perform each operation?


2.1. Multi-factor Authentication
--------------------------------------------------------

A web application may wish to extend or replace existing username/password based authentication schemes 
with authentication methods based on proving that the user has access to some secret :term:`keying material`.
Rather than using transport-layer authentication, such as TLS client certificates, 
the web application may wish to provide a rich user experience 
by providing authentication within the application itself.

Using the Web Cryptography API, 
such an application could locate suitable client keys, 
which may have been previously generated via the user agent 
or pre-provisioned out-of-band by the web application. 
It could then perform cryptographic operations 
such as decrypting an authentication challenge followed by signing an authentication response.

Further, 
the authentication data could be further enhanced by binding the authentication 
to the TLS session that the client is authenticating over, 
by deriving a key based on properties of the underlying transport.

If a user did not already have a key associated with their account, 
the web application could direct the user agent to either generate a new key 
or to re-use an existing key of the user's choosing.

2.2. Protected Document Exchange
--------------------------------------------------------

When exchanging documents that may contain sensitive or personal information, a web application may wish to ensure that only certain users can view the documents, even after they have been securely received, such as over TLS. One way that a web application can do so is by encrypting the documents with a secret key, and then wrapping that key with the public keys associated with authorized users.

When a user agent navigates to such a web application, the application may send the encrypted form of the document. The user agent is then instructed to unwrap the encryption key, using the user's private key, and from there, decrypt and display the document.

2.3. Cloud Storage
--------------------------------------------------------

When storing data with remote service providers, users may wish to protect the confidentiality of their documents and data prior to uploading them. The Web Cryptography API allows an application to have a user select a private or secret key, to either derive encryption keys from the selected key or to directly encrypt documents using this key, and then to upload the transformed/encrypted data to the service provider using existing APIs.

This use case is similar to the Protected Document Exchange use case because Cloud Storage can be considered as a user exchanging protected data with himself in the future.

2.4. Document Signing
--------------------------------------------------------

A web application may wish to accept electronic signatures on documents, in lieu of requiring physical signatures. An authorized signature may use a key that was pre-provisioned out-of-band by the web application, or it may be using a key that the client generated specifically for the web application.

The web application must be able to locate any appropriate keys for signatures, then direct the user to perform a signing operation over some data, as proof that they accept the document.

2.5. Data Integrity Protection
--------------------------------------------------------

When caching data locally, an application may wish to ensure that this data cannot be modified in an offline attack. In such a case, the server may sign the data that it intends the client to cache, with a private key held by the server. The web application that subsequently uses this cached data may contain a public key that enables it to validate that the cache contents have not been modified by anyone else.

2.6. Secure Messaging
--------------------------------------------------------

In addition to a number of web applications already offering chat based services, the rise of WebSockets and RTCWEB allows a great degree of flexibility in inter-user-agent messaging. While TLS/DTLS may be used to protect messages to web applications, users may wish to directly secure messages using schemes such as off-the-record (OTR) messaging.

The Web Cryptography API enables OTR, by allowing key agreement to be performed so that the two parties can negotiate shared encryption keys and message authentication code (MAC) keys, to allow encryption and decryption of messages, and to prevent tampering of messages through the MACs.

2.7. Javascript Object Signing and Encryption (JOSE)
--------------------------------------------------------

A web application wishes to make use of the structures and format of messages defined by the IETF Javascript Object Signing and Encryption (JOSE) Working Group. The web application wishes to manipulate public keys encoded in the JSON key format (JWK), messages that have been integrity protected using digital signatures or MACs (JWS), or that have been encrypted (JWE).

2.8. Out-of-Band Key Provisioning
--------------------------------------------------------

Web applications may wish to use keys that have been provisioned through means outside the scope of this API. This may include keys that are provisioned through platform-specific native APIs, stored in secure elements such as smart cards or trusted platform modules (TPMs), or individually bound to devices at time of manufacturing. Such keys may, for example, be used to assist in identifying a client to a specific web service. User agents may choose to expose such keys to web applications after implementing appropriate security and privacy mitigations, such as gaining user consent or other out-of-band authorization.

In this scenario, a web application discovers a pre-provisioned key based on its attributes and uses it to perform authorized cryptographic operations as part of a protocol with a server. The server may utilize knowledge obtained out-of-band regarding the key's provisioning to make access control and policy decisions, such as inferring the identity of the user and/or device and customizing its responses based on that.



