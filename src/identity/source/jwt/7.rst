7.  Rules for Creating and Validating a JWT
====================================================

.. note::
    - :doc:`jws` : [:term:`Encoded JWS Header`].[:term:`Encoded JWS Payload`].[:term:`Encoded JWS Signature`] 
    - :doc:`jwe` - [:term:`Encoded JWE Header`].[:term:`Encoded JWE Encrypted Key`].[:term:`Encoded JWE Ciphertext`] 
    - **plaintext** - [:term:`Encoded JWT Header`].[:term:`Message`] 

.. glossary::
    Message
         UTF-8 representation of the :term:`JWT Claims Object`

To create a JWT, one MUST follow these steps:

    1.  Create a :term:`JWT Claims Object` containing the desired claims. 
        Note that :term:`white space` is explicitly allowed in the representation 
        and no canonicalization is performed before encoding.

    2.  Let the :term:`Message` be the bytes of the UTF-8 representation of the :term:`JWT Claims Object`.

    3.  Create a :term:`JWT Header` containing the desired set of header parameters. 

        If the JWT is to be signed or encrypted, 
        they MUST conform to either the [:term:`JWS`] or [:term:`JWE`] specifications, respectively. 

        Else, if the JWT is to be :term:`plaintext`, 
        the :term:`alg` value **none** MUST be used. 
        Note that :term:`white space` is explicitly allowed in the representation 
        and no canonicalization is performed before encoding.

    4.  Base64url encode the bytes of the UTF-8 representation of the :term:`JWT Header`. 
        Let this be the :term:`Encoded JWT Header`.

    5.  Depending upon whether the JWT is to be signed, encrypted, or plaintext, there are three cases:

        -   If the JWT is to be signed, 
            create a JWS using the :term:`JWT Header` as the :term:`JWS Header` 
            and the :term:`Message` as the :term:`JWS Payload`; 

            all steps specified in [:term:`JWS`] for creating a JWS MUST be followed. 

            Let the :term:`JWT Second Part` be the :term:`Encoded JWS Payload` and 
            let the :term:`JWT Third Part` be the :term:`Encoded JWS Signature`.

        -   If the JWT is to be encrypted, 
            create a JWE using the :term:`JWT Header` as the :term:`JWE Header` and 
            the :term:`Message` as the :term:`JWE Plaintext`; 

            all steps specified in [:term:`JWE`] for creating a JWE MUST be followed.
            Let the :term:`JWT Second Part` be the :term:`Encoded JWE Encrypted Key` and 
            let the :term:`JWT Third Part` be the :term:`Encoded JWE Ciphertext`.

        -   Else, 
            if the JWT is to be :term:`plaintext`, 
            let the :term:`JWT Second Part` be the base64url encoding of the :term:`Message` 
            and let the :term:`JWT Third Part` be the **empty string**.

    6.  Concatenate the :term:`Encoded JWT Header`, 
        the :term:`JWT Second Part`, 
        and the :term:`JWT Third Part` in that order, 
        separating each by **period ('.')** characters.

    7.  If a nested signing or encryption operation will be performed, 
        let the :term:`Message` be this concatenation, and return to Step 3, 
        using a :term:`typ` value of either "JWS" or "JWE" respectively in the new JWT Header created in that step.

    8.  Otherwise, let the resulting JWT be this concatenation.

When validating a JWT the following steps MUST be taken. If any of the listed steps fails then the token MUST be rejected for processing.


    1.  The JWT MUST contain exactly **two period characters**.

    2.  The JWT MUST be split on the two period characters resulting in three strings. 
        The first string is the :term:`Encoded JWT Header`; 
        the second is the :term:`JWT Second Part`; 
        the third is the :term:`JWT Third Part`.

    3.  The :term:`Encoded JWT Header` MUST be successfully **base64url decoded** 
        following the restriction given in this specification that **no padding characters** have been used.

    4.  The :term:`JWT Header` MUST be completely valid JSON syntax conforming to RFC 4627 [:term:`RFC4627`].

    5.  The :term:`JWT Header` MUST be validated to only include parameters 
        and values whose syntax and semantics are both understood and supported.

    6.  Determine whether the JWT is signed, encrypted, or plaintext 
        by examining the :term:`alg` (algorithm) header value and optionally, 
        the :term:`enc` (encryption method) header value, 
        if present.

    7.  Depending upon whether the JWT signed, encrypted, or plaintext, there are three cases:

        -   If the JWT is signed, all steps specified in [JWS] for validating a JWS MUST be followed. 
            Let the Message be the result of base64url decoding the JWS Payload.

        -   If the JWT is encrypted, all steps specified in [JWE] for validating a JWE MUST be followed. 
            Let the Message be the JWE Plaintext.

        -   Else, 
            if the JWT is plaintext, 
            let the Message be the result of base64url decoding the JWE Second Part. 
            The Third Part MUST be verified to be the empty string.

    8.      If the JWT Header contains a typ value of either "JWS" or "JWE", then the Message contains a JWT that was the subject of nested signing or encryption operations, respectively. In this case, return to Step 1, using the Message as the JWT.

    9.      Otherwise, let the JWT Claims object be the Message.

    10.     The JWT Claims Object MUST be completely valid JSON syntax conforming to RFC 4627 [RFC4627].

    11.     When used in a security-related context, 
            the JWT Claims Object MUST be validated to only include claims whose syntax and semantics are both understood and supported.

Processing a JWT inevitably requires comparing known strings to values in the token. For example, in checking what the algorithm is, the Unicode string encoding alg will be checked against the member names in the JWT Header to see if there is a matching header parameter name. A similar process occurs when determining if the value of the alg header parameter represents a supported algorithm. Comparing Unicode strings, however, has significant security implications, as per Section 10.

Comparisons between JSON strings and other Unicode strings MUST be performed as specified below:

    1.      Remove any JSON applied escaping to produce an array of Unicode code points.

    2.      Unicode Normalization [USA15] MUST NOT be applied at any point to either the JSON string or to the string it is to be compared against.

    3.      Comparisons between the two strings MUST be performed as a Unicode code point to code point equality comparison.

(v.06)

