7.  Rules for Creating and Validating a JWT
====================================================

To create a JWT, one MUST follow these steps:

    1.  Create a JWT Claims Object containing the desired claims. 
        Note that white space is explicitly allowed in the representation and no canonicalization is performed before encoding.

    2.  Let the Message be the bytes of the UTF-8 representation of the JWT Claims Object.

    3.  Create a JWT Header containing the desired set of header parameters. 
        If the JWT is to be signed or encrypted, 
        they MUST conform to either the [JWS] or [JWE] specifications, respectively. 
        Else, if the JWT is to be plaintext, 
        the alg value none MUST be used. 
        Note that white space is explicitly allowed in the representation 
        and no canonicalization is performed before encoding.

    4.  Base64url encode the bytes of the UTF-8 representation of the JWT Header. 
        Let this be the Encoded JWT Header.

    5.  Depending upon whether the JWT is to be signed, encrypted, or plaintext, there are three cases:

        -   If the JWT is to be signed, 
            create a JWS using the JWT Header as the JWS Header and the Message as the JWS Payload; 
            all steps specified in [JWS] for creating a JWS MUST be followed. 
            Let the JWT Second Part be the Encoded JWS Payload and 
            let the JWT Third Part be the Encoded JWS Signature.

        -   If the JWT is to be encrypted, 
            create a JWE using the JWT Header as the JWE Header and 
            the Message as the JWE Plaintext; 
            all steps specified in [JWE] for creating a JWE MUST be followed.
            Let the JWT Second Part be the Encoded JWE Encrypted Key and 
            let the JWT Third Part be the Encoded JWS Ciphertext.

        -   Else, 
            if the JWT is to be plaintext, 
            let the JWT Second Part be the base64url encoding of the Message and let the JWT Third Part be the empty string.

    6.  Concatenate the Encoded JWT Header, 
        the JWT Second Part, 
        and the JWT Third Part in that order, 
        separating each by period ('.') characters.

    7.  If a nested signing or encryption operation will be performed, 
        let the Message be this concatenation, and return to Step 3, 
        using a typ value of either "JWS" or "JWE" respectively in the new JWT Header created in that step.

    8.  Otherwise, let the resulting JWT be this concatenation.

When validating a JWT the following steps MUST be taken. If any of the listed steps fails then the token MUST be rejected for processing.


    1.  The JWT MUST contain exactly two period characters.

    2.  The JWT MUST be split on the two period characters resulting in three strings. The first string is the Encoded JWT Header; the second is the JWT Second Part; the third is the JWT Third Part.

    3.  The Encoded JWT Header MUST be successfully base64url decoded following the restriction given in this specification that no padding characters have been used.

    4.  The JWT Header MUST be completely valid JSON syntax conforming to RFC 4627 [RFC4627].

    5.  The JWT Header MUST be validated to only include parameters and values whose syntax and semantics are both understood and supported.

    6.  Determine whether the JWT is signed, encrypted, or plaintext by examining the alg (algorithm) header value and optionally, the enc (encryption method) header value, if present.

    7.  Depending upon whether the JWT signed, encrypted, or plaintext, there are three cases:

        -   If the JWT is signed, all steps specified in [JWS] for validating a JWS MUST be followed. 
            Let the Message be the result of base64url decoding the JWS Payload.

        -   If the JWT is encrypted, all steps specified in [JWE] for validating a JWE MUST be followed. 
            Let the Message be the JWE Plaintext.

        -   Else, 
            if the JWT is plaintext, 
            let the Message be the result of base64url decoding the JWE Second Part. 
            The Third Part MUST be verified to be the empty string.

    8.      If the JWT Header contains a typ value of either "JWS" or "JWE", then the Message contains a JWT that was the subject of nested signing or encryption operations, respectively. In this case, return to Step 1, using the Message as the JWT.

    9.      Otherwise, let the JWT Claims object be the Message.

    10.     The JWT Claims Object MUST be completely valid JSON syntax conforming to RFC 4627 [RFC4627].

    11.     When used in a security-related context, 
            the JWT Claims Object MUST be validated to only include claims whose syntax and semantics are both understood and supported.

Processing a JWT inevitably requires comparing known strings to values in the token. For example, in checking what the algorithm is, the Unicode string encoding alg will be checked against the member names in the JWT Header to see if there is a matching header parameter name. A similar process occurs when determining if the value of the alg header parameter represents a supported algorithm. Comparing Unicode strings, however, has significant security implications, as per Section 10.

Comparisons between JSON strings and other Unicode strings MUST be performed as specified below:

    1.      Remove any JSON applied escaping to produce an array of Unicode code points.

    2.      Unicode Normalization [USA15] MUST NOT be applied at any point to either the JSON string or to the string it is to be compared against.

    3.      Comparisons between the two strings MUST be performed as a Unicode code point to code point equality comparison.

(v.06)

