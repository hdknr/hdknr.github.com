7.4.  Entropy of the code_verifier
------------------------------------------

   The client SHOULD create a code_verifier with a minimum of 256bits of
   entropy.  This can be done by having a suitable random number
   generator create a 32-octet sequence.  The Octet sequence can then be
   Base64url encoded to produce a 42-octet URL safe string to use as a
   code_challenge that has the required entropy.

   Salting is not used in the production of the code_verifier, as the
   code_chalange contains sufficient entropy to prevent brute force
   attacks.  Concatenating a publicly known value to a code_challenge
   (with 256 bits of entropy) and then hashing it with SHA256 would
   actually reduce the entropy in the resulting code_verifier making it
   easier for an attacker to brute force.

   While the S256 transformation is like hashing a password there are
   important differences.  Passwords tend to be relatively low entropy
   words that can be hashed offline and the hash looked up in a
   dictionary.  By concatenating a unique though public value to each
   password prior to hashing, the dictionary space that an attacker
   needs to search is greatly expanded.

   Modern graphics processors now allow attackers to calculate hashes in
   real time faster than they could be looked up from a disk.  This
   eliminates the value of the salt in increasing the complexity of a
   brute force attack for even low entropy passwords.

