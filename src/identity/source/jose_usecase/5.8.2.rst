5.8.2.  Object security for CoAP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This use case deals with constrained devices of class C0/C1 
(see :term:`[I-D.ietf-lwig-terminology]`).  

These devices communicate using RESTful requests 
and responses transferred using the CoAP protocol
:term:`[I-D.ietf-core-coap]`.  

To simplify matters, 
all communication is assumed to be unicast, 
i.e. these security measures don't cover
multicast or broadcast.

In this type of setting it may be too costly to use session based
security (e.g. to run a 4 pass authentication protocol) since
receiving and in particular sending consumes a lot of power, in
particular for wireless devices.  Therefore to just secure the CoAP
payload by replacing a plain text payload of a request or response
with a JWE object is an important alternative solution, which allows
a trade-off between protection (the CoAP headers are not protected)
and performance.

In a simple setting, consider the payload of a CoAP GET response from
a sensor type device.  The information in a sensor reading may be
privacy or business sensitive and needs both integrity protection and
encryption.

However some sensor readings are very short, say a few bytes, and in
this case default encryption and integrity protection algorithms
(such as 128 bit AES with HMAC_SHA256) may cause a dramatic message
expansion of the payload, even disregarding JWE headers.

Also the value of certain sensor readings may decline rapidly, e.g.
traffic or environmental measurements, so it must be possible to
reduce the security overhead.

This leads to the following requirements which could be covered by
specific JWE/JWS profiles:


-  The size of the secure object shall be as small as possible.
   Receiving an object may cost orders of magnitude more in terms of
   power than performing say public key cryptography on the object,
   in particular in a wireless setting.

-  Integrity protection: The object shall be able to support
   integrity protection, i.e. have a field containing a digital
   signature, both public key signatures and keyed message
   authentication codes shall be supported.

-  Encryption: The object shall be able to support encryption as an
   optional addition to integrity protection.  It shall be possible
   to exclude certain fields from encryption which are needed before
   verifying integrity or decrypting the object.

-  Cipher suites: It should be possible to support a variety of
   cipher suites to support the constrained devices use cases.  For
   example:

   *  Block ciphers with block sizes of e.g. 96 bits, in addition to
      the standard 128 bits

   *  Modes of operation for block ciphers that do not expand the
      message size to a block boundary, such as AES-GCM.

   *  Cipher suites that support combined encryption and MAC
      calculation (i.e., AEAD modes for block ciphers).

(draft06)
