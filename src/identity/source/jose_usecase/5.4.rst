5.4.  XMPP
---------------

The Extensible Messaging and Presence Protocol (XMPP) routes 
messages from one end client to another 
by way of :term:`XMPP` servers :term:`[RFC6120]`.

There are typically two servers involved in delivering 
any given message: 
The first client (Alice) sends a message for another client (Bob) 
to her server (A).  

Server A uses Bob's identity and the DNS to locate the server 
for Bob's domain (B), 
then delivers the message to that server.  

Server B then routes the message to Bob.

::

         +-------+   +----------+   +----------+   +-----+
         | Alice |-->| Server A |-->| Server B |-->| Bob |
         +-------+   +----------+   +----------+   +-----+

                Figure 2: Delivering an XMPP message

The untrusted-intermediary problems are especially acute for XMPP
because in many current deployments, 
the holder of an XMPP domain outsources the operation of 
the domain's servers to a different entity.  

In this environment, 
there is a clear risk of exposing the domain holder's private information 
to the domain operator.  

XMPP already has a defined mechanism for end-to-end security using S/MIME,
but it has failed to gain widespread deployment [RFC3923], 
in part because of key management challenges and because of the difficulty of
processing S/MIME objects.

The XMPP working group is in the process of developing a new end-to-
end encryption system with an encoding based on JOSE and a clearer
key management system [I-D.miller-xmpp-e2e].  

The process of sending an encrypted message in this system 
involves two steps: 
First, 
the **sender** generates a **symmetric** :term:`Session Master Key` (SMK), 
encrypts the message content 
(including a per-message Content Master Key), and
sends the **encrypted message** to the desired set of recipients.

Second, 
each recipient "**dials back**" to the sender, 
providing his public key.  
The sender then responds with the relevant SMK, 
wrapped with the recipient's public key.

::

         +-------+   +----------+   +----------+   +-----+
         | Alice |<->| Server A |<->| Server B |<->| Bob |
         +-------+   +----------+   +----------+   +-----+
             |             |              |           |
             |------------Encrypted--message--------->|
             |             |              |           |
             |<---------------Public-key--------------|
             |             |              |           |
             |---------------Wrapped SMK------------->|
             |             |              |           |

             Figure 3: Delivering a secure XMPP message

The main thing that 
this system requires from the JOSE formats is
**confidentiality protection** via **content encryption**, 
plus an integrity check via a MAC derived from the same symmetric key.  

The separation of the **key exchange** from the transmission of the encrypted content,
however, 
requires that the JOSE encrypted object format 
allow wrapped symmetric keys to be carried separately 
from the encrypted payload.

In addition, 
the encrypted object will need to have a **tag** for the key
that was used to encrypt the content, 
so that the **recipient** (Bob) can present the **tag** to the sender (Alice) 
when requesting the wrapped key.

Another important feature of XMPP is that 
it allows for the simultaneous delivery of a message to multiple recipients.  

In the diagrams above, 
Server A could deliver the message not only to Server B (for Bob) 
but also to Servers C, D, E, etc. for other users.  

In such cases, 
to avoid the multiple "dial back" transactions implied by
the above mechanism, 
XMPP systems will likely re-use a given SMK for multiple individual messages, 
refreshing the SMK on a periodic and/or event-driven basis 
(e.g., when the recipient's presence changes).


They might also cache public keys for end recipients, 
so that wrapped keys can be sent along with content on future messages.  
This implies that the JOSE encrypted object format must support the provision of
multiple versions of the same wrapped SMK 
(much as a CMS EnvelopedData structure can include multiple RecipientInfo structures).

In the current draft of the XMPP end-to-end security system, 
each party is authenticated by virtue of the other party's trust 
in the XMPP message routing system.  

The sender is authenticated to the receiver 
because he can receive messages for the identifier "Alice" 
(in particular, the request for wrapped keys), 
and can originate messages for that identifier (the wrapped key).  

Likewise, 
the receiver is authenticated to the sender 
because he received the original encrypted message 
and originated the request for wrapped key.  

So the authentication here requires not only that XMPP routing
be done properly, 
but also that TLS be used on every hop.  

Moreover,
it requires that the TLS channels have strong authentication, 
since a :term:`man in the middle` on any of the three hops 
can masquerade as Bob and obtain the key material 
for an encrypted message.

Because this authentication is quite weak 
(depending on the use of transport-layer security on three hops) 
and unverifiable by the endpoints, 
it is possible that the XMPP working group will 
integrate some sort of credentials for end recipients, 
in which case there would need to be a way 
to associate these credentials with JOSE objects.


.. note::
    - XMPPのメッセージはXMLだけど、JoseはXML運べるから

Finally, 
it's worth noting that XMPP is based on XML, not JSON.  
So by using JOSE, 
XMPP will be carrying JSON objects within XML.  
It is thus a desirable property for JOSE objects to be encoded 
in such a way as to be safe for inclusion in XML.  

Otherwise, 
an explicit :term:`CDATA` indication must be given to the parser 
to indicate that it is not to be parsed as XML.  

One way to meet this requirement 
would be to apply :term:`base64url encoding`, 
but for XMPP messages of medium-to-large size,
this could impose a fair degree of overhead.

(draft06)
