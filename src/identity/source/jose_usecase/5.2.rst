5.2.  OAuth
------------------------------------------------------------------------------------

The OAuth protocol defines a mechanism 
for distributing and using authorization tokens 
using HTTP [RFC6749].  

A **Client** that wishes to access a **protected resource** 
requests **authorization** from the **Resource Owner**.  

If the Resource Owner allows this access, 
he directs an Authorization Server 
to issue an access token to the Client.  

When the Client wishes to access the protected resource, 
he presents the token to the relevant Resource Server, 
which verifies the validity of the token 
before providing access to the protected resource.

::

              +---------------+          +---------------+
              |               |          |               |
              |   Resource    |<........>| Authorization |
              |    Server     |          |     Server    |
              |               |          |               |
              +---------------+          +---------------+
                           ^                |
                           |                |
                           |                |
                           |                |
                           |                |
              +------------|--+          +--|------------+
              |            +----------------+            |
              |               |          |   Resource    |
              |     Client    |          |     Owner     |
              |               |          |               |
              +---------------+          +---------------+

                     Figure 1: The OAuth process

In effect, 
this process moves the token from the Authorization Server
(as a sender of the object) 
to the Resource Server (recipient), via
the Client as well as the Resource Owner 
(the latter because of the HTTP mechanics underlying the protocol).  

So again we have a case where an application object is transported 
via untrusted intermediaries.



This application has two essential security requirements: 
**Integrity** and **data origin authentication**.  

.. note::
    - インテグリティ

Integrity protection is required so
that the Resource Owner and the Client cannot modify 
the permission encoded in the token.  

Although the Resource Owner is ultimately the
entity that grants authorization, 
it is not trusted to modify the authorization token, 
since this could, for example, grant access to
resources not owned by the Resource Owner.

.. note::
    - 認証

Data origin authentication is required so that 
the Resource Server can verify that the token was issued 
by a trusted Authorization Server.


Confidentiality protection may also be needed, 
if the Authorization Server is concerned 
about the visibility of permissions information 
to the Resource Owner or Client.  

For example, 
permissions related to social networking 
might be considered private information.  

Note, however, 
that OAuth already requires that the underlying HTTP
transactions be protected by TLS, 
so tokens are already confidentiality-protected 
from entities other than the Resource Owner and Client.


The confidentiality and integrity needs are met 
by the basic requirements for signed and encrypted object formats, 
whether the signing and encryption are provided 
using asymmetric or symmetric cryptography.  

The choice of which mechanism is applied will 
depend on the relationship between the two servers, 
namely whether they share a symmetric key or only public keys.


Authentication requirements will also 
depend on deployment characteristics.  

Where there is a relatively strong binding between
the resource server and the authorization server, 
it may suffice for the Authorization Server 
issuing a token to be identified by the key used to sign the token.  

This requires that the protocol carry either
the public key of the Authorization Server or an identifier for the
public or symmetric key.  
In OAuth, 
the "**client_id**" parameter identifies the key to be used.


There may also be more advanced cases, 
where the Authorization Server's key is not known 
in advance to the Resource Server.  

This may happen, for instance, 
if an entity instantiated a collection of Authorization Servers 
(say for load balancing), 
each of which has an independent key pair.  
In these cases, 
it may be necessary to also include a certificate 
or certificate chain for the Authorization Server, 
so that the Resource Server can verify that the Authorization Server 
is an entity that it trusts.

The HTTP transport for OAuth imposes a particular constraint 
on the encoding.  


.. note::
    - トークンのサイズの注意

In the OAuth protocol, 
tokens frequently need to be passed as query parameters 
in HTTP URIs [RFC2616], 
after having been base64url encoded [RFC4648].  

While there is no specified limit on the length of URIs 
(and thus of query parameters), 
in practice, 
URIs of more than 2,048 characters are rejected by some user agents.  

For some mobile browsers, 
this limit is even smaller.  
So this use case requires that 
a JOSE object have sufficiently small size even after signing, 
possibly encrypting, 
while still being simple to include in an HTTP URI query parameter.

(draft06)
