1.  Introduction
=========================

.. note::
    - チャネルプロテクションだけでは足りないので、オブジェクトプロテクション

Internet applications rest on the layered architecture of the Internet, 
and take advantage of security mechanisms at all layers.

Many applications rely primarily 
on **channel-based security technologies** 
such as :term:`IPsec` and :term:`TLS`, 
which create a secure channel at the IP layer 
or transport layer over which application data can flow
[RFC4301][RFC5246].  

These mechanisms, however, cannot provide end-to-end security in some cases.  

For example, 
in protocols with application-layer intermediaries, 
channel-based security protocols
would protect messages from attackers between intermediaries, 
but not from the intermediaries themselves.  
These cases require **object-based security technologies**, 
which embed application data within a secure object 
that can be safely handled by untrusted entities.


.. note::
    - S/MIME はオブジェクトプロテクション


The most well-known example of such a protocol today is 
the use of Secure/Multipurpose Internet Mail Extensions 
(:term:`S/MIME`) protections within the email system 
:term:`[RFC5751]`:term:`[RFC5322]`.  


An email message
typically passes through a series of intermediate Mail Transfer
Agents (MTAs) en route to its destination.  

While these MTAs often apply channel-based security protections 
to their interactions (e.g., :term:`STARTTLS` :term:`[RFC3207]`), 
these protections do not prevent the MTAs from interfering with the message.  

In order to provide end-to-end security protections 
in the presence of untrusted MTAs, 
mail users can use S/MIME to embed message bodies 
in a secure object format that can provide confidentiality, 
integrity, and data origin authentication.

S/MIME is based on the Cryptographic Message Syntax for 
secure objects (CMS) :term:`[RFC5652]`.  

.. note::
    - S/MIME は ANS.1
    - XMLやJSONの方が使い易い

CMS is defined using **Abstract Syntax Notation 1** (:term:`ASN.1`) 
and typically encoded using the ASN.1 Distinguished Encoding Rules (:term:`DER`), 
which define a binary encoding of the protected message 
and associated parameters :term:`[ITU.X690.2002]`.  

In recent years, 
usage of ASN.1 has decreased 
(along with other binary encodings for general objects), 
while more applications have come to rely on text-based formats 
such as the Extensible Markup Language (:term:`XML`) :term:`[W3C.REC-xml]` 
or the JavaScript Object Notation (:term:`JSON`) :term:`[RFC4627]`.

Many current applications thus have much more robust support for
processing objects in these text-based formats than ASN.1 objects;
indeed, 
many lack the ability to process ASN.1 objects at all.  

To simplify the addition of object-based security features 
to these applications, 
the IETF JSON Object Signing and Encryption (:term:`JOSE`)
working group has been chartered to develop a secure object format
based on JSON.  

While the basic requirements for this object format
are straightforward -- 
namely, confidentiality and integrity mechanisms, 
encoded in JSON -- 
discussions in the working group indicated 
that different applications hoping to use the formats
defined by JOSE have different requirements.  

This document summarizes the use cases for JOSE envisioned 
by those potential applications and 
the resulting requirements for security mechanisms
and object encodings.

.. note::
    - XML ? 実装がANS.1並みに難しくなってます

Some systems that use XML have specified the use of XML-based
security mechanisms for object security, 
namely :term:`XML Digital Signatures` and :term:`XML Encryption` 
:term:`[W3C.xmldsig-core]` :term:`[W3C.xmlenc-core]`.

These mechanisms are defined for use 
with several security token systems 
(e.g., :term:`SAML` :term:`[OASIS.saml-core-2.0-os]` 
and :term:`WS-Federation` :term:`[WS-Federation]`)
and the :term:`CAP emergency alerting format` :term:`[CAP]`.  

In practice, however, 
XML-based secure object formats introduce 
similar levels of complexity to ASN.1 
(e.g., due to the need for XML canonicalization), 
so developers that lack the tools or motivation 
to handle ASN.1 aren't likely to use XML security either.  

This situation motivates the creation of a JSON-based secure object format
that is simple enough to implement and deploy that it can be easily
adopted by developers with minimal effort and tools.

(draft06)
