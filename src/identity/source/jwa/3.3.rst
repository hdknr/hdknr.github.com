3.3.  Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512
------------------------------------------------------------------------------------------------------------

The Elliptic Curve Digital Signature Algorithm (ECDSA) is defined by FIPS 186-3 [FIPS.186â€‘3]. ECDSA provides for the use of Elliptic Curve cryptography, which is able to provide equivalent security to RSA cryptography but using shorter key lengths and with greater processing speed. This means that ECDSA digital signatures will be substantially smaller in terms of length than equivalently strong RSA digital signatures.

This specification defines the use of ECDSA with the P-256 curve and the SHA-256 cryptographic hash function, ECDSA with the P-384 curve and the SHA-384 hash function, and ECDSA with the P-521 curve and the SHA-512 hash function. The P-256, P-384, and P-521 curves are also defined in FIPS 186-3. The alg (algorithm) header parameter values ES256, ES384, and ES512 are used in the JWS Header to indicate that the Encoded JWS Signature contains a base64url encoded ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512 digital signature, respectively.

The ECDSA P-256 SHA-256 digital signature is generated as follows:

    1.  Generate a digital signature of the UTF-8 representation of 
        the JWS Secured Input using ECDSA P-256 SHA-256 with the desired private key. 
        The output will be the EC point (R, S), where R and S are unsigned integers.
    2.  Turn R and S into byte arrays in big endian order. 
        Each array will be 32 bytes long.
    3.  Concatenate the two byte arrays in the order R and then S.
    4.  Base64url encode the resulting 64 byte array.

The output is the :term:`Encoded JWS Signature` for the JWS.

The ECDSA P-256 SHA-256 digital signature for a JWS is validated as follows:

    1.  Take the Encoded JWS Signature and base64url decode it into a byte array. If decoding fails, the JWS MUST be rejected.
    2.  The output of the base64url decoding MUST be a 64 byte array.
    3.  Split the 64 byte array into two 32 byte arrays. 
        The first array will be R and the second S. Remember that the byte arrays are in big endian byte order; 
        please check the ECDSA validator in use to see what byte order it requires.
    4.  Submit the UTF-8 representation of the :term:`JWS Secured Input`, R, S 
        and the public key (x, y) to the ECDSA P-256 SHA-256 validator.
    5.  If the validation fails, the JWS MUST be rejected.

The ECDSA validator will then determine if the digital signature is valid, given the inputs. Note that ECDSA digital signature contains a value referred to as K, which is a random number generated for each digital signature instance. This means that two ECDSA digital signatures using exactly the same input parameters will output different signature values because their K values will be different. The consequence of this is that one must validate an ECDSA digital signature by submitting the previously specified inputs to an ECDSA validator.

Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512 algorithms is performed identically to the procedure for ECDSA P-256 SHA-256 - just with correspondingly longer key and result values.


(00)
