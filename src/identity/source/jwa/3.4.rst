3.4. Digital Signature with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512
------------------------------------------------------------------------------------------------

The Elliptic Curve Digital Signature Algorithm (:term:`ECDSA`) :term:`[DSS]` provides
for the use of Elliptic Curve cryptography, which is able to provide
equivalent security to RSA cryptography but using **shorter key sizes**
and with **greater processing speed**.  
This means that ECDSA digital signatures will be substantially smaller 
in terms of length than equivalently strong RSA digital signatures.

This specification defines the use of ECDSA with the P-256 curve and
the SHA-256 cryptographic hash function, ECDSA with the P-384 curve
and the SHA-384 hash function, and ECDSA with the P-521 curve and the
SHA-512 hash function.  The P-256, P-384, and P-521 curves are
defined in [DSS].  The "alg" (algorithm) header parameter values
"ES256", "ES384", and "ES512" are used in the JWS Header to indicate
that the Encoded JWS Signature contains a base64url encoded ECDSA
P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512 digital
signature, respectively.

The ECDSA P-256 SHA-256 digital signature is generated as follows:

   1.  Generate a digital signature of the bytes of the ASCII
       representation of the JWS Secured Input using ECDSA P-256 SHA-256
       with the desired private key.  The output will be the pair (R,
       S), where R and S are 256 bit unsigned integers.

   2.  Turn R and S into byte arrays in big endian order, with each
       array being be 32 bytes long.  The array representations MUST not
       be shortened to omit any leading zero bytes contained in the
       values.

   3.  Concatenate the two byte arrays in the order R and then S. (Note
       that many ECDSA implementations will directly produce this
       concatenation as their output.)

   4.  Base64url encode the resulting 64 byte array.

The output is the Encoded JWS Signature for the JWS.

The ECDSA P-256 SHA-256 digital signature for a JWS is validated as follows:

   1.  Take the Encoded JWS Signature and base64url decode it into a
       byte array.  If decoding fails, the JWS MUST be rejected.

   2.  The output of the base64url decoding MUST be a 64 byte array.  If
       decoding does not result in a 64 byte array, the JWS MUST be
       rejected.

   3.  Split the 64 byte array into two 32 byte arrays.  The first array
       will be R and the second S (with both being in big endian byte
       order).

   4.  Submit the bytes of the ASCII representation of the JWS Secured
       Input R, S and the public key (x, y) to the ECDSA P-256 SHA-256
       validator.

   5.  If the validation fails, the JWS MUST be rejected.

Note that ECDSA digital signature contains a value referred to as K,
which is a random number generated for each digital signature
instance.  This means that two ECDSA digital signatures using exactly
the same input parameters will output different signature values
because their K values will be different.  A consequence of this is
that one cannot validate an ECDSA signature by recomputing the
signature and comparing the results.

Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512
algorithms is performed identically to the procedure for ECDSA P-256
SHA-256 - just using the corresponding hash algorithm with
correspondingly larger result values.  For ECDSA P-384 SHA-384, R and
S will be 384 bits each, resulting in a 96 byte array.  For ECDSA
P-521 SHA-512, R and S will be 521 bits each, resulting in a 132 byte
array.

Examples using these algorithms are shown in Appendices A.3 and A.4
of [JWS].

(draft 06 , http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-06#section-3.4 )
