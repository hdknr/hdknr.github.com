.. _oauth_threat.tokens:

3.1.  Tokens
------------------------------------------------------------

OAuth makes extensive use of many kinds of tokens 
(:term:`access tokens`,
:term:`refresh tokens`, authorization "codes").  

The information content of a token can be represented in two ways, 
as follows:

Handle (or artifact)  

      A 'handle' is a reference to some internal data
      structure within the authorization server; the internal data
      structure contains the attributes of the token, such as user id
      (UID), scope, etc.  Handles enable simple revocation and do not
      require cryptographic mechanisms to protect token content from
      being modified.  

      On the other hand, handles require communication
      between the issuing and consuming entity (e.g., the authorization
      server and resource server) in order to validate the token and
      obtain token-bound data.  This communication might have a negative
      impact on performance and scalability if both entities reside on
      different systems.  Handles are therefore typically used if the
      issuing and consuming entity are the same.  A 'handle' token is
      often referred to as an 'opaque' token because the resource server
      does not need to be able to interpret the token directly; it
      simply uses the token.

Assertion (aka self-contained token)  

      An assertion is a parseable token.  

      An assertion typically has a :term:`duration`, has an :term:`audience`,
      and is **digitally signed** in order to ensure **data integrity** and
      :term:`origin authentication`.  
      It contains information about the :term:`user` and the :term:`client`.  

      Examples of assertion formats are Security Assertion Markup Language (SAML) assertions 
      :term:`[OASIS.saml-core-2.0-os]` and Kerberos tickets :term:`[RFC4120]`.  

      Assertions can typically be directly
      validated and used by a resource server without interactions with
      the authorization server.  
      This results in better performance and
      scalability in deployments where the issuing and consuming
      entities reside on different systems.  

      Implementing token revocation is more difficult with assertions than with handles.

Tokens can be used in two ways to invoke requests 
on resource servers, as follows:

bearer token  

      A ':doc:`bearer token <oauth_bearer>`' is a token that can be used 
      by any client who has received the token 
      (e.g., :term:`[RFC6750]`).  

      Because mere possession is enough to use the token, 
      it is important that
      communication between endpoints be secured to ensure that only
      authorized endpoints may capture the token.  

      The bearer token is
      convenient for client applications, as it does not require them to
      do anything to use them (such as a proof of identity).  

      Bearer tokens have similar characteristics to web single-sign-on (SSO)
      cookies used in browsers.

proof token  

      A 'proof token' is a token that can only be used by a specific client.  

      Each use of the token requires the client to
      perform some action that proves that it is the authorized user of
      the token.  

      Examples of this are MAC-type access tokens, which
      require the client to digitally sign the resource request with a
      secret corresponding to the particular token sent with the request
      (e.g., [OAuth-HTTP-MAC]).

( http://tools.ietf.org/html/rfc6819#section-3.1 )
